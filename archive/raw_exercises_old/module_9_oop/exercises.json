{
  "version": "2.1.0",
  "theme_support": true,
  "generated_at": "2026-02-01T10:50:24.322115",
  "module": "module_9_oop",
  "count": 12,
  "exercise_types": [
    "blank_page",
    "complete_function",
    "fix_style",
    "which_is_better",
    "write_code"
  ],
  "exercises": [
    {
      "id": "module_9_oop.blank_page.exercise_1_blank_class_design",
      "topic_id": "oop.classes",
      "exercise_type": "blank_page",
      "category": "free_writing",
      "title": "Blank Class Design",
      "title_he": "×¢×™×¦×•×‘ ××—×œ×§×•×ª",
      "title_en": "Blank Class Design",
      "description_he": "×ª×›× ×•×ª ××•× ×—×” ×¢×¦××™×: ×¢×™×¦×•×‘ ××—×œ×§×•×ª\n\nExercise 1: Write From Scratch - Class Design\nDesign and implement classes from scratch based on specifications.\nThis is how real object-oriented programming works!\nTheme: Creating game entities for {{school}} adventure\n============================================================\nCHALLENGE A: EASY - Simple Item Class\n============================================================",
      "description_en": "Object-Oriented Programming: Blank Class Design\n\nExercise 1: Write From Scratch - Class Design\nDesign and implement classes from scratch based on specifications.\nThis is how real object-oriented programming works!\nTheme: Creating game entities for {{school}} adventure\n============================================================\nCHALLENGE A: EASY - Simple Item Class\n============================================================",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "problem_solving",
        "full_implementation",
        "independence"
      ],
      "starter_code": "# Exercise 1: Write From Scratch - Class Design\n#\n# Design and implement classes from scratch based on specifications.\n# This is how real object-oriented programming works!\n#\n# Theme: Creating game entities for {{school}} adventure\n\n\n# ============================================================\n# CHALLENGE A: EASY - Simple Item Class\n# ============================================================\n\nclass Item:\n    \"\"\"\n    A simple item that can be picked up.\n\n    Attributes:\n        name (str): The item's name\n        value (int): The item's worth in gold\n\n    Methods:\n        __init__(name, value=0): Create an item\n        __str__(): Return \"Item: {name} (worth {value} gold)\"\n\n    Examples:\n        >>> wand = Item(\"Elder Wand\", 1000)\n        >>> wand.name\n        'Elder Wand'\n        >>> wand.value\n        1000\n        >>> str(wand)\n        'Item: Elder Wand (worth 1000 gold)'\n    \"\"\"\n    # âœï¸ YOUR CODE HERE âœï¸\n    pass\n\n\n# ============================================================\n# CHALLENGE B: EASY - Counter Class\n# ============================================================\n\nclass Counter:\n    \"\"\"\n    A simple counter that can be incremented and reset.\n\n    Attributes:\n        count (int): Current count, starts at 0\n\n    Methods:\n        __init__(): Create counter at 0\n        increment(): Add 1 to count\n        reset(): Set count back to 0\n        __str__(): Return \"Count: {count}\"\n\n    Examples:\n        >>> c = Counter()\n        >>> c.count\n        0\n        >>> c.increment()\n        >>> c.increment()\n        >>> c.count\n        2\n        >>> c.reset()\n        >>> c.count\n        0\n    \"\"\"\n    # âœï¸ YOUR CODE HERE âœï¸\n    pass\n\n\n# ============================================================\n# CHALLENGE C: MEDIUM - Character Class\n# ============================================================\n\nclass Character:\n    \"\"\"\n    A game character with health and basic combat.\n\n    Attributes:\n        name (str): Character's name\n        max_health (int): Maximum health points\n        health (int): Current health points\n\n    Methods:\n        __init__(name, max_health=100): Create character\n        take_damage(amount): Reduce health (minimum 0)\n        heal(amount): Restore health (maximum max_health)\n        is_alive(): Return True if health > 0\n        __str__(): Return \"{name}: {health}/{max_health} HP\"\n\n    Examples:\n        >>> hero = Character(\"{{hero}}\", 100)\n        >>> hero.take_damage(30)\n        >>> hero.health\n        70\n        >>> hero.heal(50)\n        >>> hero.health\n        100  # Can't exceed max\n        >>> hero.is_alive()\n        True\n    \"\"\"\n    # âœï¸ YOUR CODE HERE âœï¸\n    pass\n\n\n# ============================================================\n# CHALLENGE D: MEDIUM - Inventory Class\n# ============================================================\n\nclass Inventory:\n    \"\"\"\n    A container for items with add/remove functionality.\n\n    Attributes:\n        items (list): List of Item objects\n        capacity (int): Maximum number of items\n\n    Methods:\n        __init__(capacity=10): Create empty inventory\n        add(item): Add item if space available, return True/False\n        remove(item_name): Remove item by name, return the item or None\n        find(item_name): Find item by name without removing\n        is_full(): Return True if at capacity\n        __len__(): Return number of items\n        __str__(): Return inventory contents\n\n    Examples:\n        >>> inv = Inventory(3)\n        >>> inv.add(Item(\"Wand\", 100))\n        True\n        >>> inv.add(Item(\"Potion\", 50))\n        True\n        >>> len(inv)\n        2\n        >>> inv.find(\"Wand\").value\n        100\n    \"\"\"\n    # âœï¸ YOUR CODE HERE âœï¸\n    pass\n\n\n# ============================================================\n# CHALLENGE E: HARD - Spell Class with Cooldown\n# ============================================================\n\nclass Spell:\n    \"\"\"\n    A spell with power, cost, and cooldown mechanics.\n\n    Attributes:\n        name (str): Spell name\n        power (int): Damage/effect strength\n        mana_cost (int): Mana required to cast\n        cooldown (int): Turns before can cast again\n        current_cooldown (int): Turns remaining until available\n\n    Methods:\n        __init__(name, power, mana_cost, cooldown=0): Create spell\n        can_cast(available_mana): True if enough mana and not on cooldown\n        cast(): Use the spell, set cooldown, return power\n        tick(): Reduce cooldown by 1 (minimum 0)\n        __str__(): Return spell info string\n\n    Examples:\n        >>> fireball = Spell(\"{{spell1}}\", 50, 30, cooldown=2)\n        >>> fireball.can_cast(30)\n        True\n        >>> damage = fireball.cast()\n        >>> damage\n        50\n        >>> fireball.can_cast(30)  # Now on cooldown\n        False\n        >>> fireball.tick()\n        >>> fireball.tick()\n        >>> fireball.can_cast(30)  # Cooldown finished\n        True\n    \"\"\"\n    # âœï¸ YOUR CODE HERE âœï¸\n    pass\n\n\n# ============================================================\n# CHALLENGE F: HARD - Player Class (Uses Other Classes)\n# ============================================================\n\nclass Player(Character):\n    \"\"\"\n    A player character that extends Character with inventory and spells.\n\n    Additional Attributes:\n        mana (int): Current mana\n        max_mana (int): Maximum mana\n        inventory (Inventory): Player's inventory\n        spells (list): List of known Spell objects\n\n    Additional Methods:\n        __init__(name, max_health=100, max_mana=50): Create player\n        learn_spell(spell): Add spell to known spells\n        cast_spell(spell_name, target): Cast spell on target if possible\n        rest(): Restore 25% health and mana\n        __str__(): Extended status string\n\n    Examples:\n        >>> player = Player(\"{{hero}}\")\n        >>> player.learn_spell(Spell(\"{{spell1}}\", 30, 20))\n        >>> enemy = Character(\"Troll\", 100)\n        >>> player.cast_spell(\"{{spell1}}\", enemy)\n        True\n        >>> enemy.health\n        70\n    \"\"\"\n    # âœï¸ YOUR CODE HERE âœï¸\n    pass\n\n\n# ============================================================\n# TESTS\n# ============================================================\n\ndef run_tests():\n    \"\"\"Test all classes.\"\"\"\n    print(\"Testing Class Implementations...\\n\")\n\n    # Test Item\n    print(\"A: Item\")\n    wand = Item(\"Elder Wand\", 1000)\n    assert wand.name == \"Elder Wand\"\n    assert wand.value == 1000\n    assert \"Elder Wand\" in str(wand)\n    print(\"   âœ“ Passed!\\n\")\n\n    # Test Counter\n    print(\"B: Counter\")\n    c = Counter()\n    assert c.count == 0\n    c.increment()\n    c.increment()\n    assert c.count == 2\n    c.reset()\n    assert c.count == 0\n    print(\"   âœ“ Passed!\\n\")\n\n    # Test Character\n    print(\"C: Character\")\n    hero = Character(\"{{hero}}\", 100)\n    assert hero.health == 100\n    hero.take_damage(30)\n    assert hero.health == 70\n    hero.heal(50)\n    assert hero.health == 100  # Capped at max\n    hero.take_damage(200)\n    assert hero.health == 0  # Minimum 0\n    assert hero.is_alive() == False\n    print(\"   âœ“ Passed!\\n\")\n\n    # Test Inventory\n    print(\"D: Inventory\")\n    inv = Inventory(2)\n    assert inv.add(Item(\"Wand\", 100)) == True\n    assert inv.add(Item(\"Potion\", 50)) == True\n    assert inv.add(Item(\"Book\", 30)) == False  # Full\n    assert len(inv) == 2\n    assert inv.find(\"Wand\").value == 100\n    removed = inv.remove(\"Potion\")\n    assert removed.name == \"Potion\"\n    assert len(inv) == 1\n    print(\"   âœ“ Passed!\\n\")\n\n    # Test Spell\n    print(\"E: Spell\")\n    fireball = Spell(\"{{spell1}}\", 50, 30, cooldown=2)\n    assert fireball.can_cast(30) == True\n    assert fireball.can_cast(10) == False  # Not enough mana\n    damage = fireball.cast()\n    assert damage == 50\n    assert fireball.can_cast(30) == False  # On cooldown\n    fireball.tick()\n    fireball.tick()\n    assert fireball.can_cast(30) == True\n    print(\"   âœ“ Passed!\\n\")\n\n    # Test Player\n    print(\"F: Player\")\n    player = Player(\"{{hero}}\", max_health=100, max_mana=50)\n    player.learn_spell(Spell(\"{{spell1}}\", 30, 20))\n    enemy = Character(\"Troll\", 100)\n    result = player.cast_spell(\"{{spell1}}\", enemy)\n    assert result == True\n    assert enemy.health == 70\n    assert player.mana == 30  # 50 - 20\n    print(\"   âœ“ Passed!\\n\")\n\n    print(\"=\" * 40)\n    print(\"All tests passed! ğŸ‰\")\n\n\ndef main():\n    print(\"=== Class Design Challenges ===\")\n    print()\n    print(\"Implement each class based on its docstring.\")\n    print(\"When ready, uncomment run_tests() to check your work.\")\n    print()\n\n    # Uncomment to run tests:\n    # run_tests()\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "blank_page"
      ],
      "source_file": "module_9_oop/blank_page/exercise_1_blank_class_design.py"
    },
    {
      "id": "module_9_oop.complete_function.exercise_8_text_adventure",
      "topic_id": "oop.project",
      "exercise_type": "complete_function",
      "category": "scaffolded_writing",
      "title": "Text Adventure",
      "title_he": "×”×¨×¤×ª×§×ª ×˜×§×¡×˜",
      "title_en": "Text Adventure",
      "description_he": "×ª×›× ×•×ª ××•× ×—×” ×¢×¦××™×: ×”×¨×¤×ª×§×ª ×˜×§×¡×˜\n\nExercise 8: Build a Text Adventure with Classes!\nPut it all together to create an object-oriented text adventure game!\nâœï¸ YOUR CODE HERE âœï¸\nCreate these classes for your adventure:",
      "description_en": "Object-Oriented Programming: Text Adventure\n\nExercise 8: Build a Text Adventure with Classes!\nPut it all together to create an object-oriented text adventure game!\nâœï¸ YOUR CODE HERE âœï¸\nCreate these classes for your adventure:",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "pattern_recognition",
        "working_with_constraints"
      ],
      "starter_code": "# Exercise 8: Build a Text Adventure with Classes!\n#\n# Put it all together to create an object-oriented text adventure game!\n\n\n# âœï¸ YOUR CODE HERE âœï¸\n# Create these classes for your adventure:\n\n\nclass Item:\n    \"\"\"An item that can be picked up and used\"\"\"\n\n    def __init__(self, name, description, usable=True):\n        # âœï¸ YOUR CODE HERE âœï¸\n        pass\n\n    def __str__(self):\n        return self.name\n\n\nclass Room:\n    \"\"\"A location in the game\"\"\"\n\n    def __init__(self, name, description):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # self.name = name\n        # self.description = description\n        # self.items = []  # Items in this room\n        # self.exits = {}  # {\"north\": another_room, \"south\": ...}\n        pass\n\n    def describe(self):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Print room name, description, items, and exits\n        pass\n\n    def add_exit(self, direction, room):\n        # âœï¸ YOUR CODE HERE âœï¸\n        pass\n\n\nclass Player:\n    \"\"\"The player character\"\"\"\n\n    def __init__(self, name):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # self.name = name\n        # self.inventory = []\n        # self.current_room = None\n        # self.health = 100\n        pass\n\n    def move(self, direction):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Check if direction is a valid exit\n        # If yes, move to that room\n        # If no, print \"You can't go that way!\"\n        pass\n\n    def take(self, item_name):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Find item in current room\n        # Add to inventory, remove from room\n        pass\n\n    def show_inventory(self):\n        # âœï¸ YOUR CODE HERE âœï¸\n        pass\n\n\nclass Game:\n    \"\"\"The main game controller\"\"\"\n\n    def __init__(self):\n        self.player = None\n        self.rooms = {}\n        self.running = True\n\n    def setup(self):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Create rooms and connect them\n        # Example:\n        # entrance = Room(\"{{school}} Entrance\", \"You stand before the great doors...\")\n        # hall = Room(\"{{location}}\", \"Magical lights illuminate the enormous room...\")\n        # entrance.add_exit(\"north\", hall)\n        # hall.add_exit(\"south\", entrance)\n        #\n        # Add items to rooms\n        # Set starting room\n        pass\n\n    def process_command(self, command):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Handle commands like:\n        # - \"go north\" / \"north\" - move\n        # - \"take [item]\" - pick up item\n        # - \"look\" - describe room\n        # - \"inventory\" / \"i\" - show inventory\n        # - \"quit\" - end game\n        pass\n\n    def play(self):\n        print(\"=\" * 50)\n        print(\"   WELCOME TO THE {{school}} ADVENTURE!\")\n        print(\"=\" * 50)\n\n        name = input(\"\\nWhat is your name, adventurer? \")\n        self.player = Player(name)\n        self.setup()\n\n        print(f\"\\n{{greeting}}, {name}!\")\n        print(\"Type 'help' for commands.\\n\")\n\n        self.player.current_room.describe()\n\n        while self.running:\n            command = input(\"\\n> \").lower().strip()\n            if command:\n                self.process_command(command)\n\n\ndef main():\n    # To play the game, complete the classes above and uncomment:\n    # game = Game()\n    # game.play()\n\n    print(\"Complete the classes above to play the adventure!\")\n    print(\"\\nHere's a simpler working example:\\n\")\n\n    # Mini working example\n    class SimpleRoom:\n        def __init__(self, name, desc):\n            self.name = name\n            self.desc = desc\n            self.exits = {}\n\n        def describe(self):\n            print(f\"\\n=== {self.name} ===\")\n            print(self.desc)\n            if self.exits:\n                print(\"Exits:\", \", \".join(self.exits.keys()))\n\n    # Create two connected rooms\n    start = SimpleRoom(\"{{school}} Gates\",\n                       \"The magnificent gates of {{school}} tower before you.\")\n    hall = SimpleRoom(\"{{location}}\",\n                      \"Magical lights line the walls. A grand staircase leads up.\")\n\n    start.exits[\"north\"] = hall\n    hall.exits[\"south\"] = start\n\n    current = start\n    current.describe()\n\n    # Simple game loop\n    for _ in range(3):  # Just 3 moves for demo\n        direction = input(\"\\nWhere do you go? \")\n        if direction in current.exits:\n            current = current.exits[direction]\n            current.describe()\n        else:\n            print(\"You can't go that way!\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [
        "Room class stores description, items list, and exits dict",
        "Player class tracks current_room and inventory",
        "Game class manages the loop and processes commands"
      ],
      "tags": [
        "module_9_oop",
        "complete_function"
      ],
      "source_file": "module_9_oop/complete_function/exercise_8_text_adventure.py"
    },
    {
      "id": "module_9_oop.complete_function.exercise_9_rpg_battle",
      "topic_id": "oop.project",
      "exercise_type": "complete_function",
      "category": "scaffolded_writing",
      "title": "RPG Battle",
      "title_he": "×§×¨×‘ RPG",
      "title_en": "RPG Battle",
      "description_he": "×ª×›× ×•×ª ××•× ×—×” ×¢×¦××™×: ×§×¨×‘ RPG\n\nExercise 9: Build a Complete RPG Battle System!\nCreate a turn-based battle game using everything you've learned!",
      "description_en": "Object-Oriented Programming: RPG Battle\n\nExercise 9: Build a Complete RPG Battle System!\nCreate a turn-based battle game using everything you've learned!",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "pattern_recognition",
        "working_with_constraints"
      ],
      "starter_code": "# Exercise 9: Build a Complete RPG Battle System!\n#\n# Create a turn-based battle game using everything you've learned!\n\nimport random\n\n\n# =====================\n# BASE CHARACTER CLASS\n# =====================\n\nclass Character:\n    \"\"\"Base class for all characters\"\"\"\n\n    def __init__(self, name, health=100, attack_power=10):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Set up: name, health, max_health, attack_power, is_defending\n        pass\n\n    def attack(self, target):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Calculate damage (reduced if target is defending)\n        # Apply damage to target\n        # Reset target's defending status\n        # Return the damage dealt\n        pass\n\n    def defend(self):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Set is_defending to True\n        pass\n\n    def is_alive(self):\n        # âœï¸ YOUR CODE HERE âœï¸\n        pass\n\n    def __str__(self):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Return a health bar like: \"{{hero}} [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘] 80/100 HP\"\n        pass\n\n\n# =====================\n# SPECIALIZED CLASSES\n# =====================\n\nclass Wizard(Character):\n    \"\"\"A wizard who can cast spells\"\"\"\n\n    def __init__(self, name, health=80, attack_power=8):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Call super().__init__\n        # Add mana = 100\n        pass\n\n    def cast_spell(self, spell_name, target):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Different spells with different effects and mana costs:\n        # - \"{{spell2}}\" (15 mana): 25 damage\n        # - \"{{spell3}}\" (30 mana): 40 damage\n        # - \"{{spell1}}\" (5 mana): just for show, no damage\n        # Return True if spell was cast, False if not enough mana\n        pass\n\n\nclass Warrior(Character):\n    \"\"\"A warrior who builds rage for powerful attacks\"\"\"\n\n    def __init__(self, name, health=120, attack_power=12):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Call super().__init__\n        # Add rage = 0\n        pass\n\n    def attack(self, target):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Normal attack + gain 20 rage\n        pass\n\n    def power_attack(self, target):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Requires 50 rage\n        # Deals 2.5x damage!\n        # Uses all rage\n        pass\n\n\nclass Healer(Character):\n    \"\"\"A healer who can restore health\"\"\"\n\n    def __init__(self, name, health=90, attack_power=6):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Add faith = 100\n        pass\n\n    def heal(self, target):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Costs 20 faith\n        # Heals 30 health (not above max_health!)\n        pass\n\n\n# =====================\n# BATTLE SYSTEM\n# =====================\n\nclass Battle:\n    \"\"\"Manages a battle between two characters\"\"\"\n\n    def __init__(self, player, enemy):\n        # âœï¸ YOUR CODE HERE âœï¸\n        pass\n\n    def show_status(self):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Print both characters' status\n        pass\n\n    def player_turn(self):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Show options based on player class:\n        # All: Attack, Defend\n        # Wizard: Cast Spell\n        # Warrior: Power Attack (if rage >= 50)\n        # Healer: Heal\n        # Get player choice and execute\n        pass\n\n    def enemy_turn(self):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Simple AI: random choice between attack and defend\n        # Or smarter: defend when low health, attack otherwise\n        pass\n\n    def run(self):\n        # âœï¸ YOUR CODE HERE âœï¸\n        # Main battle loop:\n        # While both alive:\n        #   - Show status\n        #   - Player turn\n        #   - Check if enemy defeated\n        #   - Enemy turn\n        #   - Check if player defeated\n        # Announce winner!\n        pass\n\n\n# =====================\n# MAIN GAME\n# =====================\n\ndef choose_character():\n    \"\"\"Let player choose their character class\"\"\"\n    print(\"\\nChoose your class:\")\n    print(\"1. Wizard (Low health, powerful spells)\")\n    print(\"2. Warrior (High health, builds rage)\")\n    print(\"3. Healer (Can heal, balanced stats)\")\n\n    choice = input(\"\\nEnter 1, 2, or 3: \")\n    name = input(\"Enter your name: \")\n\n    if choice == \"1\":\n        return Wizard(name)\n    elif choice == \"2\":\n        return Warrior(name)\n    else:\n        return Healer(name)\n\n\ndef main():\n    print(\"=\" * 50)\n    print(\"   âš”ï¸  RPG BATTLE ARENA  âš”ï¸\")\n    print(\"=\" * 50)\n\n    # For testing - uncomment when classes are complete:\n    # player = choose_character()\n    # enemy = Warrior(\"{{villain}}\", health=100, attack_power=15)\n    # battle = Battle(player, enemy)\n    # battle.run()\n\n    print(\"\\nComplete the classes above to play!\")\n    print(\"\\nHere's a mini working example:\\n\")\n\n    # Simple working demo\n    class SimpleFighter:\n        def __init__(self, name, hp):\n            self.name = name\n            self.hp = hp\n\n        def hit(self, target, damage):\n            target.hp -= damage\n            print(f\"{self.name} hits {target.name} for {damage}!\")\n            print(f\"{target.name} has {target.hp} HP left\")\n\n    hero = SimpleFighter(\"{{hero}}\", 100)\n    villain = SimpleFighter(\"{{villain}}\", 80)\n\n    print(\"=== Quick Battle Demo ===\")\n    while hero.hp > 0 and villain.hp > 0:\n        # Hero attacks\n        hero.hit(villain, random.randint(10, 20))\n        if villain.hp <= 0:\n            break\n        # Villain attacks\n        villain.hit(hero, random.randint(8, 15))\n\n    winner = hero if hero.hp > 0 else villain\n    print(f\"\\nğŸ† {winner.name} wins!\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [
        "Base Character class has attack, defend, is_alive methods",
        "Subclasses add special abilities: Wizard has cast_spell",
        "Battle class alternates turns between player and enemy"
      ],
      "tags": [
        "module_9_oop",
        "complete_function"
      ],
      "source_file": "module_9_oop/complete_function/exercise_9_rpg_battle.py"
    },
    {
      "id": "module_9_oop.fix_style.exercise_1_fix_class_style",
      "topic_id": "oop.style",
      "exercise_type": "fix_style",
      "category": "improvement",
      "title": "Fix Class Style",
      "title_he": "×ª×™×§×•×Ÿ ×¡×’× ×•×Ÿ ××—×œ×§×•×ª",
      "title_en": "Fix Class Style",
      "description_he": "×ª×›× ×•×ª ××•× ×—×” ×¢×¦××™×: ×ª×™×§×•×Ÿ ×¡×’× ×•×Ÿ ××—×œ×§×•×ª\n\nExercise 1: Fix the Style - Class Style\nThis code WORKS but has terrible class style! Fix the issues:\n- Incorrect naming conventions for classes\n- Missing or poor docstrings\n- Public attributes that should be managed\n- Poor method organization\n- Inconsistent __str__ / __repr__\nTheme: Character classes for {{school}} adventure game\n============================================================\nSTYLE FIX A: Class Naming\n============================================================",
      "description_en": "Object-Oriented Programming: Fix Class Style\n\nExercise 1: Fix the Style - Class Style\nThis code WORKS but has terrible class style! Fix the issues:\n- Incorrect naming conventions for classes\n- Missing or poor docstrings\n- Public attributes that should be managed\n- Poor method organization\n- Inconsistent __str__ / __repr__\nTheme: Character classes for {{school}} adventure game\n============================================================\nSTYLE FIX A: Class Naming\n============================================================",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 8,
      "skills": [
        "pep8",
        "readability",
        "conventions",
        "code_quality"
      ],
      "starter_code": "# Exercise 1: Fix the Style - Class Style\n#\n# This code WORKS but has terrible class style! Fix the issues:\n# - Incorrect naming conventions for classes\n# - Missing or poor docstrings\n# - Public attributes that should be managed\n# - Poor method organization\n# - Inconsistent __str__ / __repr__\n#\n# Theme: Character classes for {{school}} adventure game\n\n\n# ============================================================\n# STYLE FIX A: Class Naming\n# ============================================================\n\nclass wizard_character:\n    \"\"\"ORIGINAL - Wrong naming convention for class\"\"\"\n    def __init__(self, name):\n        self.name = name\n\n\nclass SPELL_BOOK:\n    \"\"\"ORIGINAL - Wrong naming convention (not a constant)\"\"\"\n    def __init__(self):\n        self.spells = []\n\n\n# âœï¸ FIX THE STYLE âœï¸\n# Classes should use CapitalizedWords (PascalCase)\n\nclass WizardCharacter:\n    \"\"\"A wizard character in the game.\"\"\"\n    def __init__(self, name):\n        # Your fixed code here\n        pass\n\n\nclass SpellBook:\n    \"\"\"A collection of spells.\"\"\"\n    def __init__(self):\n        # Your fixed code here\n        pass\n\n\n# ============================================================\n# STYLE FIX B: Missing Docstrings\n# ============================================================\n\nclass original_b:\n    def __init__(self, n, h, p):\n        self.n = n\n        self.h = h\n        self.p = p\n\n    def a(self, x):\n        self.p = self.p + x\n\n    def t(self, d):\n        self.h = self.h - d\n\n\nclass Character:\n    # âœï¸ FIX THE STYLE âœï¸\n    # - Add class docstring\n    # - Add method docstrings\n    # - Rename attributes to be descriptive\n    # - Rename methods to be descriptive\n    # What are n, h, p? What do a() and t() do?\n\n    def __init__(self, name, health, power):\n        \"\"\"Initialize a character with name, health, and power.\"\"\"\n        pass\n\n    def add_power(self, amount):\n        \"\"\"Add power points to the character.\"\"\"\n        pass\n\n    def take_damage(self, damage):\n        \"\"\"Reduce health by damage amount.\"\"\"\n        pass\n\n\n# ============================================================\n# STYLE FIX C: Method Organization\n# ============================================================\n\nclass original_c:\n    \"\"\"ORIGINAL - Methods in random order\"\"\"\n\n    def cast_spell(self, spell):\n        print(f\"Casting {spell}\")\n\n    def __init__(self, name):\n        self.name = name\n        self.health = 100\n\n    def __str__(self):\n        return self.name\n\n    def heal(self, amount):\n        self.health += amount\n\n    def get_health(self):\n        return self.health\n\n\nclass OrganizedCharacter:\n    # âœï¸ FIX THE STYLE âœï¸\n    # Organize methods in standard order:\n    # 1. __init__ first\n    # 2. __str__, __repr__ next (dunder methods)\n    # 3. Properties/getters\n    # 4. Regular methods (alphabetically or by purpose)\n\n    \"\"\"A well-organized character class.\"\"\"\n\n    # Write methods in proper order here\n    pass\n\n\n# ============================================================\n# STYLE FIX D: String Representation\n# ============================================================\n\nclass original_d:\n    \"\"\"ORIGINAL - Inconsistent/missing string methods\"\"\"\n\n    def __init__(self, name, spell_type, power):\n        self.name = name\n        self.spell_type = spell_type\n        self.power = power\n\n    def __str__(self):\n        return self.name  # Too little info\n\n    # No __repr__ at all!\n\n\nclass Spell:\n    # âœï¸ FIX THE STYLE âœï¸\n    # Add proper __str__ and __repr__:\n    # - __str__ should be human-readable\n    # - __repr__ should be unambiguous, ideally reproducible\n\n    \"\"\"A magical spell with name, type, and power level.\"\"\"\n\n    def __init__(self, name, spell_type, power):\n        pass\n\n    def __str__(self):\n        # Human-readable: \"Fireball (fire) - Power: 50\"\n        pass\n\n    def __repr__(self):\n        # Unambiguous: \"Spell('Fireball', 'fire', 50)\"\n        pass\n\n\n# ============================================================\n# STYLE FIX E: Attribute Access\n# ============================================================\n\nclass original_e:\n    \"\"\"ORIGINAL - Direct attribute manipulation\"\"\"\n\n    def __init__(self, name):\n        self.name = name\n        self.health = 100\n        self.max_health = 100\n        self.gold = 0\n\n    # Anyone can do: character.health = -999 (bad!)\n    # Anyone can do: character.gold = 1000000 (cheating!)\n\n\nclass ProtectedCharacter:\n    # âœï¸ FIX THE STYLE âœï¸\n    # Use properties or methods to control attribute access.\n    # Prevent invalid values like negative health.\n\n    \"\"\"A character with protected attributes.\"\"\"\n\n    def __init__(self, name):\n        self.name = name\n        self._health = 100  # \"Private\" by convention\n        self._max_health = 100\n        self._gold = 0\n\n    @property\n    def health(self):\n        \"\"\"Get current health.\"\"\"\n        pass\n\n    @health.setter\n    def health(self, value):\n        \"\"\"Set health, clamped to valid range.\"\"\"\n        # Ensure health stays between 0 and max_health\n        pass\n\n    def add_gold(self, amount):\n        \"\"\"Add gold (must be positive).\"\"\"\n        # Only allow adding positive amounts\n        pass\n\n    @property\n    def gold(self):\n        \"\"\"Get current gold.\"\"\"\n        pass\n\n\n# ============================================================\n# STYLE FIX F: Complete Class Cleanup\n# ============================================================\n\nclass orig:\n    \"\"\"ORIGINAL - Everything wrong at once\"\"\"\n    def m(self,s):\n        self.s.append(s)\n    def __init__(self,n):\n        self.n=n\n        self.s=[]\n        self.hp=100\n    def __str__(self):return self.n\n    def atk(self,t):t.hp=t.hp-10\n\n\nclass Hero:\n    # âœï¸ FIX THE STYLE âœï¸\n    # Complete cleanup needed:\n    # - Class docstring\n    # - Proper __init__ (first, with spacing)\n    # - Descriptive attribute names\n    # - Method docstrings\n    # - Descriptive method names\n    # - Proper spacing throughout\n    # - Good __str__ and __repr__\n\n    \"\"\"A hero character for the adventure game.\"\"\"\n\n    def __init__(self, name):\n        \"\"\"Initialize hero with name, empty spell list, and full health.\"\"\"\n        pass\n\n    def __str__(self):\n        \"\"\"Return human-readable string.\"\"\"\n        pass\n\n    def __repr__(self):\n        \"\"\"Return unambiguous representation.\"\"\"\n        pass\n\n    def learn_spell(self, spell_name):\n        \"\"\"Add a spell to the hero's known spells.\"\"\"\n        pass\n\n    def attack(self, target):\n        \"\"\"Attack another character, dealing damage.\"\"\"\n        pass\n\n\ndef main():\n    print(\"=== Style Fix A: Class Naming ===\")\n    bad_wizard = wizard_character(\"{{hero}}\")\n    print(f\"Bad style: {bad_wizard.name}\")\n    # good_wizard = WizardCharacter(\"{{hero}}\")\n    # print(f\"Good style: {good_wizard.name}\")\n\n    print(\"\\n=== Style Fix B: Docstrings ===\")\n    bad_char = original_b(\"{{hero}}\", 100, 50)\n    bad_char.a(10)  # What does this do?\n    bad_char.t(25)  # What does this do?\n    print(f\"n={bad_char.n}, h={bad_char.h}, p={bad_char.p}\")  # Confusing!\n\n    print(\"\\n=== Style Fix D: String Representation ===\")\n    spell = original_d(\"{{spell1}}\", \"fire\", 50)\n    print(f\"str: {str(spell)}\")\n    print(f\"repr: {repr(spell)}\")  # Not helpful!\n\n    print(\"\\n=== Test your fixed classes! ===\")\n    print(\"Uncomment the test code in main() to verify your fixes.\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "fix_style"
      ],
      "source_file": "module_9_oop/fix_style/exercise_1_fix_class_style.py"
    },
    {
      "id": "module_9_oop.which_is_better.exercise_1_compare_inheritance_vs_composition",
      "topic_id": "oop.composition",
      "exercise_type": "which_is_better",
      "category": "analysis",
      "title": "Compare Inheritance vs Composition",
      "title_he": "×”×©×•×•××ª ×”×•×¨×©×” ××•×œ ×”×¨×›×‘×”",
      "title_en": "Compare Inheritance vs Composition",
      "description_he": "×ª×›× ×•×ª ××•× ×—×” ×¢×¦××™×: ×”×©×•×•××ª ×”×•×¨×©×” ××•×œ ×”×¨×›×‘×”\n\nExercise 1: Which is Better? - Inheritance vs Composition\nFor each pair of solutions, both work correctly.\nYour job: Analyze and explain which is better AND WHY.\nSometimes the answer is \"it depends\"!\nTheme: Designing magical beings for {{school}}\n============================================================\nCOMPARISON A: Character with Abilities\n============================================================\nVersion 1: Inheritance",
      "description_en": "Object-Oriented Programming: Compare Inheritance vs Composition\n\nExercise 1: Which is Better? - Inheritance vs Composition\nFor each pair of solutions, both work correctly.\nYour job: Analyze and explain which is better AND WHY.\nSometimes the answer is \"it depends\"!\nTheme: Designing magical beings for {{school}}\n============================================================\nCOMPARISON A: Character with Abilities\n============================================================\nVersion 1: Inheritance",
      "difficulty": 3,
      "requires_running": false,
      "estimated_time_minutes": 10,
      "skills": [
        "critical_thinking",
        "trade_offs",
        "code_judgment"
      ],
      "starter_code": "# Exercise 1: Which is Better? - Inheritance vs Composition\n#\n# For each pair of solutions, both work correctly.\n# Your job: Analyze and explain which is better AND WHY.\n# Sometimes the answer is \"it depends\"!\n#\n# Theme: Designing magical beings for {{school}}\n\n\n# ============================================================\n# COMPARISON A: Character with Abilities\n# ============================================================\n\n# Version 1: Inheritance\nclass Character_A1:\n    def __init__(self, name):\n        self.name = name\n\n\nclass SpellCaster_A1(Character_A1):\n    def cast_spell(self, spell):\n        return f\"{self.name} casts {spell}!\"\n\n\n# Version 2: Composition\nclass SpellAbility:\n    def cast_spell(self, caster_name, spell):\n        return f\"{caster_name} casts {spell}!\"\n\n\nclass Character_A2:\n    def __init__(self, name, can_cast_spells=False):\n        self.name = name\n        self.spell_ability = SpellAbility() if can_cast_spells else None\n\n    def cast_spell(self, spell):\n        if self.spell_ability:\n            return self.spell_ability.cast_spell(self.name, spell)\n        return f\"{self.name} cannot cast spells!\"\n\n\ndef analysis_a():\n    # âœï¸ YOUR ANALYSIS âœï¸\n    # Which is better: A1 (inheritance) or A2 (composition)?\n    # Consider: flexibility, simplicity, adding new abilities\n\n    analysis = \"\"\"\n    Better version: ??? (or \"it depends\")\n\n    Reasons:\n    1.\n    2.\n\n    When to use inheritance (A1):\n    -\n\n    When to use composition (A2):\n    -\n    \"\"\"\n    return analysis\n\n\n# ============================================================\n# COMPARISON B: Multiple Abilities\n# ============================================================\n\n# Version 1: Multiple Inheritance\nclass Flyer_B1:\n    def fly(self):\n        return f\"{self.name} flies through the air!\"\n\n\nclass Swimmer_B1:\n    def swim(self):\n        return f\"{self.name} swims gracefully!\"\n\n\nclass Dragon_B1(Character_A1, Flyer_B1):\n    pass\n\n\nclass Mermaid_B1(Character_A1, Swimmer_B1):\n    pass\n\n\n# What if we want a creature that can both fly AND swim?\n# class FlyingFish_B1(Character_A1, Flyer_B1, Swimmer_B1):\n#     pass  # This works but gets complicated...\n\n\n# Version 2: Composition with multiple abilities\nclass FlyAbility:\n    def fly(self, creature_name):\n        return f\"{creature_name} flies through the air!\"\n\n\nclass SwimAbility:\n    def swim(self, creature_name):\n        return f\"{creature_name} swims gracefully!\"\n\n\nclass Creature_B2:\n    def __init__(self, name, abilities=None):\n        self.name = name\n        self.abilities = abilities or {}\n\n    def fly(self):\n        if \"fly\" in self.abilities:\n            return self.abilities[\"fly\"].fly(self.name)\n        return f\"{self.name} cannot fly!\"\n\n    def swim(self):\n        if \"swim\" in self.abilities:\n            return self.abilities[\"swim\"].swim(self.name)\n        return f\"{self.name} cannot swim!\"\n\n\ndef analysis_b():\n    # âœï¸ YOUR ANALYSIS âœï¸\n    # Which handles multiple abilities better?\n    # Consider: diamond problem, flexibility, code reuse\n\n    analysis = \"\"\"\n    Better version: ??? (or \"it depends\")\n\n    Reasons:\n    1.\n    2.\n\n    When to use multiple inheritance (B1):\n    -\n\n    When to use composition (B2):\n    -\n    \"\"\"\n    return analysis\n\n\n# ============================================================\n# COMPARISON C: Is-A vs Has-A Relationship\n# ============================================================\n\n# Version 1: Inheritance (Wizard IS-A Person)\nclass Person_C1:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def greet(self):\n        return f\"Hello, I'm {self.name}!\"\n\n\nclass Wizard_C1(Person_C1):\n    def __init__(self, name, age, wand):\n        super().__init__(name, age)\n        self.wand = wand\n\n    def cast(self):\n        return f\"{self.name} waves their {self.wand}!\"\n\n\n# Version 2: Composition (Wizard HAS-A Wand)\nclass Wand:\n    def __init__(self, wood, core):\n        self.wood = wood\n        self.core = core\n\n    def wave(self):\n        return f\"The {self.wood} wand with {self.core} core glows!\"\n\n\nclass Wizard_C2:\n    def __init__(self, name, age, wand):\n        self.name = name\n        self.age = age\n        self.wand = wand  # Has-a relationship\n\n    def greet(self):\n        return f\"Hello, I'm {self.name}!\"\n\n    def cast(self):\n        return f\"{self.name}: {self.wand.wave()}\"\n\n\ndef analysis_c():\n    # âœï¸ YOUR ANALYSIS âœï¸\n    # Is a Wizard more of a \"type of Person\" or \"has equipment\"?\n    # Consider: what changes, what stays the same\n\n    analysis = \"\"\"\n    Better version: ??? (or \"it depends\")\n\n    Reasons:\n    1.\n    2.\n\n    When inheritance makes sense:\n    -\n\n    When composition makes sense:\n    -\n    \"\"\"\n    return analysis\n\n\n# ============================================================\n# COMPARISON D: Extending Behavior\n# ============================================================\n\n# Version 1: Override via inheritance\nclass Animal_D1:\n    def speak(self):\n        return \"...\"\n\n\nclass Dog_D1(Animal_D1):\n    def speak(self):\n        return \"Woof!\"\n\n\nclass Cat_D1(Animal_D1):\n    def speak(self):\n        return \"Meow!\"\n\n\n# Version 2: Strategy pattern (composition)\nclass SpeakBehavior:\n    def speak(self):\n        return \"...\"\n\n\nclass WoofBehavior(SpeakBehavior):\n    def speak(self):\n        return \"Woof!\"\n\n\nclass MeowBehavior(SpeakBehavior):\n    def speak(self):\n        return \"Meow!\"\n\n\nclass Animal_D2:\n    def __init__(self, name, speak_behavior):\n        self.name = name\n        self.speak_behavior = speak_behavior\n\n    def speak(self):\n        return self.speak_behavior.speak()\n\n    def set_speak_behavior(self, new_behavior):\n        \"\"\"Can change behavior at runtime!\"\"\"\n        self.speak_behavior = new_behavior\n\n\ndef analysis_d():\n    # âœï¸ YOUR ANALYSIS âœï¸\n    # Which is better for changing behavior?\n    # Consider: runtime changes, testing, simplicity\n\n    analysis = \"\"\"\n    Better version: ??? (or \"it depends\")\n\n    Reasons:\n    1.\n    2.\n\n    When to use method override (D1):\n    -\n\n    When to use strategy pattern (D2):\n    -\n    \"\"\"\n    return analysis\n\n\n# ============================================================\n# COMPARISON E: Real-World Scenario\n# ============================================================\n\n# Scenario: A game with characters, items, and abilities\n# Version 1 would use deep inheritance hierarchies\n# Version 2 uses composition for flexibility\n\n# Version 2 example (preferred for games):\nclass GameEntity:\n    def __init__(self, name):\n        self.name = name\n        self.components = {}\n\n    def add_component(self, name, component):\n        self.components[name] = component\n\n    def get_component(self, name):\n        return self.components.get(name)\n\n\nclass HealthComponent:\n    def __init__(self, max_hp):\n        self.max_hp = max_hp\n        self.current_hp = max_hp\n\n    def take_damage(self, amount):\n        self.current_hp = max(0, self.current_hp - amount)\n        return self.current_hp\n\n    def heal(self, amount):\n        self.current_hp = min(self.max_hp, self.current_hp + amount)\n        return self.current_hp\n\n\nclass MagicComponent:\n    def __init__(self, spells):\n        self.spells = spells\n\n    def cast(self, spell_name):\n        if spell_name in self.spells:\n            return f\"Casting {spell_name}!\"\n        return f\"Unknown spell: {spell_name}\"\n\n\ndef analysis_e():\n    # âœï¸ YOUR ANALYSIS âœï¸\n    # For a game with many entity types, which approach scales better?\n    # Consider: adding new features, combining behaviors, maintainability\n\n    analysis = \"\"\"\n    Better version: ??? (or \"it depends\")\n\n    Reasons:\n    1.\n    2.\n\n    When deep inheritance works:\n    -\n\n    When component composition works:\n    -\n    \"\"\"\n    return analysis\n\n\ndef main():\n    print(\"=== Comparison A: Character with Abilities ===\")\n    wizard1 = SpellCaster_A1(\"{{hero}}\")\n    print(f\"Inheritance: {wizard1.cast_spell('{{spell1}}')}\")\n\n    wizard2 = Character_A2(\"{{hero}}\", can_cast_spells=True)\n    muggle = Character_A2(\"{{friend}}\", can_cast_spells=False)\n    print(f\"Composition (wizard): {wizard2.cast_spell('{{spell1}}')}\")\n    print(f\"Composition (non-wizard): {muggle.cast_spell('{{spell1}}')}\")\n    print(f\"\\nAnalysis:{analysis_a()}\")\n\n    print(\"\\n=== Comparison B: Multiple Abilities ===\")\n    dragon = Dragon_B1(\"{{creature}}\")\n    print(f\"Inheritance: {dragon.fly()}\")\n\n    flying_fish = Creature_B2(\"Flying Fish\", {\n        \"fly\": FlyAbility(),\n        \"swim\": SwimAbility()\n    })\n    print(f\"Composition (fly): {flying_fish.fly()}\")\n    print(f\"Composition (swim): {flying_fish.swim()}\")\n    print(f\"\\nAnalysis:{analysis_b()}\")\n\n    print(\"\\n=== Comparison C: Is-A vs Has-A ===\")\n    wizard3 = Wizard_C1(\"{{hero}}\", 11, \"Holly wand\")\n    print(f\"Inheritance: {wizard3.cast()}\")\n\n    wand = Wand(\"Holly\", \"Phoenix feather\")\n    wizard4 = Wizard_C2(\"{{hero}}\", 11, wand)\n    print(f\"Composition: {wizard4.cast()}\")\n    print(f\"\\nAnalysis:{analysis_c()}\")\n\n    print(\"\\n=== Comparison D: Extending Behavior ===\")\n    dog1 = Dog_D1()\n    print(f\"Inheritance: {dog1.speak()}\")\n\n    dog2 = Animal_D2(\"Fido\", WoofBehavior())\n    print(f\"Composition: {dog2.speak()}\")\n    dog2.set_speak_behavior(MeowBehavior())  # Change at runtime!\n    print(f\"After change: {dog2.speak()}\")\n    print(f\"\\nAnalysis:{analysis_d()}\")\n\n    print(\"\\n=== Comparison E: Game Entity System ===\")\n    hero = GameEntity(\"{{hero}}\")\n    hero.add_component(\"health\", HealthComponent(100))\n    hero.add_component(\"magic\", MagicComponent([\"{{spell1}}\", \"{{spell2}}\"]))\n\n    health = hero.get_component(\"health\")\n    magic = hero.get_component(\"magic\")\n    print(f\"Hero HP: {health.current_hp}\")\n    print(f\"Take damage: {health.take_damage(30)} HP remaining\")\n    print(f\"Cast spell: {magic.cast('{{spell1}}')}\")\n    print(f\"\\nAnalysis:{analysis_e()}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "which_is_better"
      ],
      "source_file": "module_9_oop/which_is_better/exercise_1_compare_inheritance_vs_composition.py"
    },
    {
      "id": "module_9_oop.write_code.exercise_1_first_class",
      "topic_id": "oop.classes",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "First Class",
      "title_he": "××—×œ×§×” ×¨××©×•× ×”",
      "title_en": "First Class",
      "description_he": "×ª×›× ×•×ª ××•× ×—×” ×¢×¦××™×: ××—×œ×§×” ×¨××©×•× ×”\n\nExercise 1: Your First Class!\nA class is like a blueprint for creating objects.\nThink of it like a character sheet template that you fill in for each character!",
      "description_en": "Object-Oriented Programming: First Class\n\nExercise 1: Your First Class!\nA class is like a blueprint for creating objects.\nThink of it like a character sheet template that you fill in for each character!",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "# Exercise 1: Your First Class!\n#\n# A class is like a blueprint for creating objects.\n# Think of it like a character sheet template that you fill in for each character!\n\n\ndef exercise_a():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a simple class called Character\n    # Give it a class attribute: school = \"{{school}}\"\n    # Then create an instance and print its school\n    #\n    # Example structure:\n    # class Character:\n    #     school = \"{{school}}\"\n    #\n    # hero = Character()\n    # print(hero.school)\n    pass\n\n\ndef exercise_b():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Spell class with these attributes:\n    # - name = \"{{spell1}}\"\n    # - power = 10\n    # - learned = True\n    # Create an instance and print all its attributes\n    pass\n\n\ndef exercise_c():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create TWO different characters from the same class\n    # Give them different names by setting the attribute after creation:\n    # hero1 = Character()\n    # hero1.name = \"{{hero}}\"\n    # hero2 = Character()\n    # hero2.name = \"{{heroine}}\"\n    pass\n\n\ndef exercise_d():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Pet class\n    # Give it attributes: species, name, owner\n    # Create {{pet}} (an owl) owned by {{hero}}\n    pass\n\n\ndef exercise_e():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a class with multiple attributes\n    # Class: Student\n    # Attributes: name, house, year, wand, pet\n    # Create yourself as a student!\n    pass\n\n\nclass ExampleCharacter:\n    \"\"\"This is a complete example to study!\"\"\"\n    school = \"{{school}}\"\n    house = \"{{house}}\"\n    year = 1\n\n    # You can add as many attributes as you want!\n    health = 100\n    spells_known = []\n\n\ndef show_example():\n    print(\"Here's how to use the example class:\")\n    student = ExampleCharacter()\n    print(f\"School: {student.school}\")\n    print(f\"House: {student.house}\")\n    print(f\"Year: {student.year}\")\n\n    # You can change attributes!\n    student.year = 2\n    print(f\"After one year: Year {student.year}\")\n\n\ndef main():\n    print(\"=== Exercise A: First Class ===\")\n    exercise_a()\n\n    print(\"\\n=== Exercise B: Spell Class ===\")\n    exercise_b()\n\n    print(\"\\n=== Exercise C: Multiple Instances ===\")\n    exercise_c()\n\n    print(\"\\n=== Exercise D: Pet Class ===\")\n    exercise_d()\n\n    print(\"\\n=== Exercise E: Complex Class ===\")\n    exercise_e()\n\n    print(\"\\n=== Example to Study ===\")\n    show_example()\n\n\nmain()\n",
      "solution_code": null,
      "hints": [
        "Define a class with: class ClassName:",
        "Add attributes inside the class: school = \"value\"",
        "Create instance: obj = ClassName(), access: obj.school"
      ],
      "tags": [
        "module_9_oop",
        "write_code"
      ],
      "source_file": "module_9_oop/write_code/exercise_1_first_class.py"
    },
    {
      "id": "module_9_oop.write_code.exercise_2_init_method",
      "topic_id": "oop.init",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Init Method",
      "title_he": "××ª×•×“×ª ××ª×—×•×œ",
      "title_en": "Init Method",
      "description_he": "×ª×›× ×•×ª ××•× ×—×” ×¢×¦××™×: ××ª×•×“×ª ××ª×—×•×œ\n\nExercise 2: The __init__ Method (Constructor!)\nThe __init__ method runs automatically when you create an object.\nIt's perfect for setting up your character with their starting stats!",
      "description_en": "Object-Oriented Programming: Init Method\n\nExercise 2: The __init__ Method (Constructor!)\nThe __init__ method runs automatically when you create an object.\nIt's perfect for setting up your character with their starting stats!",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "# Exercise 2: The __init__ Method (Constructor!)\n#\n# The __init__ method runs automatically when you create an object.\n# It's perfect for setting up your character with their starting stats!\n\n\ndef exercise_a():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Character class with an __init__ method\n    # that takes a name parameter\n    #\n    # class Character:\n    #     def __init__(self, name):\n    #         self.name = name\n    #\n    # hero = Character(\"{{hero}}\")\n    # print(hero.name)\n    pass\n\n\ndef exercise_b():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Character with multiple init parameters:\n    # - name\n    # - house\n    # - year\n    # Create {{heroine}} in {{house}}, year 5\n    pass\n\n\ndef exercise_c():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Use DEFAULT values in __init__!\n    # def __init__(self, name, health=100, level=1):\n    # Create a character with just a name (uses defaults)\n    # Create another with custom health and level\n    pass\n\n\ndef exercise_d():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Spell class where __init__ calculates something!\n    # Parameters: name, base_power, level\n    # In __init__, calculate: actual_power = base_power * level\n    pass\n\n\ndef exercise_e():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Student class that initializes a list!\n    # Each student starts with an empty spell list:\n    # def __init__(self, name):\n    #     self.name = name\n    #     self.spells = []  # Empty list for each student!\n    # Create two students and add different spells to each\n    pass\n\n\ndef exercise_f():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a comprehensive Character class:\n    # __init__ takes: name, character_class (wizard/warrior/healer)\n    # Based on character_class, set different starting stats:\n    # - wizard: health=80, magic=100, strength=30\n    # - warrior: health=120, magic=20, strength=100\n    # - healer: health=100, magic=80, strength=40\n    pass\n\n\nclass ExampleCharacter:\n    \"\"\"Study this example!\"\"\"\n\n    def __init__(self, name, house=\"{{house}}\"):\n        # 'self' refers to the object being created\n        self.name = name\n        self.house = house\n        # You can set attributes that aren't parameters too!\n        self.health = 100\n        self.inventory = []\n\n        # You can even print when an object is created!\n        print(f\"âœ¨ {name} has joined {house}!\")\n\n\ndef show_example():\n    print(\"Creating characters with __init__:\")\n    hero = ExampleCharacter(\"{{hero}}\")\n    friend = ExampleCharacter(\"{{friend}}\", \"{{house}}\")\n\n    print(f\"\\n{hero.name}'s house: {hero.house}\")\n    print(f\"{friend.name}'s house: {friend.house}\")\n\n\ndef main():\n    print(\"=== Exercise A: Basic __init__ ===\")\n    exercise_a()\n\n    print(\"\\n=== Exercise B: Multiple Parameters ===\")\n    exercise_b()\n\n    print(\"\\n=== Exercise C: Default Values ===\")\n    exercise_c()\n\n    print(\"\\n=== Exercise D: Calculated Attributes ===\")\n    exercise_d()\n\n    print(\"\\n=== Exercise E: Initialize Lists ===\")\n    exercise_e()\n\n    print(\"\\n=== Exercise F: Class-Based Stats ===\")\n    exercise_f()\n\n    print(\"\\n=== Example to Study ===\")\n    show_example()\n\n\nmain()\n",
      "solution_code": null,
      "hints": [
        "__init__ runs automatically when you create an object",
        "First parameter is always 'self': def __init__(self, name):",
        "Store values with self.name = name"
      ],
      "tags": [
        "module_9_oop",
        "write_code"
      ],
      "source_file": "module_9_oop/write_code/exercise_2_init_method.py"
    },
    {
      "id": "module_9_oop.write_code.exercise_3_methods",
      "topic_id": "oop.methods",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Methods",
      "title_he": "××ª×•×“×•×ª",
      "title_en": "Methods",
      "description_he": "×ª×›× ×•×ª ××•× ×—×” ×¢×¦××™×: ××ª×•×“×•×ª\n\nExercise 3: Methods - Making Objects DO Things!\nMethods are functions that belong to a class.\nThey let your objects perform actions!",
      "description_en": "Object-Oriented Programming: Methods\n\nExercise 3: Methods - Making Objects DO Things!\nMethods are functions that belong to a class.\nThey let your objects perform actions!",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "# Exercise 3: Methods - Making Objects DO Things!\n#\n# Methods are functions that belong to a class.\n# They let your objects perform actions!\n\n\ndef exercise_a():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Character class with a greet() method\n    #\n    # class Character:\n    #     def __init__(self, name):\n    #         self.name = name\n    #\n    #     def greet(self):\n    #         print(f\"{{greeting}} I'm {self.name}!\")\n    #\n    # hero = Character(\"{{hero}}\")\n    # hero.greet()\n    pass\n\n\ndef exercise_b():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Character with a take_damage(amount) method\n    # The method should subtract amount from health\n    # Print how much damage was taken and remaining health\n    pass\n\n\ndef exercise_c():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Character with:\n    # - heal(amount) method - adds health (but max 100!)\n    # - is_alive() method - returns True if health > 0\n    pass\n\n\ndef exercise_d():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Wizard class with:\n    # - __init__(name) - also sets mana = 100\n    # - cast_spell(spell_name, cost) - uses mana if enough available\n    # Try casting spells until mana runs out!\n    pass\n\n\ndef exercise_e():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create an Inventory class with methods:\n    # - add_item(item) - adds to the list\n    # - remove_item(item) - removes from list if present\n    # - show_items() - prints all items\n    # - has_item(item) - returns True/False\n    pass\n\n\ndef exercise_f():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Pet class with:\n    # - __init__(name, species) - also sets happiness = 50\n    # - feed() - increases happiness by 10\n    # - play() - increases happiness by 20\n    # - status() - prints how the pet is feeling based on happiness\n    pass\n\n\nclass ExampleCharacter:\n    \"\"\"A character with multiple methods\"\"\"\n\n    def __init__(self, name):\n        self.name = name\n        self.health = 100\n        self.level = 1\n        self.xp = 0\n\n    def attack(self, target):\n        damage = 10 * self.level\n        print(f\"{self.name} attacks {target} for {damage} damage!\")\n        return damage\n\n    def gain_xp(self, amount):\n        self.xp += amount\n        print(f\"{self.name} gained {amount} XP!\")\n\n        # Level up check\n        if self.xp >= 100:\n            self.level_up()\n\n    def level_up(self):\n        self.level += 1\n        self.xp -= 100\n        self.health += 20\n        print(f\"ğŸ‰ {self.name} reached level {self.level}!\")\n\n\ndef show_example():\n    hero = ExampleCharacter(\"{{hero}}\")\n    hero.attack(\"{{villain}}\")\n    hero.gain_xp(50)\n    hero.gain_xp(60)  # This should trigger level up!\n\n\ndef main():\n    print(\"=== Exercise A: Simple Method ===\")\n    exercise_a()\n\n    print(\"\\n=== Exercise B: Take Damage ===\")\n    exercise_b()\n\n    print(\"\\n=== Exercise C: Heal and Check ===\")\n    exercise_c()\n\n    print(\"\\n=== Exercise D: Wizard Spells ===\")\n    exercise_d()\n\n    print(\"\\n=== Exercise E: Inventory System ===\")\n    exercise_e()\n\n    print(\"\\n=== Exercise F: Pet Care ===\")\n    exercise_f()\n\n    print(\"\\n=== Example to Study ===\")\n    show_example()\n\n\nmain()\n",
      "solution_code": null,
      "hints": [
        "Methods are functions inside a class that take self first",
        "Use self.attribute to access the object's data",
        "Call methods with: object.method_name()"
      ],
      "tags": [
        "module_9_oop",
        "write_code"
      ],
      "source_file": "module_9_oop/write_code/exercise_3_methods.py"
    },
    {
      "id": "module_9_oop.write_code.exercise_4_str_repr",
      "topic_id": "oop.dunder",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "String Representation",
      "title_he": "×™×™×¦×•×’ ×˜×§×¡×˜×•××œ×™",
      "title_en": "String Representation",
      "description_he": "×ª×›× ×•×ª ××•× ×—×” ×¢×¦××™×: ×™×™×¦×•×’ ×˜×§×¡×˜×•××œ×™\n\nExercise 4: __str__ and __repr__ - Making Objects Printable!\nWhen you print() an object, Python calls its __str__ method.\nThis lets you control how your objects look when printed!",
      "description_en": "Object-Oriented Programming: String Representation\n\nExercise 4: __str__ and __repr__ - Making Objects Printable!\nWhen you print() an object, Python calls its __str__ method.\nThis lets you control how your objects look when printed!",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "# Exercise 4: __str__ and __repr__ - Making Objects Printable!\n#\n# When you print() an object, Python calls its __str__ method.\n# This lets you control how your objects look when printed!\n\n\ndef exercise_a():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Character class with a __str__ method\n    #\n    # class Character:\n    #     def __init__(self, name, house):\n    #         self.name = name\n    #         self.house = house\n    #\n    #     def __str__(self):\n    #         return f\"{self.name} of {self.house}\"\n    #\n    # hero = Character(\"{{hero}}\", \"{{house}}\")\n    # print(hero)  # This now prints nicely!\n    pass\n\n\ndef exercise_b():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Spell class with __str__ that shows:\n    # \"Spell: [name] (Power: [power])\"\n    pass\n\n\ndef exercise_c():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Character with health bar in __str__!\n    # Example output:\n    # \"{{hero}} [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘] 80/100 HP\"\n    # Hint: Use â–ˆ and â–‘ characters\n    pass\n\n\ndef exercise_d():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a detailed character card!\n    # __str__ returns a multi-line string:\n    # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n    # â•‘   {{hero}}        â•‘\n    # â•‘   Level: 5       â•‘\n    # â•‘   House: {{house}} â•‘\n    # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n    pass\n\n\ndef exercise_e():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create an Inventory class where __str__ lists all items nicely:\n    # \"Inventory: {{item}}, potion x3, gold (50)\"\n    pass\n\n\ndef exercise_f():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Battle class that shows both fighters:\n    # __str__ shows:\n    # \"Battle: {{hero}} (100 HP) vs {{villain}} (150 HP)\"\n    pass\n\n\nclass ExampleCharacter:\n    \"\"\"Example with both __str__ and __repr__\"\"\"\n\n    def __init__(self, name, house, level=1):\n        self.name = name\n        self.house = house\n        self.level = level\n        self.health = 100\n\n    def __str__(self):\n        # User-friendly output\n        bar_length = 10\n        filled = int((self.health / 100) * bar_length)\n        health_bar = \"â–ˆ\" * filled + \"â–‘\" * (bar_length - filled)\n        return f\"{self.name} [{health_bar}] {self.health}/100 HP\"\n\n    def __repr__(self):\n        # Developer-friendly output (for debugging)\n        return f\"Character(name='{self.name}', house='{self.house}', level={self.level})\"\n\n\ndef show_example():\n    hero = ExampleCharacter(\"{{hero}}\", \"{{house}}\", level=5)\n\n    print(\"Using print() calls __str__:\")\n    print(hero)\n\n    print(\"\\nUsing repr() calls __repr__:\")\n    print(repr(hero))\n\n    print(\"\\nIn a list, Python uses __repr__:\")\n    characters = [hero, ExampleCharacter(\"{{friend}}\", \"{{house}}\")]\n    print(characters)\n\n\ndef main():\n    print(\"=== Exercise A: Basic __str__ ===\")\n    exercise_a()\n\n    print(\"\\n=== Exercise B: Spell String ===\")\n    exercise_b()\n\n    print(\"\\n=== Exercise C: Health Bar ===\")\n    exercise_c()\n\n    print(\"\\n=== Exercise D: Character Card ===\")\n    exercise_d()\n\n    print(\"\\n=== Exercise E: Inventory Display ===\")\n    exercise_e()\n\n    print(\"\\n=== Exercise F: Battle Display ===\")\n    exercise_f()\n\n    print(\"\\n=== Example to Study ===\")\n    show_example()\n\n\nmain()\n",
      "solution_code": null,
      "hints": [
        "__str__ controls what print(object) displays",
        "Return a string from __str__, don't print inside it",
        "Use f-strings to build the output: return f\"{self.name}\""
      ],
      "tags": [
        "module_9_oop",
        "write_code"
      ],
      "source_file": "module_9_oop/write_code/exercise_4_str_repr.py"
    },
    {
      "id": "module_9_oop.write_code.exercise_5_interaction",
      "topic_id": "oop.methods",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Object Interaction",
      "title_he": "××™× ×˜×¨××§×¦×™×”",
      "title_en": "Object Interaction",
      "description_he": "×ª×›× ×•×ª ××•× ×—×” ×¢×¦××™×: ××™× ×˜×¨××§×¦×™×”\n\nExercise 5: Objects Interacting with Each Other!\nThe real power of OOP is when objects interact!\nCharacters can attack each other, trade items, cast spells on targets...",
      "description_en": "Object-Oriented Programming: Object Interaction\n\nExercise 5: Objects Interacting with Each Other!\nThe real power of OOP is when objects interact!\nCharacters can attack each other, trade items, cast spells on targets...",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "# Exercise 5: Objects Interacting with Each Other!\n#\n# The real power of OOP is when objects interact!\n# Characters can attack each other, trade items, cast spells on targets...\n\n\ndef exercise_a():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Character class where one can attack another:\n    #\n    # class Character:\n    #     def __init__(self, name, health=100, power=10):\n    #         ...\n    #\n    #     def attack(self, target):\n    #         # target is another Character object!\n    #         target.health -= self.power\n    #         print(f\"{self.name} attacks {target.name}!\")\n    #\n    # hero = Character(\"{{hero}}\", power=20)\n    # villain = Character(\"{{villain}}\", health=50)\n    # hero.attack(villain)\n    pass\n\n\ndef exercise_b():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Healer class that can heal other characters:\n    # healer.heal(target) adds health to target\n    pass\n\n\ndef exercise_c():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a trade system!\n    # Characters have an inventory (list)\n    # character.give_item(item, other_character)\n    # moves an item from one inventory to another\n    pass\n\n\ndef exercise_d():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Wizard that can cast spells ON a target:\n    # wizard.cast(spell_name, target)\n    # Different spells have different effects:\n    # - \"{{spell1}}\": no damage, just print \"The area lights up!\"\n    # - \"{{spell2}}\": disarm target (remove {{item}} if they have it)\n    # - \"{{spell3}}\": heal the target if ally, damage if enemy\n    pass\n\n\ndef exercise_e():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Team battle!\n    # Create a Team class that holds multiple Characters\n    # team.add_member(character)\n    # team.attack(enemy_team) - each member attacks a random enemy\n    pass\n\n\nclass ExampleCombat:\n    \"\"\"Example of objects interacting in combat\"\"\"\n\n    class Character:\n        def __init__(self, name, health=100, power=15):\n            self.name = name\n            self.health = health\n            self.power = power\n            self.is_defending = False\n\n        def attack(self, target):\n            damage = self.power\n            if target.is_defending:\n                damage = damage // 2\n                print(f\"{target.name} blocks some damage!\")\n\n            target.health -= damage\n            target.is_defending = False\n            print(f\"{self.name} hits {target.name} for {damage} damage!\")\n            print(f\"{target.name} has {target.health} HP remaining\")\n\n            if target.health <= 0:\n                print(f\"ğŸ’€ {target.name} has been defeated!\")\n\n        def defend(self):\n            self.is_defending = True\n            print(f\"{self.name} takes a defensive stance!\")\n\n        def is_alive(self):\n            return self.health > 0\n\n\ndef show_example():\n    # Create the class inside the example\n    Character = ExampleCombat.Character\n\n    hero = Character(\"{{hero}}\", health=100, power=20)\n    villain = Character(\"{{villain}}\", health=80, power=25)\n\n    print(\"=== Battle! ===\")\n    villain.defend()\n    hero.attack(villain)\n    villain.attack(hero)\n    hero.attack(villain)\n    hero.attack(villain)\n\n\ndef main():\n    print(\"=== Exercise A: Attack System ===\")\n    exercise_a()\n\n    print(\"\\n=== Exercise B: Healing ===\")\n    exercise_b()\n\n    print(\"\\n=== Exercise C: Trading ===\")\n    exercise_c()\n\n    print(\"\\n=== Exercise D: Spell Casting ===\")\n    exercise_d()\n\n    print(\"\\n=== Exercise E: Team Battle ===\")\n    exercise_e()\n\n    print(\"\\n=== Example Combat ===\")\n    show_example()\n\n\nmain()\n",
      "solution_code": null,
      "hints": [
        "Pass one object to another's method: hero.attack(enemy)",
        "Inside attack, 'self' is the attacker, 'target' is parameter",
        "Modify target's attributes: target.health -= self.power"
      ],
      "tags": [
        "module_9_oop",
        "write_code"
      ],
      "source_file": "module_9_oop/write_code/exercise_5_interaction.py"
    },
    {
      "id": "module_9_oop.write_code.exercise_6_inheritance",
      "topic_id": "oop.inheritance",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Inheritance",
      "title_he": "×”×•×¨×©×”",
      "title_en": "Inheritance",
      "description_he": "×ª×›× ×•×ª ××•× ×—×” ×¢×¦××™×: ×”×•×¨×©×”\n\nExercise 6: Inheritance - Creating Specialized Classes!\nInheritance lets you create new classes based on existing ones.\nA Wizard IS a Character, but with extra magic abilities!",
      "description_en": "Object-Oriented Programming: Inheritance\n\nExercise 6: Inheritance - Creating Specialized Classes!\nInheritance lets you create new classes based on existing ones.\nA Wizard IS a Character, but with extra magic abilities!",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "# Exercise 6: Inheritance - Creating Specialized Classes!\n#\n# Inheritance lets you create new classes based on existing ones.\n# A Wizard IS a Character, but with extra magic abilities!\n\n\ndef exercise_a():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a base Character class, then a Wizard that inherits from it:\n    #\n    # class Character:\n    #     def __init__(self, name):\n    #         self.name = name\n    #         self.health = 100\n    #\n    # class Wizard(Character):  # Wizard inherits from Character!\n    #     pass\n    #\n    # merlin = Wizard(\"{{mentor}}\")\n    # print(merlin.name)    # Works because Wizard inherits from Character!\n    # print(merlin.health)\n    pass\n\n\ndef exercise_b():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Add extra attributes to the child class:\n    #\n    # class Wizard(Character):\n    #     def __init__(self, name):\n    #         super().__init__(name)  # Call parent's __init__\n    #         self.mana = 100         # Add wizard-specific attribute\n    pass\n\n\ndef exercise_c():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create THREE character types from one base:\n    # - Wizard: has mana, can cast spells\n    # - Warrior: has rage, can use heavy attacks\n    # - Healer: has faith, can heal others\n    # All inherit health and name from Character\n    pass\n\n\ndef exercise_d():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Override a method from the parent!\n    #\n    # class Character:\n    #     def attack(self, target):\n    #         print(f\"{self.name} attacks!\")\n    #\n    # class Wizard(Character):\n    #     def attack(self, target):\n    #         print(f\"{self.name} casts a spell!\")  # Different attack!\n    pass\n\n\ndef exercise_e():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Use super() to extend parent behavior:\n    #\n    # class Wizard(Character):\n    #     def attack(self, target):\n    #         super().attack(target)  # Do normal attack\n    #         print(\"âœ¨ Magic sparkles fly everywhere!\")  # Add extra!\n    pass\n\n\ndef exercise_f():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a creature hierarchy:\n    # Creature (base): name, health\n    # â”œâ”€â”€ FriendlyCreature: can be_petted()\n    # â”‚   â””â”€â”€ Pet: has owner, can follow()\n    # â””â”€â”€ HostileCreature: can attack()\n    #     â””â”€â”€ Boss: has special_attack()\n    pass\n\n\nclass ExampleHierarchy:\n    \"\"\"Example character hierarchy\"\"\"\n\n    class Character:\n        def __init__(self, name, health=100):\n            self.name = name\n            self.health = health\n\n        def introduce(self):\n            print(f\"I am {self.name}!\")\n\n        def attack(self, target):\n            damage = 10\n            target.health -= damage\n            print(f\"{self.name} attacks for {damage} damage!\")\n\n    class Wizard(Character):\n        def __init__(self, name, health=80):\n            super().__init__(name, health)\n            self.mana = 100\n\n        def cast_spell(self, spell_name):\n            if self.mana >= 10:\n                self.mana -= 10\n                print(f\"{self.name} casts {spell_name}!\")\n            else:\n                print(f\"{self.name} is out of mana!\")\n\n        def attack(self, target):\n            # Override to use magic instead\n            print(f\"âœ¨ {self.name} hurls a magic bolt!\")\n            target.health -= 15\n\n    class Warrior(Character):\n        def __init__(self, name, health=120):\n            super().__init__(name, health)\n            self.rage = 0\n\n        def attack(self, target):\n            super().attack(target)  # Normal attack\n            self.rage += 10\n            if self.rage >= 50:\n                print(f\"âš”ï¸ {self.name} enters a battle fury!\")\n\n\ndef show_example():\n    Character = ExampleHierarchy.Character\n    Wizard = ExampleHierarchy.Wizard\n    Warrior = ExampleHierarchy.Warrior\n\n    # Create different character types\n    wizard = Wizard(\"{{heroine}}\")\n    warrior = Warrior(\"{{hero}}\")\n    enemy = Character(\"{{villain}}\")\n\n    wizard.introduce()\n    wizard.cast_spell(\"{{spell3}}\")\n\n    warrior.attack(enemy)\n    warrior.attack(enemy)\n    warrior.attack(enemy)\n\n\ndef main():\n    print(\"=== Exercise A: Basic Inheritance ===\")\n    exercise_a()\n\n    print(\"\\n=== Exercise B: Extended __init__ ===\")\n    exercise_b()\n\n    print(\"\\n=== Exercise C: Multiple Subclasses ===\")\n    exercise_c()\n\n    print(\"\\n=== Exercise D: Override Methods ===\")\n    exercise_d()\n\n    print(\"\\n=== Exercise E: Extend with super() ===\")\n    exercise_e()\n\n    print(\"\\n=== Exercise F: Creature Hierarchy ===\")\n    exercise_f()\n\n    print(\"\\n=== Example Hierarchy ===\")\n    show_example()\n\n\nmain()\n",
      "solution_code": null,
      "hints": [
        "Inherit with class Child(Parent):",
        "Call parent's __init__: super().__init__(name)",
        "Override methods by defining them again in the child class"
      ],
      "tags": [
        "module_9_oop",
        "write_code"
      ],
      "source_file": "module_9_oop/write_code/exercise_6_inheritance.py"
    },
    {
      "id": "module_9_oop.write_code.exercise_7_composition",
      "topic_id": "oop.composition",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Composition",
      "title_he": "×”×¨×›×‘×”",
      "title_en": "Composition",
      "description_he": "×ª×›× ×•×ª ××•× ×—×” ×¢×¦××™×: ×”×¨×›×‘×”\n\nExercise 7: Composition - Objects Containing Objects!\nComposition is when objects CONTAIN other objects.\nA Character HAS an Inventory, HAS a list of Spells, HAS Equipment...",
      "description_en": "Object-Oriented Programming: Composition\n\nExercise 7: Composition - Objects Containing Objects!\nComposition is when objects CONTAIN other objects.\nA Character HAS an Inventory, HAS a list of Spells, HAS Equipment...",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "# Exercise 7: Composition - Objects Containing Objects!\n#\n# Composition is when objects CONTAIN other objects.\n# A Character HAS an Inventory, HAS a list of Spells, HAS Equipment...\n\n\ndef exercise_a():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create separate classes and combine them:\n    #\n    # class Spell:\n    #     def __init__(self, name, power):\n    #         self.name = name\n    #         self.power = power\n    #\n    # class Wizard:\n    #     def __init__(self, name):\n    #         self.name = name\n    #         self.spells = []  # Will hold Spell objects!\n    #\n    #     def learn_spell(self, spell):\n    #         self.spells.append(spell)\n    #\n    # lumos = Spell(\"{{spell1}}\", 10)\n    # wizard = Wizard(\"{{hero}}\")\n    # wizard.learn_spell(lumos)\n    pass\n\n\ndef exercise_b():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create an Equipment class and a Character that HAS equipment:\n    # - Equipment has: name, defense_bonus, attack_bonus\n    # - Character has: weapon (Equipment), armor (Equipment)\n    # Character's total attack = base_attack + weapon.attack_bonus\n    pass\n\n\ndef exercise_c():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Party class that contains multiple Characters:\n    # - party.add_member(character)\n    # - party.remove_member(name)\n    # - party.show_members()\n    # - party.total_health() - sum of all member health\n    pass\n\n\ndef exercise_d():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a School with Houses with Students!\n    # School has: name, list of House objects\n    # House has: name, list of Student objects\n    # Student has: name, year\n    #\n    # school.add_house(house)\n    # house.add_student(student)\n    # school.count_students() - total across all houses\n    pass\n\n\ndef exercise_e():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a Quest system:\n    # - Objective class: description, is_complete\n    # - Quest class: name, list of Objectives, reward\n    # - quest.complete_objective(index)\n    # - quest.is_finished() - True when all objectives complete\n    pass\n\n\ndef exercise_f():\n    # âœï¸ YOUR CODE HERE âœï¸\n    # Create a complete RPG Character:\n    # - Stats class: strength, intelligence, agility\n    # - Inventory class: list of items, gold\n    # - Character class: name, Stats, Inventory, health\n    # The Character uses its Stats to calculate damage!\n    pass\n\n\nclass ExampleGameSystem:\n    \"\"\"A complete game system using composition\"\"\"\n\n    class Item:\n        def __init__(self, name, item_type, value):\n            self.name = name\n            self.item_type = item_type\n            self.value = value\n\n        def __str__(self):\n            return f\"{self.name} ({self.item_type})\"\n\n    class Inventory:\n        def __init__(self):\n            self.items = []\n            self.gold = 0\n\n        def add_item(self, item):\n            self.items.append(item)\n            print(f\"Added {item.name} to inventory!\")\n\n        def show(self):\n            print(\"=== Inventory ===\")\n            for item in self.items:\n                print(f\"  - {item}\")\n            print(f\"  Gold: {self.gold}\")\n\n    class Character:\n        def __init__(self, name):\n            self.name = name\n            self.health = 100\n            self.inventory = ExampleGameSystem.Inventory()  # HAS an inventory\n\n        def pick_up(self, item):\n            self.inventory.add_item(item)\n\n        def show_status(self):\n            print(f\"\\n=== {self.name} ===\")\n            print(f\"Health: {self.health}\")\n            self.inventory.show()\n\n\ndef show_example():\n    Item = ExampleGameSystem.Item\n    Character = ExampleGameSystem.Character\n\n    # Create a character with their own inventory\n    hero = Character(\"{{hero}}\")\n\n    # Create items\n    wand = Item(\"{{item}}\", \"weapon\", 100)\n    potion = Item(\"{{item}}\", \"consumable\", 25)\n\n    # Character picks up items (adds to their inventory)\n    hero.pick_up(wand)\n    hero.pick_up(potion)\n    hero.inventory.gold = 50\n\n    hero.show_status()\n\n\ndef main():\n    print(\"=== Exercise A: Spell Collection ===\")\n    exercise_a()\n\n    print(\"\\n=== Exercise B: Equipment System ===\")\n    exercise_b()\n\n    print(\"\\n=== Exercise C: Adventure Party ===\")\n    exercise_c()\n\n    print(\"\\n=== Exercise D: Nested Organization ===\")\n    exercise_d()\n\n    print(\"\\n=== Exercise E: Quest System ===\")\n    exercise_e()\n\n    print(\"\\n=== Exercise F: Complete Character ===\")\n    exercise_f()\n\n    print(\"\\n=== Example Game System ===\")\n    show_example()\n\n\nmain()\n",
      "solution_code": null,
      "hints": [
        "Composition: store objects as attributes of other objects",
        "Create: self.inventory = Inventory()",
        "Use: self.inventory.add_item(item)"
      ],
      "tags": [
        "module_9_oop",
        "write_code"
      ],
      "source_file": "module_9_oop/write_code/exercise_7_composition.py"
    }
  ]
}