{
  "version": "3.0.0",
  "theme_support": true,
  "generated_at": "2026-02-03T12:37:49.709507",
  "module": "module_9_oop",
  "count": 22,
  "exercise_types": [
    "blank_page",
    "complete_function",
    "fix_style",
    "hybrid",
    "which_is_better",
    "write_code"
  ],
  "exercises": [
    {
      "id": "module_9_oop.blank_page.exercise_1_design_class",
      "topic_id": "oop.classes",
      "exercise_type": "blank_page",
      "category": "free_writing",
      "title": "Design Class",
      "title_en": "Design Class",
      "title_he": "Design Class",
      "description_en": "Object-Oriented Programming: Design Class\n\n{{CONTEXT_BLANK_PAGE_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nDesign and implement classes from scratch based on requirements.\nNo starter code is provided - you must design the structure yourself.",
      "description_he": "תכנות מונחה עצמים: Design Class\n\n{{CONTEXT_BLANK_PAGE_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nDesign and implement classes from scratch based on requirements.\nNo starter code is provided - you must design the structure yourself.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "problem_solving",
        "full_implementation",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_BLANK_PAGE_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nDesign and implement classes from scratch based on requirements.\nNo starter code is provided - you must design the structure yourself.\n\"\"\"\n\n\n# ============================================================\n# {{BLANK_1_TITLE}}\n# ============================================================\n# {{CONTEXT_BLANK_1_NARRATIVE}}\n\n\ndef timer_class():\n    \"\"\"\n    Design a Timer class for tracking time at {{school}}.\n\n    Requirements:\n        - Initialize with a name for the timer\n        - Track seconds elapsed (starts at 0)\n        - Method to add time (tick)\n        - Method to reset to 0\n        - Method to get formatted time as \"MM:SS\"\n        - __str__ should return \"[name]: MM:SS\"\n\n    Examples:\n        >>> timer = Timer(\"Quest Timer\")\n        >>> timer.get_time()\n        '00:00'\n        >>> timer.tick(90)  # Add 90 seconds\n        >>> timer.get_time()\n        '01:30'\n        >>> str(timer)\n        'Quest Timer: 01:30'\n        >>> timer.reset()\n        >>> timer.get_time()\n        '00:00'\n\n    Hints:\n        - minutes = seconds // 60\n        - remaining_seconds = seconds % 60\n        - Use f\"{value:02d}\" to zero-pad numbers\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\n# ============================================================\n# {{BLANK_2_TITLE}}\n# ============================================================\n# {{CONTEXT_BLANK_2_NARRATIVE}}\n\n\ndef leaderboard_class():\n    \"\"\"\n    Design a Leaderboard class for {{school}} competitions.\n\n    Requirements:\n        - Initialize with a competition name\n        - Store player scores (name -> score mapping)\n        - Method to add/update a player's score\n        - Method to get a player's score (0 if not found)\n        - Method to get the top N players (list of tuples)\n        - Method to get total number of players\n        - __str__ should show the competition name and top 3\n\n    Examples:\n        >>> board = Leaderboard(\"{{spell1}} Tournament\")\n        >>> board.add_score(\"{{hero}}\", 100)\n        >>> board.add_score(\"{{heroine}}\", 150)\n        >>> board.add_score(\"{{friend}}\", 75)\n        >>> board.get_score(\"{{hero}}\")\n        100\n        >>> board.get_score(\"unknown\")\n        0\n        >>> board.get_top(2)\n        [('{{heroine}}', 150), ('{{hero}}', 100)]\n        >>> board.player_count()\n        3\n\n    Hints:\n        - Use a dictionary for scores\n        - sorted(dict.items(), key=lambda x: x[1], reverse=True)\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\n# ============================================================\n# {{BLANK_3_TITLE}}\n# ============================================================\n# {{CONTEXT_BLANK_3_NARRATIVE}}\n\n\ndef stat_tracker_class():\n    \"\"\"\n    Design a StatTracker class for tracking character statistics.\n\n    Requirements:\n        - Initialize with character name and a dict of base stats\n        - Store current stats (which can change) and base stats (reference)\n        - Method to modify a stat by an amount (positive or negative)\n        - Method to reset all stats to base values\n        - Method to get a stat's current value\n        - Method to get stat as percentage of base: current/base * 100\n        - Method to check if any stat is below 25% of its base (is_critical)\n        - __str__ shows all current stats\n\n    Examples:\n        >>> stats = StatTracker(\"{{hero}}\", {\"health\": 100, \"mana\": 50, \"stamina\": 75})\n        >>> stats.get_stat(\"health\")\n        100\n        >>> stats.modify_stat(\"health\", -30)\n        >>> stats.get_stat(\"health\")\n        70\n        >>> stats.get_percentage(\"health\")\n        70.0\n        >>> stats.is_critical()\n        False\n        >>> stats.modify_stat(\"mana\", -45)\n        >>> stats.is_critical()\n        True\n        >>> stats.reset_all()\n        >>> stats.get_stat(\"health\")\n        100\n\n    Hints:\n        - Make a copy of base_stats for current_stats\n        - Use dict.copy() to avoid shared references\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\n# ============================================================\n# TESTS\n# ============================================================\n\ndef run_tests():\n    \"\"\"Run tests for all classes.\"\"\"\n    print(\"Testing your implementations...\\n\")\n\n    print(\"{{BLANK_1_TITLE}} - Timer\")\n    # Uncomment to test:\n    # timer = Timer(\"Quest Timer\")\n    # assert timer.get_time() == \"00:00\"\n    # timer.tick(90)\n    # assert timer.get_time() == \"01:30\"\n    # timer.reset()\n    # assert timer.get_time() == \"00:00\"\n    print(\"   (Uncomment tests after implementing)\\n\")\n\n    print(\"{{BLANK_2_TITLE}} - Leaderboard\")\n    # Uncomment to test:\n    # board = Leaderboard(\"Tournament\")\n    # board.add_score(\"{{hero}}\", 100)\n    # board.add_score(\"{{heroine}}\", 150)\n    # assert board.get_score(\"{{hero}}\") == 100\n    # assert board.get_score(\"unknown\") == 0\n    # top = board.get_top(1)\n    # assert top[0][0] == \"{{heroine}}\"\n    print(\"   (Uncomment tests after implementing)\\n\")\n\n    print(\"{{BLANK_3_TITLE}} - StatTracker\")\n    # Uncomment to test:\n    # stats = StatTracker(\"{{hero}}\", {\"health\": 100, \"mana\": 50})\n    # assert stats.get_stat(\"health\") == 100\n    # stats.modify_stat(\"health\", -30)\n    # assert stats.get_stat(\"health\") == 70\n    # assert stats.get_percentage(\"health\") == 70.0\n    # stats.reset_all()\n    # assert stats.get_stat(\"health\") == 100\n    print(\"   (Uncomment tests after implementing)\\n\")\n\n    print(\"=\" * 40)\n    print(\"All tests passed!\")\n\n\ndef main():\n    print(\"{{CONTEXT_BLANK_PAGE_INTRO}}\")\n    print(\"=\" * 50)\n    print()\n    print(\"Implement each class based on its docstring specification.\")\n    print(\"When ready, run the tests to check your work.\")\n    print()\n\n    # Uncomment the function for the class you're working on:\n    # timer_class()\n    # leaderboard_class()\n    # stat_tracker_class()\n\n    # Uncomment to run tests:\n    # run_tests()\n\n    print(\"{{CONTEXT_MASTERY_COMPLETE}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "blank_page"
      ],
      "source_file": "module_9_oop/blank_page/exercise_1_design_class.py"
    },
    {
      "id": "module_9_oop.blank_page.exercise_2_design_hierarchy",
      "topic_id": "oop.classes",
      "exercise_type": "blank_page",
      "category": "free_writing",
      "title": "Design Hierarchy",
      "title_en": "Design Hierarchy",
      "title_he": "Design Hierarchy",
      "description_en": "Object-Oriented Programming: Design Hierarchy\n\n{{CONTEXT_BLANK_PAGE_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nDesign and implement a class hierarchy from scratch.\nThis requires planning parent-child relationships and using inheritance.",
      "description_he": "תכנות מונחה עצמים: Design Hierarchy\n\n{{CONTEXT_BLANK_PAGE_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nDesign and implement a class hierarchy from scratch.\nThis requires planning parent-child relationships and using inheritance.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "problem_solving",
        "full_implementation",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_BLANK_PAGE_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nDesign and implement a class hierarchy from scratch.\nThis requires planning parent-child relationships and using inheritance.\n\"\"\"\n\n\n# ============================================================\n# {{BLANK_1_TITLE}}\n# ============================================================\n# {{CONTEXT_BLANK_1_NARRATIVE}}\n\n\ndef ability_hierarchy():\n    \"\"\"\n    Design an Ability class hierarchy for {{school}}.\n\n    Base class: Ability\n        - name (string)\n        - cost (integer, resource cost to use)\n        - cooldown (integer, turns until can be used again)\n        - current_cooldown (starts at 0)\n        - can_use() -> True if current_cooldown == 0\n        - use() -> sets current_cooldown to cooldown, returns description\n        - tick() -> reduces current_cooldown by 1 (minimum 0)\n        - __str__ -> \"[name] (cost: [cost], CD: [current]/[cooldown])\"\n\n    Subclass: DamageAbility(Ability)\n        - Additional: damage (integer)\n        - Override use() to return \"[name] deals [damage] damage!\"\n        - Inherits everything else\n\n    Subclass: HealAbility(Ability)\n        - Additional: heal_amount (integer)\n        - Override use() to return \"[name] heals for [heal_amount]!\"\n        - Inherits everything else\n\n    Subclass: BuffAbility(Ability)\n        - Additional: buff_name (string), duration (integer)\n        - Override use() to return \"[name] applies [buff] for [duration] turns!\"\n        - Inherits everything else\n\n    Examples:\n        >>> fireball = DamageAbility(\"{{spell2}}\", 20, 3, 50)\n        >>> fireball.can_use()\n        True\n        >>> fireball.use()\n        '{{spell2}} deals 50 damage!'\n        >>> fireball.can_use()\n        False\n        >>> fireball.tick()\n        >>> fireball.tick()\n        >>> fireball.tick()\n        >>> fireball.can_use()\n        True\n\n        >>> heal = HealAbility(\"{{spell1}}\", 15, 2, 30)\n        >>> heal.use()\n        '{{spell1}} heals for 30!'\n\n        >>> buff = BuffAbility(\"{{spell3}}\", 10, 5, \"Shield\", 3)\n        >>> buff.use()\n        '{{spell3}} applies Shield for 3 turns!'\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\n# ============================================================\n# {{BLANK_2_TITLE}}\n# ============================================================\n# {{CONTEXT_BLANK_2_NARRATIVE}}\n\n\ndef item_hierarchy():\n    \"\"\"\n    Design an Item class hierarchy for {{school}}'s shop.\n\n    Base class: Item\n        - name (string)\n        - base_value (integer, gold value)\n        - get_value() -> returns base_value\n        - get_description() -> \"[name] worth [value] gold\"\n        - __str__ -> calls get_description()\n\n    Subclass: Equipment(Item)\n        - Additional: slot (string like \"weapon\", \"armor\", \"accessory\")\n        - Additional: durability (integer, starts at 100)\n        - use() -> reduces durability by 10, returns True if durability > 0\n        - Override get_description() to include slot and durability\n        - get_value() -> base_value * (durability / 100)\n\n    Subclass: Consumable(Item)\n        - Additional: quantity (integer, starts at given amount)\n        - Additional: effect (string describing what it does)\n        - consume() -> reduces quantity by 1, returns effect if quantity > 0\n        - Override get_description() to include quantity and effect\n        - is_empty() -> True if quantity == 0\n\n    Subclass: QuestItem(Item)\n        - Additional: quest_name (string, the quest it belongs to)\n        - Override get_value() to return 0 (can't sell quest items)\n        - Override get_description() to note it's a quest item\n\n    Examples:\n        >>> sword = Equipment(\"{{item}}\", 100, \"weapon\")\n        >>> sword.get_value()\n        100\n        >>> sword.use()\n        True\n        >>> sword.durability\n        90\n        >>> sword.get_value()\n        90\n\n        >>> potion = Consumable(\"Healing Potion\", 50, 3, \"Restores 50 HP\")\n        >>> potion.consume()\n        'Restores 50 HP'\n        >>> potion.quantity\n        2\n\n        >>> key = QuestItem(\"Ancient Key\", 500, \"Find the Lost Vault\")\n        >>> key.get_value()\n        0\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\n# ============================================================\n# {{BLANK_3_TITLE}}\n# ============================================================\n# {{CONTEXT_BLANK_3_NARRATIVE}}\n\n\ndef character_hierarchy():\n    \"\"\"\n    Design a Character class hierarchy for a {{school}} game.\n\n    Base class: Character\n        - name (string)\n        - health, max_health (integers)\n        - is_alive() -> health > 0\n        - take_damage(amount) -> reduces health, min 0\n        - heal(amount) -> increases health, max max_health\n        - get_status() -> \"[name]: [health]/[max_health] HP\"\n\n    Subclass: Player(Character)\n        - Additional: experience (starts at 0), level (starts at 1)\n        - gain_experience(amount) -> adds XP, levels up at 100 XP per level\n        - Override get_status() to include level and XP\n\n    Subclass: Enemy(Character)\n        - Additional: damage (attack power), loot_value (gold dropped)\n        - attack(target) -> deals damage to target\n        - Override get_status() to include damage\n\n    Subclass: Boss(Enemy)\n        - Additional: phase (starts at 1), max_phases (integer)\n        - Override take_damage: at 0 HP, if phase < max_phases,\n          restore to full health and increment phase\n        - Override get_status() to include phase\n\n    Examples:\n        >>> player = Player(\"{{hero}}\", 100)\n        >>> player.gain_experience(150)\n        >>> player.level\n        2\n        >>> player.experience\n        50\n\n        >>> enemy = Enemy(\"{{creature}}\", 50, 15, 20)\n        >>> enemy.attack(player)\n        >>> player.health\n        85\n\n        >>> boss = Boss(\"{{villain}}\", 100, 30, 50, 3)\n        >>> boss.take_damage(150)\n        >>> boss.is_alive()\n        True\n        >>> boss.phase\n        2\n        >>> boss.health\n        100\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\n# ============================================================\n# TESTS\n# ============================================================\n\ndef run_tests():\n    \"\"\"Run tests for all hierarchies.\"\"\"\n    print(\"Testing your implementations...\\n\")\n\n    print(\"{{BLANK_1_TITLE}} - Ability Hierarchy\")\n    # Uncomment to test:\n    # fireball = DamageAbility(\"Fireball\", 20, 3, 50)\n    # assert fireball.can_use() == True\n    # result = fireball.use()\n    # assert \"50 damage\" in result\n    # assert fireball.can_use() == False\n    print(\"   (Uncomment tests after implementing)\\n\")\n\n    print(\"{{BLANK_2_TITLE}} - Item Hierarchy\")\n    # Uncomment to test:\n    # sword = Equipment(\"Sword\", 100, \"weapon\")\n    # assert sword.get_value() == 100\n    # sword.use()\n    # assert sword.durability == 90\n    # potion = Consumable(\"Potion\", 50, 3, \"Heals 50\")\n    # assert potion.consume() == \"Heals 50\"\n    # assert potion.quantity == 2\n    print(\"   (Uncomment tests after implementing)\\n\")\n\n    print(\"{{BLANK_3_TITLE}} - Character Hierarchy\")\n    # Uncomment to test:\n    # player = Player(\"Hero\", 100)\n    # player.gain_experience(150)\n    # assert player.level == 2\n    # enemy = Enemy(\"Goblin\", 50, 15, 20)\n    # enemy.attack(player)\n    # assert player.health == 85\n    # boss = Boss(\"Dragon\", 100, 30, 50, 3)\n    # boss.take_damage(150)\n    # assert boss.is_alive() == True\n    # assert boss.phase == 2\n    print(\"   (Uncomment tests after implementing)\\n\")\n\n    print(\"=\" * 40)\n    print(\"All tests passed!\")\n\n\ndef main():\n    print(\"{{CONTEXT_BLANK_PAGE_INTRO}}\")\n    print(\"=\" * 50)\n    print()\n    print(\"Design each class hierarchy based on the specifications.\")\n    print(\"Think carefully about what goes in the base class vs subclasses.\")\n    print()\n\n    # Uncomment the hierarchy you're working on:\n    # ability_hierarchy()\n    # item_hierarchy()\n    # character_hierarchy()\n\n    # Uncomment to run tests:\n    # run_tests()\n\n    print(\"{{CONTEXT_MASTERY_COMPLETE}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "blank_page"
      ],
      "source_file": "module_9_oop/blank_page/exercise_2_design_hierarchy.py"
    },
    {
      "id": "module_9_oop.complete_function.exercise_1_init_completion",
      "topic_id": "oop.classes",
      "exercise_type": "complete_function",
      "category": "scaffolded_writing",
      "title": "Init Completion",
      "title_en": "Init Completion",
      "title_he": "Init Completion",
      "description_en": "Object-Oriented Programming: Init Completion\n\n{{CONTEXT_COMPLETE_FUNCTION_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll practice completing __init__ methods\nto properly initialize object state. Understanding __init__ is\nessential for creating well-structured classes.",
      "description_he": "תכנות מונחה עצמים: Init Completion\n\n{{CONTEXT_COMPLETE_FUNCTION_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll practice completing __init__ methods\nto properly initialize object state. Understanding __init__ is\nessential for creating well-structured classes.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "pattern_recognition",
        "working_with_constraints"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_COMPLETE_FUNCTION_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll practice completing __init__ methods\nto properly initialize object state. Understanding __init__ is\nessential for creating well-structured classes.\n\"\"\"\n\n\n# ============================================================\n# {{FUNCTION_1_TITLE}}\n# ============================================================\n# {{CONTEXT_FUNCTION_1_NARRATIVE}}\n\n\nclass Creature:\n    \"\"\"A creature that can be encountered at {{school}}.\"\"\"\n\n    def __init__(self, name, health, strength):\n        \"\"\"\n        Initialize a new creature.\n\n        Args:\n            name: The creature's name (string)\n            health: Starting health points (integer)\n            strength: Attack power (integer)\n\n        After initialization, the creature should have:\n            - self.name set to the name parameter\n            - self.health set to the health parameter\n            - self.strength set to the strength parameter\n            - self.is_alive set to True\n\n        Examples:\n            >>> creature = Creature(\"{{creature}}\", 100, 25)\n            >>> creature.name\n            '{{creature}}'\n            >>> creature.health\n            100\n            >>> creature.is_alive\n            True\n        \"\"\"\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_1}}\n        #\n        # Store each parameter as an instance attribute using self.\n        # Also set self.is_alive to True (not passed as parameter).\n\n        pass\n\n\n# ============================================================\n# {{FUNCTION_2_TITLE}}\n# ============================================================\n# {{CONTEXT_FUNCTION_2_NARRATIVE}}\n\n\nclass Inventory:\n    \"\"\"An inventory system for holding items.\"\"\"\n\n    def __init__(self, owner, capacity=10):\n        \"\"\"\n        Initialize an empty inventory for a character.\n\n        Args:\n            owner: Name of the inventory owner (string)\n            capacity: Maximum items the inventory can hold (default 10)\n\n        After initialization, the inventory should have:\n            - self.owner set to the owner parameter\n            - self.capacity set to the capacity parameter\n            - self.items set to an empty list []\n            - self.gold set to 0\n\n        Examples:\n            >>> inv = Inventory(\"{{hero}}\")\n            >>> inv.owner\n            '{{hero}}'\n            >>> inv.items\n            []\n            >>> inv.capacity\n            10\n            >>> inv = Inventory(\"{{heroine}}\", capacity=20)\n            >>> inv.capacity\n            20\n        \"\"\"\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_2}}\n        #\n        # Set up the owner, capacity (from parameters), and\n        # initialize items as empty list and gold as 0.\n\n        pass\n\n\n# ============================================================\n# {{FUNCTION_3_TITLE}}\n# ============================================================\n# {{CONTEXT_FUNCTION_3_NARRATIVE}}\n\n\nclass QuestLog:\n    \"\"\"Tracks active and completed quests.\"\"\"\n\n    def __init__(self, character_name, max_active=5):\n        \"\"\"\n        Initialize a new quest log.\n\n        Args:\n            character_name: Name of the character (string)\n            max_active: Maximum concurrent active quests (default 5)\n\n        After initialization, the quest log should have:\n            - self.character_name set to character_name\n            - self.max_active set to max_active\n            - self.active_quests set to an empty list []\n            - self.completed_quests set to an empty list []\n            - self.total_quests_completed set to 0\n\n        Examples:\n            >>> log = QuestLog(\"{{hero}}\")\n            >>> log.character_name\n            '{{hero}}'\n            >>> log.active_quests\n            []\n            >>> log.completed_quests\n            []\n            >>> log.total_quests_completed\n            0\n        \"\"\"\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_3}}\n        #\n        # Initialize all five attributes as described above.\n        # Some come from parameters, others start at fixed values.\n\n        pass\n\n\n# ============================================================\n# {{FUNCTION_4_TITLE}}\n# ============================================================\n# {{CONTEXT_FUNCTION_4_NARRATIVE}}\n\n\nclass SkillTree:\n    \"\"\"A skill tree for character progression.\"\"\"\n\n    def __init__(self, class_name, starting_points=0):\n        \"\"\"\n        Initialize a skill tree for a character class.\n\n        Args:\n            class_name: The character's class (e.g., \"{{ROLE_TITLE}}\")\n            starting_points: Skill points available to spend (default 0)\n\n        After initialization:\n            - self.class_name set to class_name\n            - self.available_points set to starting_points\n            - self.spent_points set to 0\n            - self.unlocked_skills set to an empty dictionary {}\n            - self.skill_levels set to an empty dictionary {}\n\n        Examples:\n            >>> tree = SkillTree(\"{{ROLE_TITLE}}\", 5)\n            >>> tree.class_name\n            '{{ROLE_TITLE}}'\n            >>> tree.available_points\n            5\n            >>> tree.unlocked_skills\n            {}\n        \"\"\"\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_4}}\n        #\n        # Initialize all attributes. Note that some should be\n        # empty dictionaries {} rather than empty lists [].\n\n        pass\n\n\ndef main():\n    print(\"{{CONTEXT_COMPLETE_FUNCTION_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== Testing {{FUNCTION_1_TITLE}} ===\")\n    creature = Creature(\"{{creature}}\", 100, 25)\n    if creature.name:\n        print(f\"Created: {creature.name}\")\n        print(f\"  Health: {creature.health}\")\n        print(f\"  Strength: {creature.strength}\")\n        print(f\"  Alive: {creature.is_alive}\")\n    else:\n        print(\"  (Complete the __init__ method)\")\n\n    print(\"\\n=== Testing {{FUNCTION_2_TITLE}} ===\")\n    inventory = Inventory(\"{{hero}}\")\n    if inventory.owner:\n        print(f\"Owner: {inventory.owner}\")\n        print(f\"  Capacity: {inventory.capacity}\")\n        print(f\"  Items: {inventory.items}\")\n        print(f\"  Gold: {inventory.gold}\")\n    else:\n        print(\"  (Complete the __init__ method)\")\n\n    print(\"\\n=== Testing {{FUNCTION_3_TITLE}} ===\")\n    quest_log = QuestLog(\"{{heroine}}\", max_active=3)\n    if quest_log.character_name:\n        print(f\"Quest log for: {quest_log.character_name}\")\n        print(f\"  Max active: {quest_log.max_active}\")\n        print(f\"  Active quests: {quest_log.active_quests}\")\n        print(f\"  Completed: {quest_log.total_quests_completed}\")\n    else:\n        print(\"  (Complete the __init__ method)\")\n\n    print(\"\\n=== Testing {{FUNCTION_4_TITLE}} ===\")\n    skill_tree = SkillTree(\"{{ROLE_TITLE}}\", 10)\n    if skill_tree.class_name:\n        print(f\"Skill tree for: {skill_tree.class_name}\")\n        print(f\"  Available points: {skill_tree.available_points}\")\n        print(f\"  Spent points: {skill_tree.spent_points}\")\n        print(f\"  Unlocked skills: {skill_tree.unlocked_skills}\")\n    else:\n        print(\"  (Complete the __init__ method)\")\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "complete_function"
      ],
      "source_file": "module_9_oop/complete_function/exercise_1_init_completion.py"
    },
    {
      "id": "module_9_oop.complete_function.exercise_2_method_completion",
      "topic_id": "oop.classes",
      "exercise_type": "complete_function",
      "category": "scaffolded_writing",
      "title": "Method Completion",
      "title_en": "Method Completion",
      "title_he": "Method Completion",
      "description_en": "Object-Oriented Programming: Method Completion\n\n{{CONTEXT_COMPLETE_FUNCTION_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll complete methods that operate on object state.\nThe class structure is provided - you write the method bodies.",
      "description_he": "תכנות מונחה עצמים: Method Completion\n\n{{CONTEXT_COMPLETE_FUNCTION_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll complete methods that operate on object state.\nThe class structure is provided - you write the method bodies.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "pattern_recognition",
        "working_with_constraints"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_COMPLETE_FUNCTION_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll complete methods that operate on object state.\nThe class structure is provided - you write the method bodies.\n\"\"\"\n\n\n# ============================================================\n# {{FUNCTION_1_TITLE}}\n# ============================================================\n# {{CONTEXT_FUNCTION_1_NARRATIVE}}\n\n\nclass HealthTracker:\n    \"\"\"Tracks health for a character at {{school}}.\"\"\"\n\n    def __init__(self, name, max_health):\n        \"\"\"Initialize with full health.\"\"\"\n        self.name = name\n        self.max_health = max_health\n        self.current_health = max_health\n\n    def take_damage(self, amount):\n        \"\"\"\n        Reduce health by the damage amount.\n\n        Args:\n            amount: Damage to take (positive integer)\n\n        The health should not go below 0.\n\n        Examples:\n            >>> tracker = HealthTracker(\"{{hero}}\", 100)\n            >>> tracker.take_damage(30)\n            >>> tracker.current_health\n            70\n            >>> tracker.take_damage(200)\n            >>> tracker.current_health\n            0\n        \"\"\"\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_1}}\n        #\n        # Subtract amount from self.current_health\n        # Make sure health doesn't go below 0\n        # Hint: Use max(0, result) or an if statement\n\n        pass\n\n    def heal(self, amount):\n        \"\"\"\n        Restore health by the healing amount.\n\n        Args:\n            amount: Health to restore (positive integer)\n\n        The health should not exceed max_health.\n\n        Examples:\n            >>> tracker = HealthTracker(\"{{hero}}\", 100)\n            >>> tracker.current_health = 50\n            >>> tracker.heal(30)\n            >>> tracker.current_health\n            80\n            >>> tracker.heal(50)\n            >>> tracker.current_health\n            100\n        \"\"\"\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_2}}\n        #\n        # Add amount to self.current_health\n        # Make sure health doesn't exceed self.max_health\n        # Hint: Use min(self.max_health, result) or an if statement\n\n        pass\n\n    def is_alive(self):\n        \"\"\"\n        Check if the character is still alive.\n\n        Returns:\n            bool: True if current_health > 0, False otherwise\n\n        Examples:\n            >>> tracker = HealthTracker(\"{{hero}}\", 100)\n            >>> tracker.is_alive()\n            True\n            >>> tracker.current_health = 0\n            >>> tracker.is_alive()\n            False\n        \"\"\"\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_3}}\n        #\n        # Return True if health is above 0\n\n        pass\n\n\n# ============================================================\n# {{FUNCTION_2_TITLE}}\n# ============================================================\n# {{CONTEXT_FUNCTION_2_NARRATIVE}}\n\n\nclass ScoreKeeper:\n    \"\"\"Keeps track of points and achievements.\"\"\"\n\n    def __init__(self, player_name):\n        \"\"\"Initialize with zero points.\"\"\"\n        self.player_name = player_name\n        self.score = 0\n        self.high_score = 0\n        self.achievements = []\n\n    def add_points(self, points):\n        \"\"\"\n        Add points to the score.\n\n        Args:\n            points: Points to add (positive integer)\n\n        Also updates high_score if the new score is higher.\n\n        Examples:\n            >>> keeper = ScoreKeeper(\"{{hero}}\")\n            >>> keeper.add_points(50)\n            >>> keeper.score\n            50\n            >>> keeper.high_score\n            50\n            >>> keeper.add_points(30)\n            >>> keeper.score\n            80\n            >>> keeper.high_score\n            80\n        \"\"\"\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_1}}\n        #\n        # Add points to self.score\n        # Update self.high_score if score is now higher\n\n        pass\n\n    def unlock_achievement(self, achievement_name):\n        \"\"\"\n        Unlock a new achievement if not already unlocked.\n\n        Args:\n            achievement_name: Name of the achievement\n\n        Returns:\n            bool: True if newly unlocked, False if already had it\n\n        Examples:\n            >>> keeper = ScoreKeeper(\"{{hero}}\")\n            >>> keeper.unlock_achievement(\"First Victory\")\n            True\n            >>> keeper.achievements\n            ['First Victory']\n            >>> keeper.unlock_achievement(\"First Victory\")\n            False\n        \"\"\"\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_2}}\n        #\n        # Check if achievement_name is already in self.achievements\n        # If not, add it and return True\n        # If already there, return False\n\n        pass\n\n    def reset_score(self):\n        \"\"\"\n        Reset the current score to 0.\n\n        The high_score is NOT reset - it persists across resets.\n\n        Examples:\n            >>> keeper = ScoreKeeper(\"{{hero}}\")\n            >>> keeper.add_points(100)\n            >>> keeper.reset_score()\n            >>> keeper.score\n            0\n            >>> keeper.high_score\n            100\n        \"\"\"\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_3}}\n        #\n        # Set self.score to 0 (but leave high_score alone)\n\n        pass\n\n\n# ============================================================\n# {{FUNCTION_3_TITLE}}\n# ============================================================\n# {{CONTEXT_FUNCTION_3_NARRATIVE}}\n\n\nclass ItemStack:\n    \"\"\"A stack of identical items in an inventory.\"\"\"\n\n    def __init__(self, item_name, quantity=1, max_stack=99):\n        \"\"\"Initialize an item stack.\"\"\"\n        self.item_name = item_name\n        self.quantity = quantity\n        self.max_stack = max_stack\n\n    def add(self, amount):\n        \"\"\"\n        Add items to the stack.\n\n        Args:\n            amount: Number of items to add\n\n        Returns:\n            int: The number of items that couldn't fit (overflow)\n\n        Examples:\n            >>> stack = ItemStack(\"{{item}}\", 50, max_stack=99)\n            >>> stack.add(30)\n            0\n            >>> stack.quantity\n            80\n            >>> stack.add(30)\n            11\n            >>> stack.quantity\n            99\n        \"\"\"\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_1}}\n        #\n        # Calculate how many items would fit\n        # Add what fits, return the overflow\n        # total = self.quantity + amount\n        # If total > max_stack: overflow = total - max_stack\n\n        pass\n\n    def remove(self, amount):\n        \"\"\"\n        Remove items from the stack.\n\n        Args:\n            amount: Number of items to remove\n\n        Returns:\n            int: The number of items actually removed\n\n        Examples:\n            >>> stack = ItemStack(\"{{item}}\", 50)\n            >>> stack.remove(30)\n            30\n            >>> stack.quantity\n            20\n            >>> stack.remove(50)\n            20\n            >>> stack.quantity\n            0\n        \"\"\"\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_2}}\n        #\n        # Can only remove up to what's available\n        # Actually removed = min(amount, self.quantity)\n        # Subtract from quantity, return amount removed\n\n        pass\n\n    def is_empty(self):\n        \"\"\"\n        Check if the stack is empty.\n\n        Returns:\n            bool: True if quantity is 0\n\n        Examples:\n            >>> stack = ItemStack(\"{{item}}\", 5)\n            >>> stack.is_empty()\n            False\n            >>> stack.remove(5)\n            5\n            >>> stack.is_empty()\n            True\n        \"\"\"\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_3}}\n\n        pass\n\n\ndef main():\n    print(\"{{CONTEXT_COMPLETE_FUNCTION_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== Testing {{FUNCTION_1_TITLE}} ===\")\n    tracker = HealthTracker(\"{{hero}}\", 100)\n    print(f\"Starting health: {tracker.current_health}\")\n    tracker.take_damage(30)\n    print(f\"After 30 damage: {tracker.current_health}\")\n    tracker.heal(20)\n    print(f\"After 20 healing: {tracker.current_health}\")\n    print(f\"Is alive: {tracker.is_alive()}\")\n\n    print(\"\\n=== Testing {{FUNCTION_2_TITLE}} ===\")\n    keeper = ScoreKeeper(\"{{heroine}}\")\n    keeper.add_points(100)\n    print(f\"Score: {keeper.score}, High: {keeper.high_score}\")\n    print(f\"New achievement: {keeper.unlock_achievement('First Win')}\")\n    print(f\"Duplicate: {keeper.unlock_achievement('First Win')}\")\n    keeper.reset_score()\n    print(f\"After reset - Score: {keeper.score}, High: {keeper.high_score}\")\n\n    print(\"\\n=== Testing {{FUNCTION_3_TITLE}} ===\")\n    stack = ItemStack(\"{{item}}\", 50, max_stack=99)\n    overflow = stack.add(60)\n    print(f\"Added 60, overflow: {overflow}, quantity: {stack.quantity}\")\n    removed = stack.remove(40)\n    print(f\"Removed {removed}, quantity: {stack.quantity}\")\n    print(f\"Is empty: {stack.is_empty()}\")\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "complete_function"
      ],
      "source_file": "module_9_oop/complete_function/exercise_2_method_completion.py"
    },
    {
      "id": "module_9_oop.complete_function.exercise_3_super_completion",
      "topic_id": "oop.classes",
      "exercise_type": "complete_function",
      "category": "scaffolded_writing",
      "title": "Super Completion",
      "title_en": "Super Completion",
      "title_he": "Super Completion",
      "description_en": "Object-Oriented Programming: Super Completion\n\n{{CONTEXT_COMPLETE_FUNCTION_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll practice using super() to call parent class\nmethods. Understanding super() is essential for properly initializing\nsubclasses and extending parent behavior.",
      "description_he": "תכנות מונחה עצמים: Super Completion\n\n{{CONTEXT_COMPLETE_FUNCTION_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll practice using super() to call parent class\nmethods. Understanding super() is essential for properly initializing\nsubclasses and extending parent behavior.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "pattern_recognition",
        "working_with_constraints"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_COMPLETE_FUNCTION_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll practice using super() to call parent class\nmethods. Understanding super() is essential for properly initializing\nsubclasses and extending parent behavior.\n\"\"\"\n\n\n# ============================================================\n# {{FUNCTION_1_TITLE}}\n# ============================================================\n# {{CONTEXT_FUNCTION_1_NARRATIVE}}\n\n\nclass BaseUnit:\n    \"\"\"Base class for all units at {{school}}.\"\"\"\n\n    def __init__(self, name, health):\n        self.name = name\n        self.health = health\n        self.max_health = health\n\n\nclass AdvancedUnit(BaseUnit):\n    \"\"\"\n    A unit with additional capabilities.\n\n    This class extends BaseUnit by adding a power attribute.\n\n    Examples:\n        >>> unit = AdvancedUnit(\"{{hero}}\", 100, 50)\n        >>> unit.name\n        '{{hero}}'\n        >>> unit.health\n        100\n        >>> unit.power\n        50\n    \"\"\"\n\n    def __init__(self, name, health, power):\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_1}}\n        #\n        # Step 1: Call the parent class __init__ using super()\n        #         super().__init__(name, health)\n        #\n        # Step 2: Add the new attribute for this class\n        #         self.power = power\n\n        pass\n\n\n# ============================================================\n# {{FUNCTION_2_TITLE}}\n# ============================================================\n# {{CONTEXT_FUNCTION_2_NARRATIVE}}\n\n\nclass BaseCharacter:\n    \"\"\"Base class for characters.\"\"\"\n\n    def __init__(self, name, level=1):\n        self.name = name\n        self.level = level\n        self.experience = 0\n\n\nclass PlayerCharacter(BaseCharacter):\n    \"\"\"\n    A player-controlled character with a class role.\n\n    Extends BaseCharacter with role and skills.\n\n    Examples:\n        >>> player = PlayerCharacter(\"{{hero}}\", \"{{ROLE_TITLE}}\", 5)\n        >>> player.name\n        '{{hero}}'\n        >>> player.level\n        5\n        >>> player.role\n        '{{ROLE_TITLE}}'\n        >>> player.skills\n        []\n    \"\"\"\n\n    def __init__(self, name, role, level=1):\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_2}}\n        #\n        # Step 1: Call parent __init__ with name and level\n        #         Note: The parent doesn't know about 'role'\n        #\n        # Step 2: Add role as a new attribute\n        #\n        # Step 3: Initialize skills as an empty list\n\n        pass\n\n\n# ============================================================\n# {{FUNCTION_3_TITLE}}\n# ============================================================\n# {{CONTEXT_FUNCTION_3_NARRATIVE}}\n\n\nclass BaseCreature:\n    \"\"\"Base class for creatures.\"\"\"\n\n    def __init__(self, species, health, power):\n        self.species = species\n        self.health = health\n        self.power = power\n        self.is_wild = True\n\n\nclass TamedCreature(BaseCreature):\n    \"\"\"\n    A creature that has been tamed by a character.\n\n    Extends BaseCreature with owner and loyalty.\n\n    Examples:\n        >>> creature = TamedCreature(\"{{creature}}\", 80, 40, \"{{hero}}\")\n        >>> creature.species\n        '{{creature}}'\n        >>> creature.is_wild\n        False\n        >>> creature.owner\n        '{{hero}}'\n        >>> creature.loyalty\n        50\n    \"\"\"\n\n    def __init__(self, species, health, power, owner):\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_3}}\n        #\n        # Step 1: Call parent __init__ with species, health, power\n        #\n        # Step 2: Override is_wild to be False (tamed creatures aren't wild)\n        #\n        # Step 3: Add owner attribute\n        #\n        # Step 4: Add loyalty attribute, initialized to 50\n\n        pass\n\n\n# ============================================================\n# {{FUNCTION_4_TITLE}}\n# ============================================================\n# {{CONTEXT_FUNCTION_4_NARRATIVE}}\n\n\nclass BaseItem:\n    \"\"\"Base class for items.\"\"\"\n\n    def __init__(self, name, base_value):\n        self.name = name\n        self.base_value = base_value\n\n    def get_value(self):\n        \"\"\"Return the item's value.\"\"\"\n        return self.base_value\n\n\nclass EnchantedItem(BaseItem):\n    \"\"\"\n    An item with magical enhancements.\n\n    Extends BaseItem with enchantment level and multiplied value.\n\n    The actual value is base_value * (1 + enchantment_level * 0.5)\n\n    Examples:\n        >>> item = EnchantedItem(\"{{item}}\", 100, 2)\n        >>> item.name\n        '{{item}}'\n        >>> item.enchantment_level\n        2\n        >>> item.get_value()\n        200.0\n    \"\"\"\n\n    def __init__(self, name, base_value, enchantment_level):\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_4}}\n        #\n        # Step 1: Call parent __init__ with name and base_value\n        #\n        # Step 2: Add enchantment_level attribute\n\n        pass\n\n    def get_value(self):\n        \"\"\"\n        Return the enchanted item's value.\n\n        Value = base_value * (1 + enchantment_level * 0.5)\n\n        Examples:\n            >>> item = EnchantedItem(\"{{item}}\", 100, 2)\n            >>> item.get_value()\n            200.0\n        \"\"\"\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # Calculate: self.base_value * (1 + self.enchantment_level * 0.5)\n\n        pass\n\n\ndef main():\n    print(\"{{CONTEXT_COMPLETE_FUNCTION_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== Testing {{FUNCTION_1_TITLE}} ===\")\n    unit = AdvancedUnit(\"{{hero}}\", 100, 50)\n    if unit.name:\n        print(f\"Name: {unit.name}\")\n        print(f\"Health: {unit.health}/{unit.max_health}\")\n        print(f\"Power: {unit.power}\")\n    else:\n        print(\"  (Complete the __init__ method)\")\n\n    print(\"\\n=== Testing {{FUNCTION_2_TITLE}} ===\")\n    player = PlayerCharacter(\"{{heroine}}\", \"{{ROLE_TITLE}}\", 5)\n    if player.name:\n        print(f\"Name: {player.name}\")\n        print(f\"Level: {player.level}\")\n        print(f\"Role: {player.role}\")\n        print(f\"Skills: {player.skills}\")\n    else:\n        print(\"  (Complete the __init__ method)\")\n\n    print(\"\\n=== Testing {{FUNCTION_3_TITLE}} ===\")\n    creature = TamedCreature(\"{{creature}}\", 80, 40, \"{{hero}}\")\n    if creature.species:\n        print(f\"Species: {creature.species}\")\n        print(f\"Owner: {creature.owner}\")\n        print(f\"Is wild: {creature.is_wild}\")\n        print(f\"Loyalty: {creature.loyalty}\")\n    else:\n        print(\"  (Complete the __init__ method)\")\n\n    print(\"\\n=== Testing {{FUNCTION_4_TITLE}} ===\")\n    item = EnchantedItem(\"{{item}}\", 100, 2)\n    if item.name:\n        print(f\"Name: {item.name}\")\n        print(f\"Base value: {item.base_value}\")\n        print(f\"Enchantment: +{item.enchantment_level}\")\n        print(f\"Actual value: {item.get_value()}\")\n    else:\n        print(\"  (Complete the __init__ and get_value methods)\")\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "complete_function"
      ],
      "source_file": "module_9_oop/complete_function/exercise_3_super_completion.py"
    },
    {
      "id": "module_9_oop.fix_style.exercise_1_oop_conventions",
      "topic_id": "oop.classes",
      "exercise_type": "fix_style",
      "category": "improvement",
      "title": "Oop Conventions",
      "title_en": "Oop Conventions",
      "title_he": "Oop Conventions",
      "description_en": "Object-Oriented Programming: Oop Conventions\n\n{{CONTEXT_FIX_STYLE_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll fix code that works but violates OOP naming\nconventions and best practices. Good style makes code readable and\nhelps others understand your class designs.",
      "description_he": "תכנות מונחה עצמים: Oop Conventions\n\n{{CONTEXT_FIX_STYLE_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll fix code that works but violates OOP naming\nconventions and best practices. Good style makes code readable and\nhelps others understand your class designs.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 8,
      "skills": [
        "pep8",
        "readability",
        "conventions",
        "code_quality"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_FIX_STYLE_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll fix code that works but violates OOP naming\nconventions and best practices. Good style makes code readable and\nhelps others understand your class designs.\n\"\"\"\n\n\n# ============================================================\n# {{STYLE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_STYLE_1_NARRATIVE}}\n\n\n# ORIGINAL - This code works but has style issues\nclass character:  # Wrong! Classes should be PascalCase\n    def __init__(self, n, hp, pwr):  # Bad parameter names\n        self.n = n  # Unclear attribute name\n        self.hp = hp\n        self.Pwr = pwr  # Inconsistent naming\n\n    def Damage(self, amt):  # Methods should be snake_case\n        self.hp = self.hp - amt\n\n    def GetInfo(self):  # Should be snake_case\n        return self.n + \" has \" + str(self.hp) + \" HP\"  # Use f-string\n\n\ndef fixed_1():\n    # ✏️ FIX THE STYLE ✏️\n    #\n    # {{CONTEXT_STYLE_FIX_1}}\n    #\n    # Rewrite the class with proper conventions:\n    # - Class name: PascalCase (Character)\n    # - Method names: snake_case (take_damage, get_info)\n    # - Attribute names: snake_case, descriptive (name, health, power)\n    # - Use f-strings for string formatting\n    #\n    # Write your fixed version below:\n\n    pass\n\n\n# ============================================================\n# {{STYLE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_STYLE_2_NARRATIVE}}\n\n\n# ORIGINAL - Mixed naming conventions and poor structure\nclass INVENTORY:  # Wrong! Not PascalCase\n    def __init__(self, ownerName):  # camelCase, should be snake_case\n        self.ownerName = ownerName\n        self.ItemList = []  # Wrong case, unclear purpose\n        self.g = 0  # What is g?\n\n    def ADD(self, item):  # All caps is wrong\n        self.ItemList.append(item)\n\n    def addGold(self, amount):  # camelCase, inconsistent with ADD\n        self.g = self.g + amount\n\n    def Display(self):\n        print(self.ownerName)\n        print(self.ItemList)\n        print(self.g)\n\n\ndef fixed_2():\n    # ✏️ FIX THE STYLE ✏️\n    #\n    # {{CONTEXT_STYLE_FIX_2}}\n    #\n    # Fix:\n    # - Class name to PascalCase\n    # - All attributes to snake_case with clear names\n    # - All methods to snake_case\n    # - Be consistent throughout\n    #\n    # Write your fixed version below:\n\n    pass\n\n\n# ============================================================\n# {{STYLE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_STYLE_3_NARRATIVE}}\n\n\n# ORIGINAL - Missing docstrings and unclear code\nclass e:  # Single letter name!\n    def __init__(self, a, b, c):\n        self.a = a\n        self.b = b\n        self.c = c\n\n    def f(self, x):\n        self.b = self.b - x\n        if self.b < 0:\n            self.b = 0\n\n    def g(self, x):\n        if self.c >= x:\n            self.c = self.c - x\n            return True\n        return False\n\n    def h(self):\n        return self.a + \" B:\" + str(self.b) + \" C:\" + str(self.c)\n\n\ndef fixed_3():\n    # ✏️ FIX THE STYLE ✏️\n    #\n    # {{CONTEXT_STYLE_FIX_3}}\n    #\n    # This appears to be a game entity with health (b) and mana (c).\n    #\n    # Fix:\n    # - Give the class a meaningful name (Entity, Character, etc.)\n    # - Rename all attributes descriptively\n    # - Rename all methods descriptively (take_damage, use_mana, get_status)\n    # - Add docstrings to the class and methods\n    #\n    # Write your fixed version below:\n\n    pass\n\n\n# ============================================================\n# {{STYLE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_STYLE_4_NARRATIVE}}\n\n\n# ORIGINAL - Inheritance with style issues\nclass baseUnit:  # Should be PascalCase\n    def __init__(self, NAME, HP):  # ALL CAPS parameters\n        self.NAME = NAME\n        self.HP = HP\n\n\nclass warrior_unit(baseUnit):  # Should be PascalCase\n    def __init__(self, NAME, HP, str):  # str shadows built-in!\n        super().__init__(NAME, HP)\n        self.str = str  # shadows built-in str()\n\n    def ATTACK(self):  # ALL CAPS method\n        return self.str\n\n\nclass MageUnit(baseUnit):  # Inconsistent with warrior_unit\n    def __init__(self, NAME, HP, mp, magic_power):\n        super().__init__(NAME, HP)\n        self.mp = mp  # Inconsistent (not all caps like HP)\n        self.magic_power = magic_power\n\n    def cast(self):\n        if self.mp >= 10:\n            self.mp -= 10\n            return self.magic_power\n        return 0\n\n\ndef fixed_4():\n    # ✏️ FIX THE STYLE ✏️\n    #\n    # {{CONTEXT_STYLE_FIX_4}}\n    #\n    # Fix:\n    # - All class names to PascalCase (BaseUnit, WarriorUnit, MageUnit)\n    # - All attributes to snake_case\n    # - All methods to snake_case\n    # - Don't shadow built-ins (str -> strength)\n    # - Be consistent across the hierarchy\n    #\n    # Write your fixed version below:\n\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_FIX_STYLE_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{STYLE_1_TITLE}} ===\")\n    print(\"Original (poor style):\")\n    c = character(\"{{hero}}\", 100, 25)\n    c.Damage(30)\n    print(c.GetInfo())\n    print(\"\\nFixed (your version):\")\n    fixed_1()\n\n    print(\"\\n=== {{STYLE_2_TITLE}} ===\")\n    print(\"Original (poor style):\")\n    inv = INVENTORY(\"{{hero}}\")\n    inv.ADD(\"{{item}}\")\n    inv.addGold(50)\n    inv.Display()\n    print(\"\\nFixed (your version):\")\n    fixed_2()\n\n    print(\"\\n=== {{STYLE_3_TITLE}} ===\")\n    print(\"Original (poor style):\")\n    entity = e(\"{{hero}}\", 100, 50)\n    entity.f(30)\n    entity.g(20)\n    print(entity.h())\n    print(\"\\nFixed (your version):\")\n    fixed_3()\n\n    print(\"\\n=== {{STYLE_4_TITLE}} ===\")\n    print(\"Original (poor style):\")\n    warrior = warrior_unit(\"{{hero}}\", 100, 25)\n    mage = MageUnit(\"{{heroine}}\", 80, 50, 30)\n    print(f\"Warrior attack: {warrior.ATTACK()}\")\n    print(f\"Mage cast: {mage.cast()}\")\n    print(\"\\nFixed (your version):\")\n    fixed_4()\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"{{CONTEXT_IMPROVEMENT_COMPLETE}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "fix_style"
      ],
      "source_file": "module_9_oop/fix_style/exercise_1_oop_conventions.py"
    },
    {
      "id": "module_9_oop.hybrid.exercise_1_character_builder",
      "topic_id": "oop.classes",
      "exercise_type": "hybrid",
      "category": "hybrid",
      "title": "Character Builder",
      "title_en": "Character Builder",
      "title_he": "Character Builder",
      "description_en": "Object-Oriented Programming: Character Builder\n\n{{CONTEXT_DISCOVERY_INTRO}}\n\nThis is a multi-part exercise where you learn to build characters\nfor {{school}} by studying examples, adding methods, and creating\nyour own class designs.\n\nProgramming concepts: classes, __init__, self, instance methods, attributes",
      "description_he": "תכנות מונחה עצמים: Character Builder\n\n{{CONTEXT_DISCOVERY_INTRO}}\n\nThis is a multi-part exercise where you learn to build characters\nfor {{school}} by studying examples, adding methods, and creating\nyour own class designs.\n\nProgramming concepts: classes, __init__, self, instance methods, attributes",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "mental_execution",
        "syntax_recall",
        "implementation",
        "pattern_recognition",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_DISCOVERY_INTRO}}\n\nThis is a multi-part exercise where you learn to build characters\nfor {{school}} by studying examples, adding methods, and creating\nyour own class designs.\n\nProgramming concepts: classes, __init__, self, instance methods, attributes\n\"\"\"\n\n\n# ============================================================\n# PART 1: Guidance - Study and Complete the Class\n# ============================================================\n# {{CONTEXT_DISCOVERY_NARRATIVE}}\n#\n# {{mentor}} has created a character class for you to study.\n# Complete the missing method to understand how the class works.\n\n\nclass BaseCharacter:\n    \"\"\"A basic character class - study this structure!\"\"\"\n\n    def __init__(self, name, role, level=1):\n        \"\"\"Initialize a character with name, role, and level.\"\"\"\n        self.name = name\n        self.role = role\n        self.level = level\n        self.experience = 0\n\n    def gain_experience(self, amount):\n        \"\"\"\n        Add experience points to the character.\n\n        Args:\n            amount: Experience points to add\n\n        The character levels up when experience reaches level * 100.\n        When leveling up:\n        - Increase level by 1\n        - Reset experience to 0\n        - Print a level up message\n        \"\"\"\n        # ✏️ COMPLETE THIS METHOD ✏️\n        #\n        # {{CONTEXT_FUNCTION_HINT_1}}\n        #\n        # Step 1: Add amount to self.experience\n        #\n        # Step 2: Calculate experience needed: self.level * 100\n        #\n        # Step 3: If experience >= needed:\n        #         - Increase self.level by 1\n        #         - Set self.experience to 0\n        #         - Print: \"[name] leveled up to [level]!\"\n\n        pass\n\n    def get_info(self):\n        \"\"\"Return character info as a formatted string.\"\"\"\n        return f\"{self.name} ({self.role}) - Level {self.level}, XP: {self.experience}\"\n\n\ndef part1_test_base_character():\n    \"\"\"Test the BaseCharacter class with your completed method.\"\"\"\n    print(\">>> PART 1: Testing BaseCharacter...\")\n    print()\n\n    hero = BaseCharacter(\"{{hero}}\", \"{{ROLE_TITLE}}\")\n    print(hero.get_info())\n\n    hero.gain_experience(50)\n    print(f\"After 50 XP: {hero.get_info()}\")\n\n    hero.gain_experience(60)  # Should trigger level up\n    print(f\"After 60 more XP: {hero.get_info()}\")\n\n\n# ============================================================\n# PART 2: Growth - Add New Methods\n# ============================================================\n# {{CONTEXT_OWNERSHIP_INTRO}}\n# {{CONTEXT_OWNERSHIP_NARRATIVE}}\n#\n# Now extend the character with combat abilities.\n\n\nclass CombatCharacter:\n    \"\"\"A character with combat capabilities.\"\"\"\n\n    def __init__(self, name, role, health=100, strength=10):\n        \"\"\"Initialize a combat character.\"\"\"\n        self.name = name\n        self.role = role\n        self.health = health\n        self.max_health = health\n        self.strength = strength\n        self.is_defending = False\n\n    # ✏️ ADD THESE METHODS ✏️\n    #\n    # Method 1: attack(self, target)\n    #     Calculate damage: self.strength\n    #     If target.is_defending, reduce damage by half (use integer division)\n    #     Call target.take_damage(damage)\n    #     Return the damage dealt\n\n    # Method 2: take_damage(self, amount)\n    #     Subtract amount from self.health\n    #     Make sure health doesn't go below 0\n    #     Set self.is_defending to False (defending ends after being hit)\n    #     If health reaches 0, print: \"[name] has been defeated!\"\n\n    # Method 3: defend(self)\n    #     Set self.is_defending to True\n    #     Print: \"[name] takes a defensive stance!\"\n\n    # Method 4: get_status(self)\n    #     Return: \"[name]: [health]/[max_health] HP\"\n\n    pass  # Remove this line when you add methods\n\n\ndef part2_test_combat():\n    \"\"\"Test combat between characters.\"\"\"\n    print(\"\\n>>> PART 2: Testing CombatCharacter...\")\n    print()\n\n    hero = CombatCharacter(\"{{hero}}\", \"{{ROLE_TITLE}}\", health=100, strength=15)\n    enemy = CombatCharacter(\"{{villain}}\", \"Antagonist\", health=80, strength=12)\n\n    print(f\"Initial: {hero.get_status()}\")\n    print(f\"Initial: {enemy.get_status()}\")\n\n    print()\n    damage = hero.attack(enemy)\n    print(f\"{{{{hero}}}} attacks for {damage} damage!\")\n    print(f\"After attack: {enemy.get_status()}\")\n\n    print()\n    enemy.defend()\n    damage = hero.attack(enemy)\n    print(f\"{{{{hero}}}} attacks defending enemy for {damage} damage!\")\n    print(f\"After attack: {enemy.get_status()}\")\n\n\n# ============================================================\n# PART 3: Ownership - Create Your Own Class\n# ============================================================\n# {{CONTEXT_MASTERY_INTRO}}\n# {{CONTEXT_MASTERY_NARRATIVE}}\n#\n# Design your own character class with unique abilities.\n\n\ndef part3_create_your_class():\n    # ✏️ CREATE YOUR OWN CHARACTER CLASS ✏️\n    #\n    # Design a class for a specific type of character (e.g., healer,\n    # ranged attacker, support). Include:\n    #\n    # Required:\n    #     __init__ with at least 4 attributes\n    #     At least 3 methods that operate on the character's state\n    #     One method that interacts with another character object\n    #\n    # Ideas:\n    #     - A healer with heal_ally(target) method\n    #     - A character with a resource (mana, energy) that limits abilities\n    #     - A character with buff/debuff abilities\n    #\n    # After defining your class:\n    #     1. Create at least 2 instances\n    #     2. Test all your methods\n    #     3. Demonstrate the interaction method\n\n    pass\n\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_DISCOVERY_INTRO}}\")\n    print(\"=\" * 60)\n    print()\n\n    # Uncomment each part as you complete it:\n\n    # print(\">>> PART 1: Guidance - Complete the Method\")\n    # part1_test_base_character()\n\n    # print()\n    # print(\">>> PART 2: Growth - Add Combat Methods\")\n    # part2_test_combat()\n\n    # print()\n    # print(\">>> PART 3: Ownership - Create Your Own Class\")\n    # part3_create_your_class()\n\n    print()\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_TRIUMPH_COMPLETE}}\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "hybrid"
      ],
      "source_file": "module_9_oop/hybrid/exercise_1_character_builder.py"
    },
    {
      "id": "module_9_oop.hybrid.exercise_2_creature_collection",
      "topic_id": "oop.classes",
      "exercise_type": "hybrid",
      "category": "hybrid",
      "title": "Creature Collection",
      "title_en": "Creature Collection",
      "title_he": "Creature Collection",
      "description_en": "Object-Oriented Programming: Creature Collection\n\n{{CONTEXT_PROJECT_INTRO}}\n\nThis is a multi-part exercise where you build a {{creature}} management\nsystem using classes. You'll create creatures, display them, manage\ncollections, and implement interactions.\n\nProgramming concepts: classes, __str__, object collections, interactions",
      "description_he": "תכנות מונחה עצמים: Creature Collection\n\n{{CONTEXT_PROJECT_INTRO}}\n\nThis is a multi-part exercise where you build a {{creature}} management\nsystem using classes. You'll create creatures, display them, manage\ncollections, and implement interactions.\n\nProgramming concepts: classes, __str__, object collections, interactions",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "mental_execution",
        "syntax_recall",
        "implementation",
        "pattern_recognition",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n\nThis is a multi-part exercise where you build a {{creature}} management\nsystem using classes. You'll create creatures, display them, manage\ncollections, and implement interactions.\n\nProgramming concepts: classes, __str__, object collections, interactions\n\"\"\"\n\n\n# ============================================================\n# PART 1: Growth - Create the Base Creature Class\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n#\n# Start by creating a class to represent a single creature.\n\n\ndef part1_base_creature():\n    # ✏️ CREATE THE CREATURE CLASS ✏️\n    #\n    # Define a class called `Creature` with:\n    #\n    # __init__(self, name, species, power, health):\n    #     Store all as instance attributes\n    #     Also set self.is_tamed = False\n    #\n    # tame(self):\n    #     Set self.is_tamed to True\n    #     Print: \"[name] has been tamed!\"\n    #\n    # Test your class:\n    #     creature = Creature(\"Fang\", \"{{creature}}\", 45, 80)\n    #     print(f\"Name: {creature.name}\")\n    #     print(f\"Species: {creature.species}\")\n    #     print(f\"Tamed: {creature.is_tamed}\")\n    #     creature.tame()\n    #     print(f\"Tamed: {creature.is_tamed}\")\n\n    pass\n\n\n# ============================================================\n# PART 2: Growth - Add String Representation\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n#\n# Add a __str__ method to display creature information nicely.\n\n\ndef part2_str_method():\n    # ✏️ ENHANCE THE CREATURE CLASS WITH __str__ ✏️\n    #\n    # Copy your Creature class from Part 1 and add:\n    #\n    # __str__(self):\n    #     If tamed: \"[name] the [species] (Power: [power], HP: [health]) [TAMED]\"\n    #     If wild: \"[name] the [species] (Power: [power], HP: [health]) [WILD]\"\n    #\n    # Test:\n    #     creature1 = Creature(\"Fang\", \"{{creature}}\", 45, 80)\n    #     print(creature1)  # Should show [WILD]\n    #\n    #     creature1.tame()\n    #     print(creature1)  # Should show [TAMED]\n\n    pass\n\n\n# ============================================================\n# PART 3: Growth - Create a Collection Class\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n#\n# Create a class to manage multiple creatures.\n\n\ndef part3_collection():\n    # ✏️ CREATE THE COLLECTION CLASS ✏️\n    #\n    # First, keep your Creature class from Part 2.\n    #\n    # Then define a class called `CreatureCollection` with:\n    #\n    # __init__(self, owner_name):\n    #     self.owner_name = owner_name\n    #     self.creatures = []  # List of Creature objects\n    #\n    # add_creature(self, creature):\n    #     Append the creature to self.creatures\n    #     Print: \"[owner_name] added [creature.name] to collection!\"\n    #\n    # list_creatures(self):\n    #     Print: \"[owner_name]'s Creatures:\"\n    #     For each creature in self.creatures:\n    #         Print the creature (uses __str__)\n    #     If no creatures: Print \"  (empty)\"\n    #\n    # count_tamed(self):\n    #     Return the count of creatures where is_tamed is True\n    #\n    # Test:\n    #     collection = CreatureCollection(\"{{hero}}\")\n    #     collection.add_creature(Creature(\"Fang\", \"{{creature}}\", 45, 80))\n    #     collection.add_creature(Creature(\"Spark\", \"{{creature}}\", 30, 60))\n    #     collection.list_creatures()\n    #     print(f\"Tamed: {collection.count_tamed()}\")\n\n    pass\n\n\n# ============================================================\n# PART 4: Ownership - Add Creature Interaction\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n#\n# Add the ability for creatures to battle each other.\n\n\ndef part4_interaction():\n    # ✏️ ADD BATTLE INTERACTION ✏️\n    #\n    # Enhance your Creature class with:\n    #\n    # battle(self, other):\n    #     - other is another Creature object\n    #     - Compare power levels:\n    #         If self.power > other.power:\n    #             Reduce other.health by (self.power - other.power)\n    #             Return self (the winner)\n    #         Else if other.power > self.power:\n    #             Reduce self.health by (other.power - self.power)\n    #             Return other (the winner)\n    #         Else:\n    #             Return None (tie)\n    #     - Print the battle result\n    #\n    # Add to CreatureCollection:\n    #\n    # find_strongest(self):\n    #     Return the creature with highest power (or None if empty)\n    #\n    # Test battles:\n    #     creature1 = Creature(\"Fang\", \"{{creature}}\", 45, 80)\n    #     creature2 = Creature(\"Spark\", \"{{creature}}\", 30, 60)\n    #\n    #     winner = creature1.battle(creature2)\n    #     if winner:\n    #         print(f\"Winner: {winner.name}\")\n    #\n    #     print(f\"After battle:\")\n    #     print(creature1)\n    #     print(creature2)\n    #\n    # Test find_strongest:\n    #     collection = CreatureCollection(\"{{hero}}\")\n    #     # Add several creatures...\n    #     strongest = collection.find_strongest()\n    #     print(f\"Strongest: {strongest.name if strongest else 'None'}\")\n\n    pass\n\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"Building a {{creature}} Management System\")\n    print(\"=\" * 60)\n    print()\n\n    print(\">>> PART 1: Base Creature Class\")\n    print(\"(Create the basic Creature class)\")\n    part1_base_creature()\n    print()\n\n    print(\">>> PART 2: String Representation\")\n    print(\"(Add __str__ for nice display)\")\n    part2_str_method()\n    print()\n\n    print(\">>> PART 3: Collection Management\")\n    print(\"(Create CreatureCollection class)\")\n    part3_collection()\n    print()\n\n    print(\">>> PART 4: Creature Interactions\")\n    print(\"(Add battle and find_strongest)\")\n    part4_interaction()\n\n    print()\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "hybrid"
      ],
      "source_file": "module_9_oop/hybrid/exercise_2_creature_collection.py"
    },
    {
      "id": "module_9_oop.hybrid.exercise_3_inheritance_journey",
      "topic_id": "oop.classes",
      "exercise_type": "hybrid",
      "category": "hybrid",
      "title": "Inheritance Journey",
      "title_en": "Inheritance Journey",
      "title_he": "Inheritance Journey",
      "description_en": "Object-Oriented Programming: Inheritance Journey\n\n{{CONTEXT_DISCOVERY_INTRO}}\n\nThis is a multi-part exercise where {{hero}} discovers legacy code from\n{{mentor}} and must understand, extend, and improve it through inheritance.\n\nProgramming concepts: inheritance, super(), method overriding, polymorphism",
      "description_he": "תכנות מונחה עצמים: Inheritance Journey\n\n{{CONTEXT_DISCOVERY_INTRO}}\n\nThis is a multi-part exercise where {{hero}} discovers legacy code from\n{{mentor}} and must understand, extend, and improve it through inheritance.\n\nProgramming concepts: inheritance, super(), method overriding, polymorphism",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "mental_execution",
        "syntax_recall",
        "implementation",
        "pattern_recognition",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_DISCOVERY_INTRO}}\n\nThis is a multi-part exercise where {{hero}} discovers legacy code from\n{{mentor}} and must understand, extend, and improve it through inheritance.\n\nProgramming concepts: inheritance, super(), method overriding, polymorphism\n\"\"\"\n\n\n# ============================================================\n# PART 1: Discovery - Understand the Parent Class\n# ============================================================\n# {{CONTEXT_DISCOVERY_NARRATIVE}}\n#\n# {{mentor}} left behind this class. Before extending it, you need to\n# understand how it works. Study the code and complete the trace.\n\n\nclass BaseEntity:\n    \"\"\"The original entity class from {{mentor}}.\"\"\"\n\n    def __init__(self, name, health, level=1):\n        self.name = name\n        self.health = health\n        self.max_health = health\n        self.level = level\n\n    def take_damage(self, amount):\n        self.health = max(0, self.health - amount)\n        return self.health\n\n    def heal(self, amount):\n        self.health = min(self.max_health, self.health + amount)\n        return self.health\n\n    def get_stats(self):\n        return f\"{self.name} (Lv.{self.level}) - HP: {self.health}/{self.max_health}\"\n\n\ndef part1_trace_parent():\n    # ✏️ TRACE THE EXECUTION ✏️\n    #\n    # Given this code:\n    #     entity = BaseEntity(\"{{hero}}\", 100, 5)\n    #     entity.take_damage(30)\n    #     entity.heal(15)\n    #     entity.take_damage(100)\n    #\n    # Fill in the tracing table:\n    # | Step | Operation       | self.health | Return Value |\n    # |------|-----------------|-------------|--------------|\n    # | 0    | __init__        |             |              |\n    # | 1    | take_damage(30) |             |              |\n    # | 2    | heal(15)        |             |              |\n    # | 3    | take_damage(100)|             |              |\n    #\n    # Questions:\n    # 1. Why does heal(15) not restore health to 100?\n    # 2. What prevents health from going below 0?\n    #\n    # Write your completed table and answers as comments below:\n    #\n\n    pass\n\n\n# ============================================================\n# PART 2: Growth - Create First Subclass\n# ============================================================\n# {{CONTEXT_OWNERSHIP_INTRO}}\n# {{CONTEXT_OWNERSHIP_NARRATIVE}}\n#\n# Create a specialized character class that inherits from BaseEntity.\n\n\ndef part2_first_subclass():\n    # ✏️ CREATE THE WARRIOR SUBCLASS ✏️\n    #\n    # Define `Warrior` inheriting from BaseEntity with:\n    #\n    # __init__(self, name, health, level, strength):\n    #     Call super().__init__ with name, health, level\n    #     Add self.strength\n    #\n    # attack(self, target):\n    #     target is another BaseEntity or subclass\n    #     Deal damage equal to self.strength to target\n    #     Print: \"[name] attacks [target.name] for [strength] damage!\"\n    #     Return the target's remaining health\n    #\n    # get_stats(self):\n    #     Override to include strength:\n    #     Call super().get_stats() and add \" | STR: [strength]\"\n    #\n    # Test:\n    #     warrior = Warrior(\"{{hero}}\", 100, 5, 25)\n    #     print(warrior.get_stats())\n    #\n    #     target = BaseEntity(\"Training Dummy\", 60, 1)\n    #     warrior.attack(target)\n    #     print(target.get_stats())\n\n    pass\n\n\n# ============================================================\n# PART 3: Growth - Create Second Subclass\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n#\n# Create a different specialization with its own unique behavior.\n\n\ndef part3_second_subclass():\n    # ✏️ CREATE THE MAGE SUBCLASS ✏️\n    #\n    # Define `Mage` inheriting from BaseEntity with:\n    #\n    # __init__(self, name, health, level, mana, spell_power):\n    #     Call super().__init__ with name, health, level\n    #     Add self.mana and self.spell_power\n    #     Set self.max_mana = mana\n    #\n    # cast_spell(self, target, mana_cost=10):\n    #     If self.mana < mana_cost:\n    #         Print: \"[name] has insufficient mana!\"\n    #         Return 0\n    #     Else:\n    #         Reduce self.mana by mana_cost\n    #         Deal self.spell_power damage to target\n    #         Print: \"[name] casts a spell on [target.name] for [spell_power] damage!\"\n    #         Return the damage dealt\n    #\n    # rest(self):\n    #     Restore 20 mana (not exceeding max_mana)\n    #     Print: \"[name] rests and recovers mana. Mana: [current]/[max]\"\n    #\n    # get_stats(self):\n    #     Override to include mana:\n    #     Call super().get_stats() and add \" | MP: [mana]/[max_mana]\"\n    #\n    # Test:\n    #     mage = Mage(\"{{heroine}}\", 60, 5, 50, 30)\n    #     print(mage.get_stats())\n    #\n    #     target = BaseEntity(\"Target\", 100, 1)\n    #     mage.cast_spell(target)\n    #     mage.cast_spell(target)\n    #     print(mage.get_stats())\n    #     mage.rest()\n\n    pass\n\n\n# ============================================================\n# PART 4: Ownership - Add Shared Functionality\n# ============================================================\n# {{CONTEXT_MASTERY_INTRO}}\n# {{CONTEXT_MASTERY_NARRATIVE}}\n#\n# Create a party system that can work with any BaseEntity subclass.\n\n\ndef part4_party_system():\n    # ✏️ CREATE THE PARTY CLASS ✏️\n    #\n    # Define `Party` (does NOT inherit from BaseEntity):\n    #\n    # __init__(self, name):\n    #     self.name = name\n    #     self.members = []  # List of BaseEntity objects\n    #\n    # add_member(self, entity):\n    #     Append entity to members\n    #     Print: \"[entity.name] joined [party name]!\"\n    #\n    # list_members(self):\n    #     Print party name and all member stats\n    #     Use each member's get_stats() method\n    #\n    # total_health(self):\n    #     Return sum of all members' current health\n    #\n    # heal_all(self, amount):\n    #     Call heal(amount) on each member\n    #     Print: \"Party healed for [amount]!\"\n    #\n    # Test with mixed party:\n    #     party = Party(\"{{group}}\")\n    #\n    #     warrior = Warrior(\"{{hero}}\", 100, 5, 25)\n    #     mage = Mage(\"{{heroine}}\", 60, 5, 50, 30)\n    #     ally = BaseEntity(\"{{friend}}\", 80, 3)\n    #\n    #     party.add_member(warrior)\n    #     party.add_member(mage)\n    #     party.add_member(ally)\n    #\n    #     party.list_members()  # Each shows their specialized stats!\n    #\n    #     # Simulate damage\n    #     warrior.take_damage(30)\n    #     mage.take_damage(20)\n    #\n    #     print(f\"Total health: {party.total_health()}\")\n    #     party.heal_all(15)\n    #     party.list_members()\n\n    pass\n\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_DISCOVERY_INTRO}}\")\n    print(\"Inheritance Journey: Extending {{mentor}}'s Legacy\")\n    print(\"=\" * 60)\n    print()\n\n    print(\">>> PART 1: Discovery - Understand BaseEntity\")\n    print(\"(Study the code and complete the trace)\")\n    part1_trace_parent()\n    print()\n\n    print(\">>> PART 2: Growth - Create Warrior Subclass\")\n    print(\"(Inherit from BaseEntity, add strength)\")\n    part2_first_subclass()\n    print()\n\n    print(\">>> PART 3: Growth - Create Mage Subclass\")\n    print(\"(Different specialization with mana)\")\n    part3_second_subclass()\n    print()\n\n    print(\">>> PART 4: Ownership - Build Party System\")\n    print(\"(Work with any BaseEntity subclass)\")\n    part4_party_system()\n\n    print()\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_TRIUMPH_COMPLETE}}\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "hybrid"
      ],
      "source_file": "module_9_oop/hybrid/exercise_3_inheritance_journey.py"
    },
    {
      "id": "module_9_oop.hybrid.exercise_4_override_challenge",
      "topic_id": "oop.classes",
      "exercise_type": "hybrid",
      "category": "hybrid",
      "title": "Override Challenge",
      "title_en": "Override Challenge",
      "title_he": "Override Challenge",
      "description_en": "Object-Oriented Programming: Override Challenge\n\n{{CONTEXT_COMPARISON_INTRO}}\n\nThis is a multi-part exercise where two {{school}} students solved\nthe same problem with different override strategies. Evaluate\ntheir approaches, implement your own, and determine best practices.\n\nProgramming concepts: method overriding, super(), design choices",
      "description_he": "תכנות מונחה עצמים: Override Challenge\n\n{{CONTEXT_COMPARISON_INTRO}}\n\nThis is a multi-part exercise where two {{school}} students solved\nthe same problem with different override strategies. Evaluate\ntheir approaches, implement your own, and determine best practices.\n\nProgramming concepts: method overriding, super(), design choices",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "mental_execution",
        "syntax_recall",
        "implementation",
        "pattern_recognition",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_COMPARISON_INTRO}}\n\nThis is a multi-part exercise where two {{school}} students solved\nthe same problem with different override strategies. Evaluate\ntheir approaches, implement your own, and determine best practices.\n\nProgramming concepts: method overriding, super(), design choices\n\"\"\"\n\n\n# ============================================================\n# PART 1: Evaluation - Compare Base Class Implementations\n# ============================================================\n# {{CONTEXT_COMPARISON_DECISION}}\n#\n# Two students created different base classes for damage calculation.\n# Both work, but which design is better?\n\n\nclass DamageCalculatorA:\n    \"\"\"Student A's approach: Simple override.\"\"\"\n\n    def __init__(self, base_damage):\n        self.base_damage = base_damage\n\n    def calculate_damage(self):\n        return self.base_damage\n\n    def get_description(self):\n        return f\"Damage: {self.calculate_damage()}\"\n\n\nclass EnhancedCalculatorA(DamageCalculatorA):\n    \"\"\"Student A's subclass: Completely overrides calculate_damage.\"\"\"\n\n    def __init__(self, base_damage, multiplier):\n        super().__init__(base_damage)\n        self.multiplier = multiplier\n\n    def calculate_damage(self):\n        # Completely replaces parent's calculation\n        return self.base_damage * self.multiplier\n\n\nclass DamageCalculatorB:\n    \"\"\"Student B's approach: Designed for extension.\"\"\"\n\n    def __init__(self, base_damage):\n        self.base_damage = base_damage\n\n    def get_base_damage(self):\n        return self.base_damage\n\n    def calculate_modifiers(self):\n        return 1.0  # No modifiers in base class\n\n    def calculate_damage(self):\n        return int(self.get_base_damage() * self.calculate_modifiers())\n\n    def get_description(self):\n        return f\"Damage: {self.calculate_damage()}\"\n\n\nclass EnhancedCalculatorB(DamageCalculatorB):\n    \"\"\"Student B's subclass: Only overrides the modifier method.\"\"\"\n\n    def __init__(self, base_damage, multiplier):\n        super().__init__(base_damage)\n        self.multiplier = multiplier\n\n    def calculate_modifiers(self):\n        return self.multiplier  # Just change the modifier\n\n\ndef part1_evaluate_designs():\n    # ✏️ YOUR ANALYSIS ✏️\n    #\n    # Test both implementations:\n    #     calc_a = EnhancedCalculatorA(100, 1.5)\n    #     calc_b = EnhancedCalculatorB(100, 1.5)\n    #     print(f\"A: {calc_a.calculate_damage()}\")  # Should be 150\n    #     print(f\"B: {calc_b.calculate_damage()}\")  # Should be 150\n    #\n    # Both produce the same result, but which is better?\n    #\n    # Analysis questions:\n    # 1. Which approach is easier to extend further?\n    # 2. If you wanted to add ANOTHER modifier (like a bonus), which is easier?\n    # 3. Which follows \"Open/Closed Principle\" better? (Open for extension,\n    #    closed for modification)\n    #\n    # Write your analysis:\n\n    analysis = \"\"\"\n    Better approach: ??? (A or B)\n\n    Reasons:\n    1.\n    2.\n\n    When A's approach is appropriate:\n    -\n\n    When B's approach is appropriate:\n    -\n    \"\"\"\n    return analysis\n\n\n# ============================================================\n# PART 2: Growth - Implement Your Override\n# ============================================================\n# {{CONTEXT_OWNERSHIP_INTRO}}\n# {{CONTEXT_OWNERSHIP_NARRATIVE}}\n#\n# Using the base class design you prefer, create a new subclass.\n\n\nclass BaseCombatant:\n    \"\"\"Base class for combat calculations.\"\"\"\n\n    def __init__(self, name, power):\n        self.name = name\n        self.power = power\n        self.buffs = []  # List of buff names\n\n    def get_base_power(self):\n        return self.power\n\n    def calculate_buff_bonus(self):\n        # Each buff adds 10% to power\n        return len(self.buffs) * 0.1\n\n    def get_attack_power(self):\n        base = self.get_base_power()\n        buff_multiplier = 1 + self.calculate_buff_bonus()\n        return int(base * buff_multiplier)\n\n    def add_buff(self, buff_name):\n        self.buffs.append(buff_name)\n\n    def get_info(self):\n        return f\"{self.name} - Power: {self.get_attack_power()}\"\n\n\ndef part2_implement_override():\n    # ✏️ CREATE A SPECIALIZED COMBATANT ✏️\n    #\n    # Define `CriticalStriker` inheriting from BaseCombatant:\n    #\n    # __init__(self, name, power, crit_chance):\n    #     Call super().__init__\n    #     Add self.crit_chance (0.0 to 1.0)\n    #     Add self.last_hit_was_crit = False\n    #\n    # Override calculate_buff_bonus(self):\n    #     Get parent's buff bonus using super()\n    #     If crit_chance > 0.5, add an extra 0.2 (crit builds benefit more)\n    #     Return the total bonus\n    #\n    # Add critical_strike(self):\n    #     Import random if not done\n    #     If random.random() < self.crit_chance:\n    #         self.last_hit_was_crit = True\n    #         Return self.get_attack_power() * 2  # Double damage!\n    #     Else:\n    #         self.last_hit_was_crit = False\n    #         Return self.get_attack_power()\n    #\n    # Override get_info(self):\n    #     Extend parent's info to include crit chance\n    #\n    # Test:\n    #     striker = CriticalStriker(\"{{hero}}\", 50, 0.6)\n    #     striker.add_buff(\"{{spell1}}\")\n    #     print(striker.get_info())\n    #     for i in range(5):\n    #         damage = striker.critical_strike()\n    #         crit_text = \" (CRIT!)\" if striker.last_hit_was_crit else \"\"\n    #         print(f\"Attack: {damage}{crit_text}\")\n\n    pass\n\n\n# ============================================================\n# PART 3: Evaluation - Compare Override Strategies\n# ============================================================\n# {{CONTEXT_ANALYSIS_PROMPT}}\n#\n# Two ways to add healing to combatants - which is better?\n\n\nclass HealerTypeA(BaseCombatant):\n    \"\"\"Approach A: Override get_attack_power to sometimes heal instead.\"\"\"\n\n    def __init__(self, name, power, heal_power):\n        super().__init__(name, power)\n        self.heal_power = heal_power\n        self.mode = \"attack\"  # or \"heal\"\n\n    def set_mode(self, mode):\n        self.mode = mode\n\n    def get_attack_power(self):\n        if self.mode == \"heal\":\n            return -self.heal_power  # Negative = healing\n        return super().get_attack_power()\n\n\nclass HealerTypeB(BaseCombatant):\n    \"\"\"Approach B: Add separate healing method, don't override attack.\"\"\"\n\n    def __init__(self, name, power, heal_power):\n        super().__init__(name, power)\n        self.heal_power = heal_power\n\n    def get_heal_power(self):\n        buff_multiplier = 1 + self.calculate_buff_bonus()\n        return int(self.heal_power * buff_multiplier)\n\n    def heal(self, target):\n        amount = self.get_heal_power()\n        target.health = min(target.health + amount, target.max_health)\n        return amount\n\n\ndef part3_compare_strategies():\n    # ✏️ YOUR ANALYSIS ✏️\n    #\n    # Consider these scenarios:\n    #\n    # Scenario 1: A system expects positive attack values\n    # Scenario 2: You want to attack AND heal in the same turn\n    # Scenario 3: Other code checks combatant.get_attack_power() for AI decisions\n    #\n    # Write your analysis:\n\n    analysis = \"\"\"\n    Better approach for healing: ??? (A or B)\n\n    Problems with approach A:\n    1.\n    2.\n\n    Why approach B is better/worse:\n    1.\n    2.\n\n    General principle this illustrates:\n    -\n    \"\"\"\n    return analysis\n\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_COMPARISON_INTRO}}\")\n    print(\"Method Override Challenge\")\n    print(\"=\" * 60)\n    print()\n\n    print(\">>> PART 1: Evaluate Design Approaches\")\n    print()\n    # Test both designs\n    calc_a = EnhancedCalculatorA(100, 1.5)\n    calc_b = EnhancedCalculatorB(100, 1.5)\n    print(f\"Approach A result: {calc_a.calculate_damage()}\")\n    print(f\"Approach B result: {calc_b.calculate_damage()}\")\n    print()\n    print(\"Your analysis:\")\n    print(part1_evaluate_designs())\n    print()\n\n    print(\">>> PART 2: Implement CriticalStriker\")\n    print(\"(Create your own override)\")\n    part2_implement_override()\n    print()\n\n    print(\">>> PART 3: Compare Healing Strategies\")\n    print()\n    print(\"Your analysis:\")\n    print(part3_compare_strategies())\n\n    print()\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_EVALUATION_COMPLETE}}\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "hybrid"
      ],
      "source_file": "module_9_oop/hybrid/exercise_4_override_challenge.py"
    },
    {
      "id": "module_9_oop.hybrid.exercise_5_style_refactor",
      "topic_id": "oop.classes",
      "exercise_type": "hybrid",
      "category": "hybrid",
      "title": "Style Refactor",
      "title_en": "Style Refactor",
      "title_he": "Style Refactor",
      "description_en": "Object-Oriented Programming: Style Refactor\n\n{{CONTEXT_FIX_STYLE_INTRO}}\n\nThis is a multi-part exercise where you identify style problems,\nfix them, and then reorganize code into a proper class structure.\n\nProgramming concepts: OOP conventions, refactoring, code organization",
      "description_he": "תכנות מונחה עצמים: Style Refactor\n\n{{CONTEXT_FIX_STYLE_INTRO}}\n\nThis is a multi-part exercise where you identify style problems,\nfix them, and then reorganize code into a proper class structure.\n\nProgramming concepts: OOP conventions, refactoring, code organization",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "mental_execution",
        "syntax_recall",
        "implementation",
        "pattern_recognition",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_FIX_STYLE_INTRO}}\n\nThis is a multi-part exercise where you identify style problems,\nfix them, and then reorganize code into a proper class structure.\n\nProgramming concepts: OOP conventions, refactoring, code organization\n\"\"\"\n\n\n# ============================================================\n# PART 1: Evaluation - Identify What's Wrong\n# ============================================================\n# {{CONTEXT_INVESTIGATION_INTRO}}\n# {{CONTEXT_INVESTIGATION_NARRATIVE}}\n#\n# Legacy code from {{school}}'s old system. It works, but has problems.\n\n\nclass data:\n    def __init__(s, N, v1, v2, v3):\n        s.N = N\n        s.v1 = v1\n        s.v2 = v2\n        s.v3 = v3\n\n    def ProcessData(s, x):\n        s.v1 = s.v1 + x\n        if s.v1 > 100:\n            s.v1 = 100\n\n    def DoOther(s, y):\n        if s.v2 >= y:\n            s.v2 = s.v2 - y\n            s.v3 = s.v3 + 1\n            return True\n        return False\n\n    def Info(s):\n        return s.N + \": \" + str(s.v1) + \"/\" + str(s.v2) + \"/\" + str(s.v3)\n\n\ndef part1_identify_problems():\n    # ✏️ IDENTIFY THE STYLE ISSUES ✏️\n    #\n    # List all the problems with the code above:\n    #\n    # Class name issues:\n    # 1.\n    #\n    # Parameter naming issues:\n    # 2.\n    # 3.\n    #\n    # Attribute naming issues:\n    # 4.\n    # 5.\n    #\n    # Method naming issues:\n    # 6.\n    # 7.\n    #\n    # Other issues:\n    # 8. (hint: look at the 'self' parameter)\n    # 9. (hint: string formatting)\n    #\n    # What do you think this class actually represents?\n    # (The attributes seem to be: name, some value capped at 100,\n    #  some resource that gets consumed, and a counter)\n    #\n    # Your guess: _______________\n\n    pass\n\n\n# ============================================================\n# PART 2: Improvement - Fix the Naming\n# ============================================================\n# {{CONTEXT_STYLE_FIX_1}}\n#\n# Apply proper naming conventions to the code.\n\n\ndef part2_fix_naming():\n    # ✏️ FIX THE NAMING ✏️\n    #\n    # Rewrite the class with proper conventions:\n    #\n    # Assuming this is a character with:\n    # - name (N)\n    # - health (v1) capped at 100\n    # - energy (v2) consumed by actions\n    # - actions_completed counter (v3)\n    #\n    # Apply these fixes:\n    # - Class name: PascalCase, meaningful (ActionTracker? Character?)\n    # - self, not s\n    # - Descriptive parameter and attribute names\n    # - snake_case method names\n    # - Meaningful method names (heal instead of ProcessData, etc.)\n    # - f-strings for formatting\n    #\n    # Write your fixed version:\n\n    pass\n\n\n# ============================================================\n# PART 3: Growth - Reorganize Into Proper Structure\n# ============================================================\n# {{CONTEXT_OWNERSHIP_INTRO}}\n# {{CONTEXT_OWNERSHIP_NARRATIVE}}\n#\n# Now refactor into a well-organized class with clear responsibilities.\n\n\ndef part3_reorganize():\n    # ✏️ REORGANIZE THE CODE ✏️\n    #\n    # Create a properly structured class:\n    #\n    # class Character:\n    #     \"\"\"A character that can perform actions at {{school}}.\n    #\n    #     Attributes:\n    #         name: The character's name\n    #         health: Current health (0-100)\n    #         max_health: Maximum health (default 100)\n    #         energy: Current energy for actions\n    #         actions_completed: Count of successful actions\n    #     \"\"\"\n    #\n    #     def __init__(self, name, health, energy):\n    #         \"\"\"Initialize a new character.\"\"\"\n    #         # Your code here\n    #         pass\n    #\n    #     def heal(self, amount):\n    #         \"\"\"Restore health, capped at max_health.\n    #\n    #         Args:\n    #             amount: Health points to restore\n    #\n    #         Returns:\n    #             The new health value\n    #         \"\"\"\n    #         # Your code here\n    #         pass\n    #\n    #     def perform_action(self, energy_cost):\n    #         \"\"\"Attempt to perform an action that costs energy.\n    #\n    #         Args:\n    #             energy_cost: Energy required for the action\n    #\n    #         Returns:\n    #             True if action was performed, False if not enough energy\n    #         \"\"\"\n    #         # Your code here\n    #         pass\n    #\n    #     def get_status(self):\n    #         \"\"\"Get a formatted status string.\"\"\"\n    #         # Your code here\n    #         pass\n    #\n    #     def __str__(self):\n    #         \"\"\"Return string representation.\"\"\"\n    #         # Your code here\n    #         pass\n    #\n    # Test your reorganized class:\n    #     char = Character(\"{{hero}}\", 50, 30)\n    #     print(char)\n    #\n    #     char.heal(30)\n    #     print(f\"After healing: {char.get_status()}\")\n    #\n    #     char.perform_action(10)\n    #     char.perform_action(10)\n    #     print(f\"After 2 actions: {char}\")\n\n    pass\n\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_FIX_STYLE_INTRO}}\")\n    print(\"Legacy Code Refactoring\")\n    print(\"=\" * 60)\n    print()\n\n    print(\">>> PART 1: Identify What's Wrong\")\n    print()\n    print(\"Original code:\")\n    d = data(\"{{hero}}\", 50, 30, 0)\n    d.ProcessData(30)\n    d.DoOther(10)\n    print(d.Info())\n    print()\n    print(\"(List the style problems you found)\")\n    part1_identify_problems()\n    print()\n\n    print(\">>> PART 2: Fix the Naming\")\n    print(\"(Rewrite with proper conventions)\")\n    part2_fix_naming()\n    print()\n\n    print(\">>> PART 3: Reorganize Into Proper Structure\")\n    print(\"(Create a well-documented, properly structured class)\")\n    part3_reorganize()\n\n    print()\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_IMPROVEMENT_COMPLETE}}\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "hybrid"
      ],
      "source_file": "module_9_oop/hybrid/exercise_5_style_refactor.py"
    },
    {
      "id": "module_9_oop.hybrid.exercise_6_oop_vs_procedural",
      "topic_id": "oop.classes",
      "exercise_type": "hybrid",
      "category": "hybrid",
      "title": "Oop Vs Procedural",
      "title_en": "Oop Vs Procedural",
      "title_he": "Oop Vs Procedural",
      "description_en": "Object-Oriented Programming: Oop Vs Procedural\n\n{{CONTEXT_COMPARISON_INTRO}}\n\nThis is a multi-part exercise exploring when to use OOP vs procedural\napproaches. You'll compare implementations, convert between styles,\nand design your own system with justification.\n\nProgramming concepts: OOP vs procedural, design decisions, refactoring",
      "description_he": "תכנות מונחה עצמים: Oop Vs Procedural\n\n{{CONTEXT_COMPARISON_INTRO}}\n\nThis is a multi-part exercise exploring when to use OOP vs procedural\napproaches. You'll compare implementations, convert between styles,\nand design your own system with justification.\n\nProgramming concepts: OOP vs procedural, design decisions, refactoring",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "mental_execution",
        "syntax_recall",
        "implementation",
        "pattern_recognition",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_COMPARISON_INTRO}}\n\nThis is a multi-part exercise exploring when to use OOP vs procedural\napproaches. You'll compare implementations, convert between styles,\nand design your own system with justification.\n\nProgramming concepts: OOP vs procedural, design decisions, refactoring\n\"\"\"\n\n\n# ============================================================\n# PART 1: Evaluation - Compare Dict-Based vs Class-Based\n# ============================================================\n# {{CONTEXT_COMPARISON_DECISION}}\n#\n# The {{school}} records system has two implementations.\n\n\n# Version A: Dictionary-based (procedural)\n\n\ndef create_student_dict(name, house, year):\n    \"\"\"Create a student record as a dictionary.\"\"\"\n    return {\n        \"name\": name,\n        \"house\": house,\n        \"year\": year,\n        \"grades\": {},\n        \"attendance\": 0\n    }\n\n\ndef add_grade_dict(student, subject, grade):\n    \"\"\"Add a grade to a student dictionary.\"\"\"\n    student[\"grades\"][subject] = grade\n\n\ndef record_attendance_dict(student):\n    \"\"\"Increment attendance for a student dictionary.\"\"\"\n    student[\"attendance\"] += 1\n\n\ndef get_average_grade_dict(student):\n    \"\"\"Calculate average grade for a student dictionary.\"\"\"\n    grades = student[\"grades\"].values()\n    if not grades:\n        return 0\n    return sum(grades) / len(grades)\n\n\ndef promote_student_dict(student):\n    \"\"\"Promote student to next year.\"\"\"\n    student[\"year\"] += 1\n\n\n# Version B: Class-based (OOP)\n\n\nclass Student:\n    \"\"\"A student at {{school}}.\"\"\"\n\n    def __init__(self, name, house, year):\n        self.name = name\n        self.house = house\n        self.year = year\n        self.grades = {}\n        self.attendance = 0\n\n    def add_grade(self, subject, grade):\n        \"\"\"Add a grade for a subject.\"\"\"\n        self.grades[subject] = grade\n\n    def record_attendance(self):\n        \"\"\"Increment attendance count.\"\"\"\n        self.attendance += 1\n\n    def get_average_grade(self):\n        \"\"\"Calculate average grade.\"\"\"\n        if not self.grades:\n            return 0\n        return sum(self.grades.values()) / len(self.grades)\n\n    def promote(self):\n        \"\"\"Promote to next year.\"\"\"\n        self.year += 1\n\n\ndef part1_compare():\n    # ✏️ YOUR ANALYSIS ✏️\n    #\n    # Test both versions:\n    #\n    #     # Dict version\n    #     s1 = create_student_dict(\"{{hero}}\", \"{{house}}\", 1)\n    #     add_grade_dict(s1, \"{{spell1}}\", 90)\n    #     add_grade_dict(s1, \"{{spell2}}\", 85)\n    #     record_attendance_dict(s1)\n    #     print(f\"Dict avg: {get_average_grade_dict(s1)}\")\n    #\n    #     # Class version\n    #     s2 = Student(\"{{hero}}\", \"{{house}}\", 1)\n    #     s2.add_grade(\"{{spell1}}\", 90)\n    #     s2.add_grade(\"{{spell2}}\", 85)\n    #     s2.record_attendance()\n    #     print(f\"Class avg: {s2.get_average_grade()}\")\n    #\n    # Write your comparison:\n\n    analysis = \"\"\"\n    Comparison:\n\n    Dict version calling style:\n        add_grade_dict(student, subject, grade)\n\n    Class version calling style:\n        student.add_grade(subject, grade)\n\n    Which is more intuitive?\n    -\n\n    Which is easier to get wrong (e.g., pass wrong data)?\n    -\n\n    Which would be easier to extend with new features?\n    -\n    \"\"\"\n    return analysis\n\n\n# ============================================================\n# PART 2: Growth - Convert Procedural to OOP\n# ============================================================\n# {{CONTEXT_OWNERSHIP_INTRO}}\n# {{CONTEXT_OWNERSHIP_NARRATIVE}}\n#\n# Convert this procedural inventory system to OOP.\n\n\n# Procedural version to convert\n\n\ndef create_inventory(name, max_slots):\n    return {\"name\": name, \"max_slots\": max_slots, \"items\": [], \"gold\": 0}\n\n\ndef add_item(inventory, item_name, item_value):\n    if len(inventory[\"items\"]) < inventory[\"max_slots\"]:\n        inventory[\"items\"].append({\"name\": item_name, \"value\": item_value})\n        return True\n    return False\n\n\ndef remove_item(inventory, item_name):\n    for i, item in enumerate(inventory[\"items\"]):\n        if item[\"name\"] == item_name:\n            inventory[\"items\"].pop(i)\n            return True\n    return False\n\n\ndef get_total_value(inventory):\n    total = inventory[\"gold\"]\n    for item in inventory[\"items\"]:\n        total += item[\"value\"]\n    return total\n\n\ndef display_inventory(inventory):\n    print(f\"=== {inventory['name']}'s Inventory ===\")\n    print(f\"Slots: {len(inventory['items'])}/{inventory['max_slots']}\")\n    for item in inventory[\"items\"]:\n        print(f\"  - {item['name']} ({item['value']} gold)\")\n    print(f\"Gold: {inventory['gold']}\")\n    print(f\"Total value: {get_total_value(inventory)}\")\n\n\ndef part2_convert_to_oop():\n    # ✏️ CONVERT TO OOP ✏️\n    #\n    # Create an Inventory class and Item class that replicate this functionality.\n    #\n    # class Item:\n    #     def __init__(self, name, value):\n    #         pass\n    #\n    # class Inventory:\n    #     def __init__(self, owner_name, max_slots):\n    #         pass\n    #\n    #     def add_item(self, item):\n    #         pass\n    #\n    #     def remove_item(self, item_name):\n    #         pass\n    #\n    #     def get_total_value(self):\n    #         pass\n    #\n    #     def __str__(self):\n    #         pass\n    #\n    # Test your conversion:\n    #     inv = Inventory(\"{{hero}}\", 5)\n    #     inv.add_item(Item(\"{{item}}\", 100))\n    #     inv.add_item(Item(\"{{spell1}}\", 50))\n    #     inv.gold = 200\n    #     print(inv)\n    #     print(f\"Total value: {inv.get_total_value()}\")\n\n    pass\n\n\n# ============================================================\n# PART 3: Ownership - Design Your Own System\n# ============================================================\n# {{CONTEXT_MASTERY_INTRO}}\n# {{CONTEXT_MASTERY_NARRATIVE}}\n#\n# Design a quest tracking system. You choose the approach!\n\n\ndef part3_design_system():\n    # ✏️ DESIGN YOUR OWN SYSTEM ✏️\n    #\n    # Requirements for Quest Tracking System:\n    # - Track quest name, description, and status (active/completed)\n    # - Track rewards (experience points, gold, items)\n    # - Support multiple objectives per quest\n    # - Track progress on each objective\n    # - Mark quest complete when all objectives are done\n    #\n    # Decision: Will you use OOP or procedural?\n    #\n    # If OOP, consider these classes:\n    # - Quest (name, description, status, objectives, rewards)\n    # - Objective (description, current_progress, target_progress)\n    # - QuestLog (collection of quests, active/completed filtering)\n    #\n    # If procedural, consider these functions:\n    # - create_quest, add_objective, update_progress\n    # - check_completion, get_active_quests, etc.\n    #\n    # Implement your chosen approach and justify your decision:\n\n    justification = \"\"\"\n    I chose: ??? (OOP / Procedural)\n\n    Reasons:\n    1.\n    2.\n    3.\n\n    This approach is better for this problem because:\n    -\n    \"\"\"\n\n    # Your implementation here:\n    pass\n\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_COMPARISON_INTRO}}\")\n    print(\"OOP vs Procedural Design\")\n    print(\"=\" * 60)\n    print()\n\n    print(\">>> PART 1: Compare Dict vs Class\")\n    print()\n\n    # Dict version\n    s_dict = create_student_dict(\"{{hero}}\", \"{{house}}\", 1)\n    add_grade_dict(s_dict, \"{{spell1}}\", 90)\n    add_grade_dict(s_dict, \"{{spell2}}\", 85)\n    print(f\"Dict approach - Avg grade: {get_average_grade_dict(s_dict)}\")\n\n    # Class version\n    s_class = Student(\"{{hero}}\", \"{{house}}\", 1)\n    s_class.add_grade(\"{{spell1}}\", 90)\n    s_class.add_grade(\"{{spell2}}\", 85)\n    print(f\"Class approach - Avg grade: {s_class.get_average_grade()}\")\n\n    print()\n    print(\"Your analysis:\")\n    print(part1_compare())\n    print()\n\n    print(\">>> PART 2: Convert Procedural to OOP\")\n    print()\n    print(\"Procedural version:\")\n    inv = create_inventory(\"{{hero}}\", 5)\n    add_item(inv, \"{{item}}\", 100)\n    add_item(inv, \"{{spell1}}\", 50)\n    inv[\"gold\"] = 200\n    display_inventory(inv)\n    print()\n    print(\"Convert to OOP:\")\n    part2_convert_to_oop()\n    print()\n\n    print(\">>> PART 3: Design Your Own Quest System\")\n    print(\"(Choose OOP or procedural and justify)\")\n    part3_design_system()\n\n    print()\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_EVALUATION_COMPLETE}}\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "hybrid"
      ],
      "source_file": "module_9_oop/hybrid/exercise_6_oop_vs_procedural.py"
    },
    {
      "id": "module_9_oop.hybrid.exercise_7_game_entities",
      "topic_id": "oop.classes",
      "exercise_type": "hybrid",
      "category": "hybrid",
      "title": "Game Entities",
      "title_en": "Game Entities",
      "title_he": "Game Entities",
      "description_en": "Object-Oriented Programming: Game Entities\n\n{{CONTEXT_PROJECT_INTRO}}\n\nThis is a multi-part exercise where you build a complete game entity\nhierarchy for {{school}}. You'll create base classes, player and enemy\nsubclasses, and implement combat interactions.\n\nProgramming concepts: inheritance, method overriding, polymorphism, composition",
      "description_he": "תכנות מונחה עצמים: Game Entities\n\n{{CONTEXT_PROJECT_INTRO}}\n\nThis is a multi-part exercise where you build a complete game entity\nhierarchy for {{school}}. You'll create base classes, player and enemy\nsubclasses, and implement combat interactions.\n\nProgramming concepts: inheritance, method overriding, polymorphism, composition",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "mental_execution",
        "syntax_recall",
        "implementation",
        "pattern_recognition",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n\nThis is a multi-part exercise where you build a complete game entity\nhierarchy for {{school}}. You'll create base classes, player and enemy\nsubclasses, and implement combat interactions.\n\nProgramming concepts: inheritance, method overriding, polymorphism, composition\n\"\"\"\n\n\n# ============================================================\n# PART 1: Growth - Create the Base Entity Class\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n#\n# Start with a solid foundation for all game entities.\n\n\ndef part1_base_entity():\n    # ✏️ CREATE THE BASE ENTITY CLASS ✏️\n    #\n    # class Entity:\n    #     \"\"\"Base class for all game entities.\"\"\"\n    #\n    #     def __init__(self, name, health, position=(0, 0)):\n    #         \"\"\"\n    #         Initialize an entity.\n    #\n    #         Args:\n    #             name: Entity name\n    #             health: Starting health (also sets max_health)\n    #             position: (x, y) tuple for location\n    #         \"\"\"\n    #         # Set name, health, max_health, position\n    #         # Set is_alive = True\n    #         pass\n    #\n    #     def take_damage(self, amount):\n    #         \"\"\"Reduce health by amount, minimum 0. Update is_alive.\"\"\"\n    #         pass\n    #\n    #     def heal(self, amount):\n    #         \"\"\"Restore health by amount, maximum max_health.\"\"\"\n    #         pass\n    #\n    #     def move_to(self, new_position):\n    #         \"\"\"Update position to new (x, y) tuple.\"\"\"\n    #         pass\n    #\n    #     def distance_to(self, other):\n    #         \"\"\"Calculate distance to another entity.\n    #         Use: sqrt((x2-x1)^2 + (y2-y1)^2)\n    #         Hint: import math, use math.sqrt\n    #         \"\"\"\n    #         pass\n    #\n    #     def get_status(self):\n    #         \"\"\"Return status string.\"\"\"\n    #         pass\n    #\n    #     def __str__(self):\n    #         \"\"\"Return string representation.\"\"\"\n    #         pass\n    #\n    # Test:\n    #     entity = Entity(\"{{hero}}\", 100, (5, 5))\n    #     print(entity)\n    #     entity.take_damage(30)\n    #     print(f\"After damage: {entity.get_status()}\")\n    #     entity.move_to((10, 10))\n    #     print(f\"Position: {entity.position}\")\n\n    pass\n\n\n# ============================================================\n# PART 2: Growth - Create the Player Subclass\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n#\n# Create a player class with inventory and experience.\n\n\ndef part2_player_class():\n    # ✏️ CREATE THE PLAYER CLASS ✏️\n    #\n    # class Player(Entity):\n    #     \"\"\"A player-controlled entity.\"\"\"\n    #\n    #     def __init__(self, name, health, position=(0, 0)):\n    #         \"\"\"Initialize player with experience system and inventory.\"\"\"\n    #         # Call super().__init__\n    #         # Add: level = 1, experience = 0, inventory = []\n    #         pass\n    #\n    #     def gain_experience(self, amount):\n    #         \"\"\"Add XP. Level up at 100 XP per level.\"\"\"\n    #         # Add amount to experience\n    #         # While experience >= level * 100:\n    #         #     Subtract level * 100 from experience\n    #         #     Increment level\n    #         #     Increase max_health by 10\n    #         #     Restore health to full\n    #         #     Print level up message\n    #         pass\n    #\n    #     def pick_up_item(self, item_name):\n    #         \"\"\"Add item to inventory.\"\"\"\n    #         pass\n    #\n    #     def use_item(self, item_name):\n    #         \"\"\"Remove and return item from inventory, or None.\"\"\"\n    #         pass\n    #\n    #     def get_status(self):\n    #         \"\"\"Override to include level and XP.\"\"\"\n    #         pass\n    #\n    # Test:\n    #     player = Player(\"{{hero}}\", 100)\n    #     player.pick_up_item(\"{{item}}\")\n    #     player.gain_experience(150)  # Should level up\n    #     print(player.get_status())\n    #     print(f\"Inventory: {player.inventory}\")\n\n    pass\n\n\n# ============================================================\n# PART 3: Growth - Create the Enemy Subclass\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n#\n# Create enemy types with different behaviors.\n\n\ndef part3_enemy_class():\n    # ✏️ CREATE THE ENEMY CLASS ✏️\n    #\n    # class Enemy(Entity):\n    #     \"\"\"An AI-controlled hostile entity.\"\"\"\n    #\n    #     def __init__(self, name, health, position, damage, xp_reward):\n    #         \"\"\"Initialize enemy with combat stats.\"\"\"\n    #         # Call super().__init__\n    #         # Add: damage, xp_reward, aggro_range = 5.0\n    #         pass\n    #\n    #     def attack(self, target):\n    #         \"\"\"Attack a target entity.\"\"\"\n    #         # Deal self.damage to target\n    #         # Print attack message\n    #         # Return damage dealt\n    #         pass\n    #\n    #     def is_in_range(self, target):\n    #         \"\"\"Check if target is within aggro_range.\"\"\"\n    #         pass\n    #\n    #     def on_death(self, killer):\n    #         \"\"\"Called when enemy dies. Give XP to killer if Player.\"\"\"\n    #         # If killer has gain_experience method, call it with xp_reward\n    #         # Print death message\n    #         pass\n    #\n    # Test:\n    #     enemy = Enemy(\"{{creature}}\", 50, (3, 3), 15, 25)\n    #     player = Player(\"{{hero}}\", 100, (5, 5))\n    #     print(f\"In range: {enemy.is_in_range(player)}\")\n    #     enemy.attack(player)\n    #     print(player.get_status())\n\n    pass\n\n\n# ============================================================\n# PART 4: Growth - Implement Combat Interaction\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n#\n# Create a combat system that handles entity interactions.\n\n\ndef part4_combat_system():\n    # ✏️ CREATE THE COMBAT SYSTEM ✏️\n    #\n    # class CombatSystem:\n    #     \"\"\"Manages combat between entities.\"\"\"\n    #\n    #     def __init__(self):\n    #         \"\"\"Initialize with empty entity lists.\"\"\"\n    #         self.players = []\n    #         self.enemies = []\n    #         self.combat_log = []\n    #\n    #     def add_player(self, player):\n    #         \"\"\"Add a player to the system.\"\"\"\n    #         pass\n    #\n    #     def add_enemy(self, enemy):\n    #         \"\"\"Add an enemy to the system.\"\"\"\n    #         pass\n    #\n    #     def log_event(self, message):\n    #         \"\"\"Add message to combat log and print it.\"\"\"\n    #         pass\n    #\n    #     def player_attack(self, player, target):\n    #         \"\"\"Handle player attacking an enemy.\"\"\"\n    #         # Calculate damage (could add player weapon damage later)\n    #         # Deal damage to target\n    #         # Log the attack\n    #         # If target dies, call on_death and remove from enemies\n    #         pass\n    #\n    #     def enemy_turn(self):\n    #         \"\"\"Process all enemy actions.\"\"\"\n    #         # For each alive enemy:\n    #         #     Find nearest player\n    #         #     If in range, attack\n    #         #     Log actions\n    #         pass\n    #\n    #     def get_battle_status(self):\n    #         \"\"\"Return summary of all combatants.\"\"\"\n    #         pass\n    #\n    # Test combat:\n    #     combat = CombatSystem()\n    #     player = Player(\"{{hero}}\", 100, (0, 0))\n    #     enemy1 = Enemy(\"{{creature}}\", 30, (2, 2), 10, 20)\n    #     enemy2 = Enemy(\"{{creature}}\", 40, (3, 1), 12, 25)\n    #\n    #     combat.add_player(player)\n    #     combat.add_enemy(enemy1)\n    #     combat.add_enemy(enemy2)\n    #\n    #     print(combat.get_battle_status())\n    #     combat.player_attack(player, enemy1)\n    #     combat.enemy_turn()\n    #     print(combat.get_battle_status())\n\n    pass\n\n\n# ============================================================\n# PART 5: Ownership - Add Your Own Entity Type\n# ============================================================\n# {{CONTEXT_MASTERY_INTRO}}\n# {{CONTEXT_MASTERY_NARRATIVE}}\n#\n# Design your own unique entity type that fits the hierarchy.\n\n\ndef part5_custom_entity():\n    # ✏️ CREATE YOUR OWN ENTITY TYPE ✏️\n    #\n    # Ideas:\n    # - Boss(Enemy): Multiple phases, special attacks\n    # - Companion(Entity): Follows player, provides buffs\n    # - NPC(Entity): Can be talked to, gives quests\n    # - Trap(Entity): Stationary, damages on contact\n    # - Healer(Entity): Restores health to nearby allies\n    #\n    # Requirements:\n    # - Must inherit from Entity or one of its subclasses\n    # - Must add at least 2 new attributes\n    # - Must add at least 2 new methods\n    # - Must override at least 1 parent method\n    # - Must interact meaningfully with other entities\n    #\n    # Demonstrate your entity in action with other entities.\n\n    pass\n\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"Building a Game Entity System\")\n    print(\"=\" * 60)\n    print()\n\n    print(\">>> PART 1: Base Entity Class\")\n    print(\"(Create the foundation for all entities)\")\n    part1_base_entity()\n    print()\n\n    print(\">>> PART 2: Player Subclass\")\n    print(\"(Add inventory and experience system)\")\n    part2_player_class()\n    print()\n\n    print(\">>> PART 3: Enemy Subclass\")\n    print(\"(Create hostile entities with combat)\")\n    part3_enemy_class()\n    print()\n\n    print(\">>> PART 4: Combat System\")\n    print(\"(Manage entity interactions)\")\n    part4_combat_system()\n    print()\n\n    print(\">>> PART 5: Your Custom Entity\")\n    print(\"(Design your own unique entity type)\")\n    part5_custom_entity()\n\n    print()\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "hybrid"
      ],
      "source_file": "module_9_oop/hybrid/exercise_7_game_entities.py"
    },
    {
      "id": "module_9_oop.hybrid.exercise_8_school_management",
      "topic_id": "oop.classes",
      "exercise_type": "hybrid",
      "category": "hybrid",
      "title": "School Management",
      "title_en": "School Management",
      "title_he": "School Management",
      "description_en": "Object-Oriented Programming: School Management\n\n{{CONTEXT_PROJECT_INTRO}}\n\nCAPSTONE PROJECT: Design and build a complete management system for {{school}}\nusing OOP principles. This exercise integrates all Module 9 concepts.\n\nProgramming concepts: class design, inheritance, composition, encapsulation",
      "description_he": "תכנות מונחה עצמים: School Management\n\n{{CONTEXT_PROJECT_INTRO}}\n\nCAPSTONE PROJECT: Design and build a complete management system for {{school}}\nusing OOP principles. This exercise integrates all Module 9 concepts.\n\nProgramming concepts: class design, inheritance, composition, encapsulation",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "mental_execution",
        "syntax_recall",
        "implementation",
        "pattern_recognition",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n\nCAPSTONE PROJECT: Design and build a complete management system for {{school}}\nusing OOP principles. This exercise integrates all Module 9 concepts.\n\nProgramming concepts: class design, inheritance, composition, encapsulation\n\"\"\"\n\n\n# ============================================================\n# PART 1: Growth - Design the Core Class Hierarchy\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n#\n# Design the foundational classes for the system.\n\n\ndef part1_core_classes():\n    # ✏️ DESIGN THE CORE CLASSES ✏️\n    #\n    # Base class: Person\n    #     - name (string)\n    #     - age (integer)\n    #     - id_number (unique identifier)\n    #     - get_info() -> returns formatted info string\n    #     - __str__ -> returns name and role\n    #\n    # Subclass: Student(Person)\n    #     - house (string, e.g., \"{{house}}\")\n    #     - year (integer, 1-7)\n    #     - grades (dict: subject -> grade)\n    #     - add_grade(subject, grade)\n    #     - get_average() -> average of all grades\n    #     - promote() -> increment year (max 7)\n    #     - Override get_info() to include house and year\n    #\n    # Subclass: Teacher(Person)\n    #     - subject (string, what they teach)\n    #     - years_experience (integer)\n    #     - students (list of Student objects they teach)\n    #     - add_student(student)\n    #     - grade_student(student, grade)\n    #     - get_class_average() -> average of all students' grades in subject\n    #     - Override get_info() to include subject\n    #\n    # Test:\n    #     student = Student(\"{{hero}}\", 11, \"S001\", \"{{house}}\", 1)\n    #     teacher = Teacher(\"{{mentor}}\", 45, \"T001\", \"{{spell1}}\", 20)\n    #     teacher.add_student(student)\n    #     teacher.grade_student(student, 95)\n    #     print(student.get_info())\n    #     print(teacher.get_info())\n\n    pass\n\n\n# ============================================================\n# PART 2: Growth - Implement Course Management\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n#\n# Create classes to manage courses and enrollment.\n\n\ndef part2_course_management():\n    # ✏️ IMPLEMENT COURSE MANAGEMENT ✏️\n    #\n    # class Course:\n    #     \"\"\"A course offered at {{school}}.\"\"\"\n    #\n    #     def __init__(self, name, teacher, max_students=30):\n    #         self.name = name\n    #         self.teacher = teacher  # Teacher object\n    #         self.max_students = max_students\n    #         self.enrolled_students = []  # List of Student objects\n    #         self.schedule = {}  # day -> time\n    #\n    #     def enroll_student(self, student):\n    #         \"\"\"Add student if not full and not already enrolled.\"\"\"\n    #         # Return True if enrolled, False otherwise\n    #         pass\n    #\n    #     def drop_student(self, student):\n    #         \"\"\"Remove student from course.\"\"\"\n    #         pass\n    #\n    #     def set_schedule(self, day, time):\n    #         \"\"\"Set when the course meets.\"\"\"\n    #         pass\n    #\n    #     def get_roster(self):\n    #         \"\"\"Return list of enrolled student names.\"\"\"\n    #         pass\n    #\n    #     def is_full(self):\n    #         \"\"\"Check if course is at capacity.\"\"\"\n    #         pass\n    #\n    #     def __str__(self):\n    #         \"\"\"Return course summary.\"\"\"\n    #         pass\n    #\n    # Test:\n    #     teacher = Teacher(\"{{mentor}}\", 45, \"T001\", \"{{spell1}}\", 20)\n    #     course = Course(\"{{spell1}} 101\", teacher, max_students=5)\n    #     student1 = Student(\"{{hero}}\", 11, \"S001\", \"{{house}}\", 1)\n    #     student2 = Student(\"{{heroine}}\", 11, \"S002\", \"{{house}}\", 1)\n    #     course.enroll_student(student1)\n    #     course.enroll_student(student2)\n    #     print(course)\n    #     print(f\"Roster: {course.get_roster()}\")\n\n    pass\n\n\n# ============================================================\n# PART 3: Growth - Add Inheritance for Specialization\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n#\n# Create specialized subclasses for different types of people and courses.\n\n\ndef part3_specialization():\n    # ✏️ ADD SPECIALIZED SUBCLASSES ✏️\n    #\n    # class Prefect(Student):\n    #     \"\"\"A student with leadership responsibilities.\"\"\"\n    #\n    #     def __init__(self, name, age, id_number, house, year):\n    #         super().__init__(name, age, id_number, house, year)\n    #         self.duties = []  # List of duty assignments\n    #         self.points_awarded = 0  # Points given to house\n    #\n    #     def assign_duty(self, duty):\n    #         \"\"\"Add a duty to the prefect's responsibilities.\"\"\"\n    #         pass\n    #\n    #     def award_points(self, amount, reason):\n    #         \"\"\"Award points to house. Track total awarded.\"\"\"\n    #         # Print: \"[name] awards [amount] points to [house]: [reason]\"\n    #         pass\n    #\n    #     def get_info(self):\n    #         \"\"\"Override to include prefect status.\"\"\"\n    #         pass\n    #\n    # class HeadTeacher(Teacher):\n    #     \"\"\"A teacher who heads a department.\"\"\"\n    #\n    #     def __init__(self, name, age, id_number, subject, years_experience, department):\n    #         super().__init__(name, age, id_number, subject, years_experience)\n    #         self.department = department\n    #         self.department_teachers = []\n    #\n    #     def add_department_teacher(self, teacher):\n    #         \"\"\"Add a teacher to the department.\"\"\"\n    #         pass\n    #\n    #     def get_department_stats(self):\n    #         \"\"\"Return department summary.\"\"\"\n    #         pass\n    #\n    # class AdvancedCourse(Course):\n    #     \"\"\"A course with prerequisites.\"\"\"\n    #\n    #     def __init__(self, name, teacher, max_students, prerequisites):\n    #         super().__init__(name, teacher, max_students)\n    #         self.prerequisites = prerequisites  # List of course names\n    #\n    #     def check_prerequisites(self, student):\n    #         \"\"\"Check if student has completed all prerequisites.\"\"\"\n    #         # Assume student has completed_courses list\n    #         pass\n    #\n    #     def enroll_student(self, student):\n    #         \"\"\"Override to check prerequisites first.\"\"\"\n    #         pass\n    #\n    # Test:\n    #     prefect = Prefect(\"{{hero}}\", 16, \"S001\", \"{{house}}\", 5)\n    #     prefect.assign_duty(\"Night patrol\")\n    #     prefect.award_points(10, \"Helping first years\")\n    #     print(prefect.get_info())\n\n    pass\n\n\n# ============================================================\n# PART 4: Improvement - Ensure Code Quality\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n#\n# Review and improve the code for production quality.\n\n\ndef part4_code_quality():\n    # ✏️ CODE QUALITY REVIEW ✏️\n    #\n    # Review your classes and ensure:\n    #\n    # 1. NAMING:\n    #    - All class names are PascalCase\n    #    - All methods and attributes are snake_case\n    #    - Names are descriptive and clear\n    #\n    # 2. DOCUMENTATION:\n    #    - Every class has a docstring explaining its purpose\n    #    - Every method has a docstring with Args and Returns\n    #    - Complex logic has inline comments\n    #\n    # 3. ENCAPSULATION:\n    #    - Data is accessed/modified through methods when appropriate\n    #    - Invalid operations are handled gracefully\n    #    - Methods validate their inputs\n    #\n    # 4. ERROR HANDLING:\n    #    - What happens if you try to enroll in a full course?\n    #    - What if you try to grade a student not in your class?\n    #    - What if you promote a 7th year student?\n    #\n    # Add input validation and error handling to your classes.\n    #\n    # Example improvements:\n    #\n    # def enroll_student(self, student):\n    #     \"\"\"Enroll a student in this course.\n    #\n    #     Args:\n    #         student: Student object to enroll\n    #\n    #     Returns:\n    #         bool: True if enrolled successfully\n    #\n    #     Raises:\n    #         ValueError: If student is None or already enrolled\n    #     \"\"\"\n    #     if student is None:\n    #         raise ValueError(\"Cannot enroll None as student\")\n    #     if student in self.enrolled_students:\n    #         return False  # Already enrolled\n    #     if self.is_full():\n    #         return False  # Course full\n    #     self.enrolled_students.append(student)\n    #     return True\n\n    pass\n\n\n# ============================================================\n# PART 5: Ownership - Extend With Your Own Feature\n# ============================================================\n# {{CONTEXT_MASTERY_INTRO}}\n# {{CONTEXT_MASTERY_NARRATIVE}}\n#\n# Add your own feature to the management system.\n\n\ndef part5_extend_system():\n    # ✏️ EXTEND THE SYSTEM ✏️\n    #\n    # Add a significant feature of your choice. Ideas:\n    #\n    # 1. House Points System:\n    #    - Track points for each house\n    #    - Teachers and prefects can award/deduct points\n    #    - Get current standings\n    #\n    # 2. Event System:\n    #    - Create events (quidditch match, feast, exam)\n    #    - Students/teachers can attend\n    #    - Track participation\n    #\n    # 3. Grading System Enhancement:\n    #    - Track grades over time\n    #    - Calculate GPA\n    #    - Generate report cards\n    #\n    # 4. Scheduling System:\n    #    - Detect schedule conflicts\n    #    - Generate student timetables\n    #    - Room booking\n    #\n    # 5. Library System:\n    #    - Books that can be borrowed\n    #    - Due dates and late fees\n    #    - Reserved section for advanced students\n    #\n    # Requirements for your feature:\n    # - At least 1 new class\n    # - Must interact with existing classes (Person, Course, etc.)\n    # - Include comprehensive testing\n    # - Document your design decisions\n    #\n    # Demonstrate your feature in action:\n\n    pass\n\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"{{school}} Management System - Capstone Project\")\n    print(\"=\" * 60)\n    print()\n\n    print(\">>> PART 1: Core Class Hierarchy\")\n    print(\"(Design Person, Student, Teacher)\")\n    part1_core_classes()\n    print()\n\n    print(\">>> PART 2: Course Management\")\n    print(\"(Implement enrollment and scheduling)\")\n    part2_course_management()\n    print()\n\n    print(\">>> PART 3: Specialization\")\n    print(\"(Add Prefect, HeadTeacher, AdvancedCourse)\")\n    part3_specialization()\n    print()\n\n    print(\">>> PART 4: Code Quality\")\n    print(\"(Add validation, error handling, documentation)\")\n    part4_code_quality()\n    print()\n\n    print(\">>> PART 5: Your Feature\")\n    print(\"(Extend the system with your own idea)\")\n    part5_extend_system()\n\n    print()\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n    print(\"Congratulations on completing the OOP module!\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "hybrid"
      ],
      "source_file": "module_9_oop/hybrid/exercise_8_school_management.py"
    },
    {
      "id": "module_9_oop.which_is_better.exercise_1_class_design",
      "topic_id": "oop.classes",
      "exercise_type": "which_is_better",
      "category": "analysis",
      "title": "Class Design",
      "title_en": "Class Design",
      "title_he": "Class Design",
      "description_en": "Object-Oriented Programming: Class Design\n\n{{CONTEXT_COMPARISON_INTRO}}\n{{CONTEXT_COMPARISON_DECISION}}\n\nIn this exercise, you'll analyze different class design approaches.\nBoth versions work correctly, but they have different trade-offs.\nEvaluate which is better for different situations.",
      "description_he": "תכנות מונחה עצמים: Class Design\n\n{{CONTEXT_COMPARISON_INTRO}}\n{{CONTEXT_COMPARISON_DECISION}}\n\nIn this exercise, you'll analyze different class design approaches.\nBoth versions work correctly, but they have different trade-offs.\nEvaluate which is better for different situations.",
      "difficulty": 3,
      "requires_running": false,
      "estimated_time_minutes": 10,
      "skills": [
        "critical_thinking",
        "trade_offs",
        "code_judgment"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_COMPARISON_INTRO}}\n{{CONTEXT_COMPARISON_DECISION}}\n\nIn this exercise, you'll analyze different class design approaches.\nBoth versions work correctly, but they have different trade-offs.\nEvaluate which is better for different situations.\n\"\"\"\n\n\n# ============================================================\n# {{APPROACH_1_NAME}}\n# ============================================================\n# {{CONTEXT_APPROACH_1_NARRATIVE}}\n\n# Design A: One class does everything\n\n\nclass CharacterAllInOneA:\n    \"\"\"Single class with all functionality built in.\"\"\"\n\n    def __init__(self, name, health, mana, strength, magic):\n        self.name = name\n        self.health = health\n        self.max_health = health\n        self.mana = mana\n        self.max_mana = mana\n        self.strength = strength\n        self.magic = magic\n\n    def physical_attack(self, target):\n        damage = self.strength\n        target.health -= damage\n        return damage\n\n    def magic_attack(self, target):\n        if self.mana >= 10:\n            self.mana -= 10\n            damage = self.magic\n            target.health -= damage\n            return damage\n        return 0\n\n    def heal_self(self):\n        if self.mana >= 15:\n            self.mana -= 15\n            heal = self.magic // 2\n            self.health = min(self.max_health, self.health + heal)\n            return heal\n        return 0\n\n\n# ============================================================\n# {{APPROACH_2_NAME}}\n# ============================================================\n# {{CONTEXT_APPROACH_2_NARRATIVE}}\n\n# Design B: Specialized classes through inheritance\n\n\nclass CharacterBaseB:\n    \"\"\"Base class with common functionality.\"\"\"\n\n    def __init__(self, name, health):\n        self.name = name\n        self.health = health\n        self.max_health = health\n\n\nclass WarriorB(CharacterBaseB):\n    \"\"\"Specialized for physical combat.\"\"\"\n\n    def __init__(self, name, health, strength):\n        super().__init__(name, health)\n        self.strength = strength\n\n    def physical_attack(self, target):\n        damage = self.strength\n        target.health -= damage\n        return damage\n\n\nclass MageB(CharacterBaseB):\n    \"\"\"Specialized for magic.\"\"\"\n\n    def __init__(self, name, health, mana, magic):\n        super().__init__(name, health)\n        self.mana = mana\n        self.max_mana = mana\n        self.magic = magic\n\n    def magic_attack(self, target):\n        if self.mana >= 10:\n            self.mana -= 10\n            damage = self.magic\n            target.health -= damage\n            return damage\n        return 0\n\n    def heal_self(self):\n        if self.mana >= 15:\n            self.mana -= 15\n            heal = self.magic // 2\n            self.health = min(self.max_health, self.health + heal)\n            return heal\n        return 0\n\n\ndef analysis_1():\n    # ✏️ YOUR ANALYSIS ✏️\n    #\n    # {{CONTEXT_ANALYSIS_PROMPT}}\n    # Consider: {{CONTEXT_DECISION_GUIDANCE}}\n\n    analysis = \"\"\"\n    Better design: ??? (A: All-in-one OR B: Specialized classes)\n\n    Advantages of Design A (All-in-one):\n    1.\n    2.\n\n    Advantages of Design B (Specialized):\n    1.\n    2.\n\n    Design A is better when:\n    -\n\n    Design B is better when:\n    -\n\n    If I needed to add a new character type (Paladin with both\n    strength AND magic), which would be easier to extend?\n    -\n    \"\"\"\n    return analysis\n\n\n# ============================================================\n# COMPARISON 2: ATTRIBUTE STORAGE\n# ============================================================\n\n\n# Design C: Direct attributes\n\n\nclass InventoryDirectC:\n    \"\"\"Stores items as a simple list.\"\"\"\n\n    def __init__(self, owner):\n        self.owner = owner\n        self.item_names = []\n        self.item_counts = []\n\n    def add_item(self, name, count=1):\n        if name in self.item_names:\n            index = self.item_names.index(name)\n            self.item_counts[index] += count\n        else:\n            self.item_names.append(name)\n            self.item_counts.append(count)\n\n    def get_count(self, name):\n        if name in self.item_names:\n            index = self.item_names.index(name)\n            return self.item_counts[index]\n        return 0\n\n\n# Design D: Using a dictionary\n\n\nclass InventoryDictD:\n    \"\"\"Stores items in a dictionary.\"\"\"\n\n    def __init__(self, owner):\n        self.owner = owner\n        self.items = {}  # name -> count\n\n    def add_item(self, name, count=1):\n        self.items[name] = self.items.get(name, 0) + count\n\n    def get_count(self, name):\n        return self.items.get(name, 0)\n\n\ndef analysis_2():\n    # ✏️ YOUR ANALYSIS ✏️\n    #\n    # Both designs store the same data. Which is better?\n\n    analysis = \"\"\"\n    Better design: ??? (C: Parallel lists OR D: Dictionary)\n\n    Why Design C is problematic:\n    1.\n    2.\n\n    Why Design D is better:\n    1.\n    2.\n\n    The main lesson here is:\n    -\n    \"\"\"\n    return analysis\n\n\n# ============================================================\n# COMPARISON 3: METHOD PLACEMENT\n# ============================================================\n\n\n# Design E: Methods that operate ON the object\n\n\nclass BattleCharacterE:\n    \"\"\"Character with methods that modify self.\"\"\"\n\n    def __init__(self, name, health, power):\n        self.name = name\n        self.health = health\n        self.power = power\n\n    def attack(self, target):\n        \"\"\"This character attacks the target.\"\"\"\n        target.health -= self.power\n\n    def take_damage(self, amount):\n        \"\"\"This character takes damage.\"\"\"\n        self.health -= amount\n\n\n# Design F: External functions\n\n\nclass BattleCharacterF:\n    \"\"\"Character as pure data container.\"\"\"\n\n    def __init__(self, name, health, power):\n        self.name = name\n        self.health = health\n        self.power = power\n\n\ndef attack_f(attacker, target):\n    \"\"\"External function to handle attack.\"\"\"\n    target.health -= attacker.power\n\n\ndef take_damage_f(character, amount):\n    \"\"\"External function to handle damage.\"\"\"\n    character.health -= amount\n\n\ndef analysis_3():\n    # ✏️ YOUR ANALYSIS ✏️\n    #\n    # Same functionality, but methods are inside vs outside the class.\n\n    analysis = \"\"\"\n    Better design: ??? (E: Methods inside OR F: Functions outside)\n\n    Why OOP (Design E) is typically preferred:\n    1.\n    2.\n\n    When external functions (Design F) might be appropriate:\n    1.\n    2.\n\n    The principle this illustrates (hint: encapsulation):\n    -\n    \"\"\"\n    return analysis\n\n\ndef main():\n    print(\"{{CONTEXT_COMPARISON_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== Comparison 1: All-in-One vs Specialized ===\")\n    print()\n\n    # Both designs work\n    char_a = CharacterAllInOneA(\"{{hero}}\", 100, 50, 20, 30)\n    warrior_b = WarriorB(\"{{hero}}\", 100, 20)\n\n    dummy = CharacterAllInOneA(\"Dummy\", 100, 0, 0, 0)\n    print(f\"Design A - Physical attack: {char_a.physical_attack(dummy)}\")\n\n    dummy2 = CharacterBaseB(\"Dummy\", 100)\n    print(f\"Design B - Physical attack: {warrior_b.physical_attack(dummy2)}\")\n\n    print(f\"\\nYour analysis:{analysis_1()}\")\n\n    print(\"\\n=== Comparison 2: Parallel Lists vs Dictionary ===\")\n    print()\n\n    inv_c = InventoryDirectC(\"{{hero}}\")\n    inv_c.add_item(\"{{item}}\", 3)\n    inv_c.add_item(\"{{spell1}}\", 1)\n    print(f\"Design C - {{{{item}}}} count: {inv_c.get_count('{{item}}')}\")\n\n    inv_d = InventoryDictD(\"{{hero}}\")\n    inv_d.add_item(\"{{item}}\", 3)\n    inv_d.add_item(\"{{spell1}}\", 1)\n    print(f\"Design D - {{{{item}}}} count: {inv_d.get_count('{{item}}')}\")\n\n    print(f\"\\nYour analysis:{analysis_2()}\")\n\n    print(\"\\n=== Comparison 3: Methods Inside vs Outside ===\")\n    print()\n    print(f\"Your analysis:{analysis_3()}\")\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"{{CONTEXT_EVALUATION_COMPLETE}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "which_is_better"
      ],
      "source_file": "module_9_oop/which_is_better/exercise_1_class_design.py"
    },
    {
      "id": "module_9_oop.which_is_better.exercise_2_oop_vs_procedural",
      "topic_id": "oop.classes",
      "exercise_type": "which_is_better",
      "category": "analysis",
      "title": "Oop Vs Procedural",
      "title_en": "Oop Vs Procedural",
      "title_he": "Oop Vs Procedural",
      "description_en": "Object-Oriented Programming: Oop Vs Procedural\n\n{{CONTEXT_COMPARISON_INTRO}}\n{{CONTEXT_COMPARISON_DECISION}}\n\nThe great debate: When should you use classes vs dictionaries and functions?\nBoth approaches can solve the same problems, but each has trade-offs.",
      "description_he": "תכנות מונחה עצמים: Oop Vs Procedural\n\n{{CONTEXT_COMPARISON_INTRO}}\n{{CONTEXT_COMPARISON_DECISION}}\n\nThe great debate: When should you use classes vs dictionaries and functions?\nBoth approaches can solve the same problems, but each has trade-offs.",
      "difficulty": 3,
      "requires_running": false,
      "estimated_time_minutes": 10,
      "skills": [
        "critical_thinking",
        "trade_offs",
        "code_judgment"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_COMPARISON_INTRO}}\n{{CONTEXT_COMPARISON_DECISION}}\n\nThe great debate: When should you use classes vs dictionaries and functions?\nBoth approaches can solve the same problems, but each has trade-offs.\n\"\"\"\n\n\n# ============================================================\n# {{APPROACH_1_NAME}}\n# ============================================================\n# {{CONTEXT_APPROACH_1_NARRATIVE}}\n\n# Procedural approach using dictionaries and functions\n\n\ndef create_character_proc(name, health, power):\n    \"\"\"Create a character as a dictionary.\"\"\"\n    return {\n        \"name\": name,\n        \"health\": health,\n        \"max_health\": health,\n        \"power\": power\n    }\n\n\ndef take_damage_proc(character, amount):\n    \"\"\"Apply damage to a character dictionary.\"\"\"\n    character[\"health\"] = max(0, character[\"health\"] - amount)\n    return character[\"health\"]\n\n\ndef heal_proc(character, amount):\n    \"\"\"Heal a character dictionary.\"\"\"\n    max_h = character[\"max_health\"]\n    character[\"health\"] = min(max_h, character[\"health\"] + amount)\n    return character[\"health\"]\n\n\ndef is_alive_proc(character):\n    \"\"\"Check if character is alive.\"\"\"\n    return character[\"health\"] > 0\n\n\ndef get_status_proc(character):\n    \"\"\"Get character status string.\"\"\"\n    return f\"{character['name']}: {character['health']}/{character['max_health']} HP\"\n\n\n# ============================================================\n# {{APPROACH_2_NAME}}\n# ============================================================\n# {{CONTEXT_APPROACH_2_NARRATIVE}}\n\n# Object-Oriented approach using a class\n\n\nclass CharacterOOP:\n    \"\"\"A character represented as an object.\"\"\"\n\n    def __init__(self, name, health, power):\n        self.name = name\n        self.health = health\n        self.max_health = health\n        self.power = power\n\n    def take_damage(self, amount):\n        \"\"\"Apply damage to this character.\"\"\"\n        self.health = max(0, self.health - amount)\n        return self.health\n\n    def heal(self, amount):\n        \"\"\"Heal this character.\"\"\"\n        self.health = min(self.max_health, self.health + amount)\n        return self.health\n\n    def is_alive(self):\n        \"\"\"Check if this character is alive.\"\"\"\n        return self.health > 0\n\n    def get_status(self):\n        \"\"\"Get status string.\"\"\"\n        return f\"{self.name}: {self.health}/{self.max_health} HP\"\n\n\ndef comparison_1():\n    # ✏️ YOUR ANALYSIS ✏️\n    #\n    # {{CONTEXT_ANALYSIS_PROMPT}}\n\n    analysis = \"\"\"\n    For a SIMPLE character system (just name, health, basic actions):\n\n    Better approach: ??? (Procedural OR OOP)\n\n    Reasons:\n    1.\n    2.\n\n    Lines of code comparison:\n    - Procedural:\n    - OOP:\n\n    Which is easier to read?\n    -\n    \"\"\"\n    return analysis\n\n\n# ============================================================\n# COMPARISON 2: COMPLEX DATA\n# ============================================================\n\n# Procedural approach for inventory\n\n\ndef create_inventory_proc(owner, capacity):\n    \"\"\"Create an inventory as a dictionary.\"\"\"\n    return {\n        \"owner\": owner,\n        \"capacity\": capacity,\n        \"items\": {},\n        \"gold\": 0\n    }\n\n\ndef add_item_proc(inventory, item_name, count=1):\n    \"\"\"Add item to inventory.\"\"\"\n    current = inventory[\"items\"].get(item_name, 0)\n    total_items = sum(inventory[\"items\"].values())\n    if total_items + count <= inventory[\"capacity\"]:\n        inventory[\"items\"][item_name] = current + count\n        return True\n    return False\n\n\ndef remove_item_proc(inventory, item_name, count=1):\n    \"\"\"Remove item from inventory.\"\"\"\n    current = inventory[\"items\"].get(item_name, 0)\n    if current >= count:\n        inventory[\"items\"][item_name] = current - count\n        if inventory[\"items\"][item_name] == 0:\n            del inventory[\"items\"][item_name]\n        return True\n    return False\n\n\ndef add_gold_proc(inventory, amount):\n    \"\"\"Add gold to inventory.\"\"\"\n    inventory[\"gold\"] += amount\n\n\ndef get_inventory_str_proc(inventory):\n    \"\"\"Get inventory as string.\"\"\"\n    items_str = \", \".join(f\"{k}: {v}\" for k, v in inventory[\"items\"].items())\n    return f\"{inventory['owner']}'s inventory ({items_str}) - {inventory['gold']} gold\"\n\n\n# OOP approach for inventory\n\n\nclass InventoryOOP:\n    \"\"\"An inventory represented as an object.\"\"\"\n\n    def __init__(self, owner, capacity):\n        self.owner = owner\n        self.capacity = capacity\n        self.items = {}\n        self.gold = 0\n\n    def add_item(self, item_name, count=1):\n        \"\"\"Add item to inventory.\"\"\"\n        current = self.items.get(item_name, 0)\n        total_items = sum(self.items.values())\n        if total_items + count <= self.capacity:\n            self.items[item_name] = current + count\n            return True\n        return False\n\n    def remove_item(self, item_name, count=1):\n        \"\"\"Remove item from inventory.\"\"\"\n        current = self.items.get(item_name, 0)\n        if current >= count:\n            self.items[item_name] = current - count\n            if self.items[item_name] == 0:\n                del self.items[item_name]\n            return True\n        return False\n\n    def add_gold(self, amount):\n        \"\"\"Add gold to inventory.\"\"\"\n        self.gold += amount\n\n    def __str__(self):\n        items_str = \", \".join(f\"{k}: {v}\" for k, v in self.items.items())\n        return f\"{self.owner}'s inventory ({items_str}) - {self.gold} gold\"\n\n\ndef comparison_2():\n    # ✏️ YOUR ANALYSIS ✏️\n\n    analysis = \"\"\"\n    For a MORE COMPLEX system (inventory with multiple operations):\n\n    Better approach: ??? (Procedural OR OOP)\n\n    Key differences:\n    1. In procedural, you must pass 'inventory' to every function\n    2. In OOP, methods know which inventory they belong to (self)\n\n    Which is easier to extend with new features?\n    -\n\n    Which is harder to make mistakes with (e.g., passing wrong data)?\n    -\n\n    What if we had 10 different functions/methods? Which scales better?\n    -\n    \"\"\"\n    return analysis\n\n\n# ============================================================\n# COMPARISON 3: TYPE CHECKING AND SAFETY\n# ============================================================\n\n\ndef comparison_3():\n    # ✏️ YOUR ANALYSIS ✏️\n    #\n    # Consider this procedural code:\n    #     char = create_character_proc(\"{{hero}}\", 100, 20)\n    #     inv = create_inventory_proc(\"{{hero}}\", 10)\n    #\n    #     # Oops! Wrong function for wrong data\n    #     take_damage_proc(inv, 50)  # This might crash or corrupt data!\n    #\n    # Now consider OOP:\n    #     char = CharacterOOP(\"{{hero}}\", 100, 20)\n    #     inv = InventoryOOP(\"{{hero}}\", 10)\n    #\n    #     # Can't accidentally call wrong method\n    #     # inv.take_damage(50)  # Error: InventoryOOP has no take_damage\n\n    analysis = \"\"\"\n    Type safety comparison:\n\n    In procedural code, what could go wrong?\n    1.\n    2.\n\n    How does OOP help prevent these errors?\n    1.\n    2.\n\n    This illustrates the OOP benefit of:\n    - (hint: binding data and behavior together)\n    \"\"\"\n    return analysis\n\n\n# ============================================================\n# WHEN TO USE EACH\n# ============================================================\n\n\ndef final_analysis():\n    # ✏️ YOUR FINAL ANALYSIS ✏️\n\n    analysis = \"\"\"\n    Use PROCEDURAL (dictionaries + functions) when:\n    1. Data is simple (few fields, few operations)\n    2. You need quick prototyping\n    3.\n\n    Use OOP (classes) when:\n    1. Data and behavior are closely related\n    2. You have multiple instances with the same operations\n    3.\n\n    General guideline:\n    -\n    \"\"\"\n    return analysis\n\n\ndef main():\n    print(\"{{CONTEXT_COMPARISON_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== Comparison 1: Simple Character ===\")\n    print()\n\n    # Procedural\n    hero_p = create_character_proc(\"{{hero}}\", 100, 20)\n    take_damage_proc(hero_p, 30)\n    print(f\"Procedural: {get_status_proc(hero_p)}\")\n\n    # OOP\n    hero_o = CharacterOOP(\"{{hero}}\", 100, 20)\n    hero_o.take_damage(30)\n    print(f\"OOP: {hero_o.get_status()}\")\n\n    print(f\"\\nYour analysis:{comparison_1()}\")\n\n    print(\"\\n=== Comparison 2: Complex Inventory ===\")\n    print()\n\n    # Procedural\n    inv_p = create_inventory_proc(\"{{hero}}\", 10)\n    add_item_proc(inv_p, \"{{item}}\", 3)\n    add_gold_proc(inv_p, 50)\n    print(f\"Procedural: {get_inventory_str_proc(inv_p)}\")\n\n    # OOP\n    inv_o = InventoryOOP(\"{{hero}}\", 10)\n    inv_o.add_item(\"{{item}}\", 3)\n    inv_o.add_gold(50)\n    print(f\"OOP: {inv_o}\")\n\n    print(f\"\\nYour analysis:{comparison_2()}\")\n\n    print(\"\\n=== Comparison 3: Type Safety ===\")\n    print(f\"\\nYour analysis:{comparison_3()}\")\n\n    print(\"\\n=== When to Use Each ===\")\n    print(f\"\\nYour analysis:{final_analysis()}\")\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"{{CONTEXT_EVALUATION_COMPLETE}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "which_is_better"
      ],
      "source_file": "module_9_oop/which_is_better/exercise_2_oop_vs_procedural.py"
    },
    {
      "id": "module_9_oop.write_code.exercise_1_first_class",
      "topic_id": "oop.classes",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "First Class",
      "title_en": "First Class",
      "title_he": "First Class",
      "description_en": "Object-Oriented Programming: First Class\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn the fundamentals of classes:\ndefining a class, writing the __init__ method, and using self\nto create instance attributes.",
      "description_he": "תכנות מונחה עצמים: First Class\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn the fundamentals of classes:\ndefining a class, writing the __init__ method, and using self\nto create instance attributes.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn the fundamentals of classes:\ndefining a class, writing the __init__ method, and using self\nto create instance attributes.\n\"\"\"\n\n\n# ============================================================\n# {{PHASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n\n\ndef exercise_a():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create your first class to represent a character at {{school}}.\n    #\n    # Step 1: Define a class called `Character` using:\n    #         class Character:\n    #\n    # Step 2: Inside the class, define the __init__ method:\n    #         def __init__(self, name, level):\n    #\n    # Step 3: In __init__, store the parameters as instance attributes:\n    #         self.name = name\n    #         self.level = level\n    #\n    # Step 4: Create an instance of Character for {{hero}}:\n    #         hero = Character(\"{{hero}}\", 1)\n    #\n    # Step 5: Print the hero's name and level using dot notation:\n    #         print(f\"Name: {hero.name}, Level: {hero.level}\")\n    #\n    # Hint: The class keyword starts a class definition, like def starts\n    #       a function. self refers to the specific object being created.\n    pass\n\n\n# ============================================================\n# {{PHASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n\n\ndef exercise_b():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create a class with more attributes.\n    #\n    # Step 1: Define a class called `Item` with __init__ that takes:\n    #         - self (always first!)\n    #         - name (the item's name)\n    #         - power (integer for power rating)\n    #         - rarity (string like \"common\" or \"rare\")\n    #\n    # Step 2: Store all three as instance attributes using self\n    #\n    # Step 3: Create two instances:\n    #         item1 = Item(\"{{item}}\", 50, \"uncommon\")\n    #         item2 = Item(\"{{spell1}}\", 25, \"common\")\n    #\n    # Step 4: Print both items' attributes:\n    #         \"[name] - Power: [power], Rarity: [rarity]\"\n    #\n    # Note: Each instance has its own separate values!\n    pass\n\n\n# ============================================================\n# {{PHASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n\n\ndef exercise_c():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create a class with default parameter values.\n    #\n    # Step 1: Define a class called `Student` with __init__ that takes:\n    #         - self\n    #         - name\n    #         - house (default: \"{{house}}\")\n    #         - year (default: 1)\n    #\n    # Step 2: Store all as instance attributes\n    #\n    # Step 3: Create three students:\n    #         student1 = Student(\"{{hero}}\")  # Uses defaults\n    #         student2 = Student(\"{{heroine}}\", \"{{house}}\", 2)\n    #         student3 = Student(\"{{friend}}\", year=3)  # Named argument\n    #\n    # Step 4: Print each student's info:\n    #         \"[name] is in [house], year [year]\"\n    #\n    # Hint: Default parameters work the same way as in regular functions!\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{PHASE_1_TITLE}} ===\")\n    exercise_a()\n\n    print(\"\\n=== {{PHASE_2_TITLE}} ===\")\n    exercise_b()\n\n    print(\"\\n=== {{PHASE_3_TITLE}} ===\")\n    exercise_c()\n\n    print(\"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "write_code"
      ],
      "source_file": "module_9_oop/write_code/exercise_1_first_class.py"
    },
    {
      "id": "module_9_oop.write_code.exercise_2_methods",
      "topic_id": "oop.classes",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Methods",
      "title_en": "Methods",
      "title_he": "Methods",
      "description_en": "Object-Oriented Programming: Methods\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn to write instance methods - functions\ninside classes that can read and modify the object's attributes using self.",
      "description_he": "תכנות מונחה עצמים: Methods\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn to write instance methods - functions\ninside classes that can read and modify the object's attributes using self.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn to write instance methods - functions\ninside classes that can read and modify the object's attributes using self.\n\"\"\"\n\n\n# ============================================================\n# {{PHASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n\n\ndef exercise_a():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create a class with methods that READ attributes.\n    #\n    # Step 1: Define a class called `Character` with __init__ that takes:\n    #         - self, name, health, max_health\n    #         Store all as instance attributes.\n    #\n    # Step 2: Add a method called `get_status`:\n    #         def get_status(self):\n    #         It should return a string: \"[name]: [health]/[max_health] HP\"\n    #\n    # Step 3: Add a method called `is_healthy`:\n    #         def is_healthy(self):\n    #         It should return True if health > max_health / 2, else False\n    #\n    # Step 4: Create a character and test the methods:\n    #         hero = Character(\"{{hero}}\", 75, 100)\n    #         print(hero.get_status())  # Should print status\n    #         print(hero.is_healthy())  # Should print True\n    #\n    # Remember: Methods always have self as the first parameter!\n    pass\n\n\n# ============================================================\n# {{PHASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n\n\ndef exercise_b():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create a class with methods that MODIFY attributes.\n    #\n    # Step 1: Define a class called `Counter` with __init__ that takes:\n    #         - self, name, start_value=0\n    #         Store as self.name and self.value\n    #\n    # Step 2: Add a method `increment` that increases value by 1:\n    #         def increment(self):\n    #             self.value += 1\n    #\n    # Step 3: Add a method `add` that takes an amount parameter:\n    #         def add(self, amount):\n    #         It should add the amount to self.value\n    #\n    # Step 4: Add a method `reset` that sets value back to 0\n    #\n    # Step 5: Test your counter:\n    #         counter = Counter(\"{{spell1}} uses\")\n    #         counter.increment()\n    #         counter.add(5)\n    #         print(f\"{counter.name}: {counter.value}\")  # Should be 6\n    #         counter.reset()\n    #         print(f\"After reset: {counter.value}\")  # Should be 0\n    pass\n\n\n# ============================================================\n# {{PHASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n\n\ndef exercise_c():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create a class where methods return values AND modify state.\n    #\n    # Step 1: Define a class called `Wallet` with __init__ that takes:\n    #         - self, owner, initial_gold=0\n    #         Store as self.owner and self.gold\n    #\n    # Step 2: Add a method `deposit` that takes an amount:\n    #         - Add amount to self.gold\n    #         - Return the new total\n    #\n    # Step 3: Add a method `withdraw` that takes an amount:\n    #         - If amount > self.gold, print \"Not enough gold!\" and return 0\n    #         - Otherwise, subtract amount from self.gold and return amount\n    #\n    # Step 4: Add a method `check_balance` that returns self.gold\n    #\n    # Step 5: Test the wallet:\n    #         wallet = Wallet(\"{{hero}}\", 50)\n    #         print(f\"Deposited, new balance: {wallet.deposit(30)}\")  # 80\n    #         print(f\"Withdrew: {wallet.withdraw(20)}\")  # 20\n    #         print(f\"Balance: {wallet.check_balance()}\")  # 60\n    #         wallet.withdraw(100)  # Should print \"Not enough gold!\"\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{PHASE_1_TITLE}} ===\")\n    exercise_a()\n\n    print(\"\\n=== {{PHASE_2_TITLE}} ===\")\n    exercise_b()\n\n    print(\"\\n=== {{PHASE_3_TITLE}} ===\")\n    exercise_c()\n\n    print(\"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "write_code"
      ],
      "source_file": "module_9_oop/write_code/exercise_2_methods.py"
    },
    {
      "id": "module_9_oop.write_code.exercise_3_str_method",
      "topic_id": "oop.classes",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Str Method",
      "title_en": "Str Method",
      "title_he": "Str Method",
      "description_en": "Object-Oriented Programming: Str Method\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn to implement __str__ - a special method\nthat defines how your objects are displayed when printed or converted\nto strings. This makes debugging and displaying information much easier.",
      "description_he": "תכנות מונחה עצמים: Str Method\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn to implement __str__ - a special method\nthat defines how your objects are displayed when printed or converted\nto strings. This makes debugging and displaying information much easier.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn to implement __str__ - a special method\nthat defines how your objects are displayed when printed or converted\nto strings. This makes debugging and displaying information much easier.\n\"\"\"\n\n\n# ============================================================\n# {{PHASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n\n\ndef exercise_a():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create a class with a __str__ method.\n    #\n    # Step 1: Define a class called `Item` with __init__ that takes:\n    #         - self, name, value\n    #         Store both as instance attributes.\n    #\n    # Step 2: Define the __str__ method:\n    #         def __str__(self):\n    #             return f\"[some formatted string]\"\n    #\n    #         Return a string like: \"Item: [name] (worth [value] gold)\"\n    #\n    # Step 3: Create an item and test __str__:\n    #         item = Item(\"{{item}}\", 100)\n    #         print(item)  # This automatically calls __str__!\n    #\n    # Note: Without __str__, print(item) would show something like:\n    #       <__main__.Item object at 0x...>\n    pass\n\n\n# ============================================================\n# {{PHASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n\n\ndef exercise_b():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create a class with a more complex __str__ that shows state.\n    #\n    # Step 1: Define a class called `Character` with __init__ that takes:\n    #         - self, name, health, max_health, level\n    #         Store all as instance attributes.\n    #\n    # Step 2: Define __str__ to show all the character info:\n    #         Format: \"[name] (Lv.[level]) - HP: [health]/[max_health]\"\n    #\n    # Step 3: Create several characters and print them:\n    #         hero = Character(\"{{hero}}\", 75, 100, 5)\n    #         print(hero)  # Should show formatted info\n    #\n    #         friend = Character(\"{{friend}}\", 50, 80, 3)\n    #         print(friend)\n    #\n    # Step 4: Modify the hero's health and print again:\n    #         hero.health = 100\n    #         print(hero)  # __str__ shows current state!\n    pass\n\n\n# ============================================================\n# {{PHASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n\n\ndef exercise_c():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create a class that uses __str__ to display a list of items.\n    #\n    # Step 1: Define a class called `Inventory` with __init__ that takes:\n    #         - self, owner\n    #         Set self.owner = owner\n    #         Set self.items = []  (empty list)\n    #\n    # Step 2: Add an `add_item` method that appends to self.items\n    #\n    # Step 3: Define __str__ to display the inventory contents:\n    #         If empty: \"[owner]'s Inventory: (empty)\"\n    #         If has items: \"[owner]'s Inventory: [item1], [item2], ...\"\n    #\n    #         Hint: Use \", \".join(self.items) to format the list\n    #\n    # Step 4: Test the inventory:\n    #         inv = Inventory(\"{{hero}}\")\n    #         print(inv)  # Should show empty\n    #\n    #         inv.add_item(\"{{item}}\")\n    #         inv.add_item(\"{{spell1}}\")\n    #         print(inv)  # Should show items\n    pass\n\n\n# ============================================================\n# {{PHASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n\n\ndef exercise_d():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create a class where __str__ formats a multi-line display.\n    #\n    # Step 1: Define a class called `ProfileCard` with __init__ that takes:\n    #         - self, name, role, level, skills (list)\n    #         Store all as instance attributes.\n    #\n    # Step 2: Define __str__ to return a multi-line card:\n    #         ┌─────────────────────┐\n    #         │ [name]              │\n    #         │ Role: [role]        │\n    #         │ Level: [level]      │\n    #         │ Skills: [s1], [s2]  │\n    #         └─────────────────────┘\n    #\n    #         Simplified version (without borders) is fine:\n    #         \"[name]\\nRole: [role]\\nLevel: [level]\\nSkills: [s1], [s2]\"\n    #\n    # Step 3: Create a profile card and print it:\n    #         card = ProfileCard(\"{{hero}}\", \"{{ROLE_TITLE}}\", 10,\n    #                           [\"{{spell1}}\", \"{{spell2}}\"])\n    #         print(card)\n    #\n    # Hint: Use \\n for newlines in the return string\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{PHASE_1_TITLE}} ===\")\n    exercise_a()\n\n    print(\"\\n=== {{PHASE_2_TITLE}} ===\")\n    exercise_b()\n\n    print(\"\\n=== {{PHASE_3_TITLE}} ===\")\n    exercise_c()\n\n    print(\"\\n=== {{PHASE_4_TITLE}} ===\")\n    exercise_d()\n\n    print(\"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "write_code"
      ],
      "source_file": "module_9_oop/write_code/exercise_3_str_method.py"
    },
    {
      "id": "module_9_oop.write_code.exercise_4_object_interaction",
      "topic_id": "oop.classes",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Object Interaction",
      "title_en": "Object Interaction",
      "title_he": "Object Interaction",
      "description_en": "Object-Oriented Programming: Object Interaction\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn how objects can interact with each other.\nMethods can take other objects as parameters, allowing objects to\ncommunicate and affect each other's state.",
      "description_he": "תכנות מונחה עצמים: Object Interaction\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn how objects can interact with each other.\nMethods can take other objects as parameters, allowing objects to\ncommunicate and affect each other's state.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn how objects can interact with each other.\nMethods can take other objects as parameters, allowing objects to\ncommunicate and affect each other's state.\n\"\"\"\n\n\n# ============================================================\n# {{PHASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n\n\ndef exercise_a():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create two classes that interact with each other.\n    #\n    # Step 1: Define a class called `Character` with __init__ that takes:\n    #         - self, name, gold=0\n    #         Store as instance attributes.\n    #\n    # Step 2: Add a method `give_gold(self, other, amount)`:\n    #         - other is another Character object\n    #         - If self.gold >= amount:\n    #             Subtract amount from self.gold\n    #             Add amount to other.gold\n    #             Return True\n    #         - Otherwise return False\n    #\n    # Step 3: Test the interaction:\n    #         hero = Character(\"{{hero}}\", 100)\n    #         friend = Character(\"{{friend}}\", 20)\n    #\n    #         print(f\"{hero.name}: {hero.gold} gold\")\n    #         print(f\"{friend.name}: {friend.gold} gold\")\n    #\n    #         hero.give_gold(friend, 30)\n    #\n    #         print(f\"After transfer:\")\n    #         print(f\"{hero.name}: {hero.gold} gold\")\n    #         print(f\"{friend.name}: {friend.gold} gold\")\n    pass\n\n\n# ============================================================\n# {{PHASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n\n\ndef exercise_b():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create objects that affect each other's state.\n    #\n    # Step 1: Define a class called `Combatant` with __init__:\n    #         - self, name, health, attack_power\n    #         Store all as instance attributes.\n    #         Also add: self.is_alive = True\n    #\n    # Step 2: Add an `attack(self, target)` method:\n    #         - target is another Combatant object\n    #         - Reduce target.health by self.attack_power\n    #         - If target.health <= 0:\n    #             Set target.health = 0\n    #             Set target.is_alive = False\n    #         - Print: \"[self.name] attacks [target.name] for [power] damage!\"\n    #\n    # Step 3: Add a `get_status(self)` method:\n    #         - Return: \"[name]: [health] HP (Alive)\" or \"(Defeated)\"\n    #\n    # Step 4: Simulate a battle:\n    #         hero = Combatant(\"{{hero}}\", 100, 25)\n    #         enemy = Combatant(\"{{villain}}\", 60, 15)\n    #\n    #         while hero.is_alive and enemy.is_alive:\n    #             hero.attack(enemy)\n    #             if enemy.is_alive:\n    #                 enemy.attack(hero)\n    #             print(f\"  {hero.get_status()}\")\n    #             print(f\"  {enemy.get_status()}\")\n    pass\n\n\n# ============================================================\n# {{PHASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n\n\ndef exercise_c():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create a class that manages a collection of other objects.\n    #\n    # Step 1: Define a class called `Item` with __init__:\n    #         - self, name, value\n    #         Store as instance attributes.\n    #\n    # Step 2: Define a class called `Shop` with __init__:\n    #         - self, name\n    #         Set self.name = name\n    #         Set self.inventory = []  (list of Item objects)\n    #\n    # Step 3: Add `add_item(self, item)` to Shop:\n    #         - item is an Item object\n    #         - Append it to self.inventory\n    #\n    # Step 4: Add `sell_to(self, item_name, buyer)` to Shop:\n    #         - buyer is a Character object (has .gold attribute)\n    #         - Find the item with matching name in self.inventory\n    #         - If found and buyer.gold >= item.value:\n    #             Remove item from inventory\n    #             Subtract value from buyer.gold\n    #             Return the item\n    #         - Otherwise return None\n    #\n    # Step 5: Test the shop:\n    #         shop = Shop(\"{{location}}\")\n    #         shop.add_item(Item(\"{{item}}\", 50))\n    #         shop.add_item(Item(\"{{spell1}}\", 30))\n    #\n    #         buyer = Character(\"{{hero}}\", 100)\n    #         purchased = shop.sell_to(\"{{item}}\", buyer)\n    #         if purchased:\n    #             print(f\"Bought {purchased.name}!\")\n    #             print(f\"Gold remaining: {buyer.gold}\")\n    pass\n\n\n# ============================================================\n# {{PHASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n\n\ndef exercise_d():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create a more complex interaction between objects.\n    #\n    # Step 1: Define a class called `Healer` with:\n    #         - __init__(self, name, heal_power, energy)\n    #         Store all as instance attributes.\n    #\n    # Step 2: Add `heal(self, target)` method:\n    #         - target is any object with a .health and .max_health attribute\n    #         - If self.energy >= 10:\n    #             Subtract 10 from self.energy\n    #             Add self.heal_power to target.health\n    #             If target.health > target.max_health:\n    #                 Set target.health = target.max_health\n    #             Print: \"[self.name] heals [target.name] for [amount]!\"\n    #             Return the amount healed\n    #         - Otherwise:\n    #             Print: \"[self.name] has no energy!\"\n    #             Return 0\n    #\n    # Step 3: Define a class called `Warrior` with:\n    #         - __init__(self, name, health, max_health)\n    #         Store all as instance attributes.\n    #\n    # Step 4: Test healing interaction:\n    #         healer = Healer(\"{{heroine}}\", 30, 50)\n    #         warrior = Warrior(\"{{hero}}\", 40, 100)\n    #\n    #         print(f\"{warrior.name}: {warrior.health}/{warrior.max_health}\")\n    #         healer.heal(warrior)\n    #         print(f\"{warrior.name}: {warrior.health}/{warrior.max_health}\")\n    #         healer.heal(warrior)\n    #         print(f\"{warrior.name}: {warrior.health}/{warrior.max_health}\")\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{PHASE_1_TITLE}} ===\")\n    exercise_a()\n\n    print(\"\\n=== {{PHASE_2_TITLE}} ===\")\n    exercise_b()\n\n    print(\"\\n=== {{PHASE_3_TITLE}} ===\")\n    exercise_c()\n\n    print(\"\\n=== {{PHASE_4_TITLE}} ===\")\n    exercise_d()\n\n    print(\"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "write_code"
      ],
      "source_file": "module_9_oop/write_code/exercise_4_object_interaction.py"
    },
    {
      "id": "module_9_oop.write_code.exercise_5_inheritance",
      "topic_id": "oop.classes",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Inheritance",
      "title_en": "Inheritance",
      "title_he": "Inheritance",
      "description_en": "Object-Oriented Programming: Inheritance\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn inheritance - creating new classes that\nextend existing ones. The child class inherits all attributes and methods\nfrom the parent, and can add its own or override existing ones.",
      "description_he": "תכנות מונחה עצמים: Inheritance\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn inheritance - creating new classes that\nextend existing ones. The child class inherits all attributes and methods\nfrom the parent, and can add its own or override existing ones.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn inheritance - creating new classes that\nextend existing ones. The child class inherits all attributes and methods\nfrom the parent, and can add its own or override existing ones.\n\"\"\"\n\n\n# ============================================================\n# {{PHASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n\n\n# Parent class (provided for you)\nclass Entity:\n    \"\"\"Base class for all game entities at {{school}}.\"\"\"\n\n    def __init__(self, name, health):\n        self.name = name\n        self.health = health\n\n    def describe(self):\n        return f\"{self.name} (HP: {self.health})\"\n\n\ndef exercise_a():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create a child class that inherits from Entity.\n    #\n    # Step 1: Define a class called `Character` that inherits from Entity:\n    #         class Character(Entity):\n    #\n    # Step 2: In Character's __init__, call the parent's __init__:\n    #         def __init__(self, name, health, role):\n    #             super().__init__(name, health)\n    #             self.role = role\n    #\n    # Step 3: Add a method unique to Character:\n    #         def introduce(self):\n    #             return f\"I am {self.name}, a {self.role}.\"\n    #\n    # Step 4: Test inheritance:\n    #         hero = Character(\"{{hero}}\", 100, \"{{ROLE_TITLE}}\")\n    #         print(hero.describe())  # Inherited from Entity!\n    #         print(hero.introduce())  # Character's own method\n    pass\n\n\n# ============================================================\n# {{PHASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n\n\n# Parent class (provided for you)\nclass Item:\n    \"\"\"Base class for all items.\"\"\"\n\n    def __init__(self, name, value):\n        self.name = name\n        self.value = value\n\n    def get_info(self):\n        return f\"{self.name} (worth {self.value} gold)\"\n\n\ndef exercise_b():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create two different child classes from the same parent.\n    #\n    # Step 1: Define `Weapon` that inherits from Item:\n    #         Add a `damage` attribute in __init__ (after calling super)\n    #         Add a method `attack_info(self)` that returns:\n    #         \"[name]: deals [damage] damage\"\n    #\n    # Step 2: Define `Armor` that inherits from Item:\n    #         Add a `defense` attribute in __init__\n    #         Add a method `defense_info(self)` that returns:\n    #         \"[name]: provides [defense] defense\"\n    #\n    # Step 3: Create instances and test:\n    #         sword = Weapon(\"{{item}}\", 150, 25)\n    #         print(sword.get_info())  # Inherited\n    #         print(sword.attack_info())  # Weapon-specific\n    #\n    #         shield = Armor(\"{{spell1}}\", 100, 15)\n    #         print(shield.get_info())  # Inherited\n    #         print(shield.defense_info())  # Armor-specific\n    pass\n\n\n# ============================================================\n# {{PHASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n\n\ndef exercise_c():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create a class hierarchy with three levels.\n    #\n    # Step 1: Define a base class `Being`:\n    #         __init__(self, name)\n    #         Store self.name\n    #\n    # Step 2: Define `LivingBeing` that inherits from Being:\n    #         __init__(self, name, health)\n    #         Call super().__init__(name)\n    #         Add self.health\n    #         Add method is_alive(self) returning health > 0\n    #\n    # Step 3: Define `Combatant` that inherits from LivingBeing:\n    #         __init__(self, name, health, power)\n    #         Call super().__init__(name, health)\n    #         Add self.power\n    #         Add method battle_cry(self) that returns:\n    #         \"[name] with power [power] is ready!\"\n    #\n    # Step 4: Test the hierarchy:\n    #         fighter = Combatant(\"{{hero}}\", 100, 50)\n    #         print(f\"Name: {fighter.name}\")  # From Being\n    #         print(f\"Alive: {fighter.is_alive()}\")  # From LivingBeing\n    #         print(fighter.battle_cry())  # From Combatant\n    pass\n\n\n# ============================================================\n# {{PHASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n\n\ndef exercise_d():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create specialized subclasses with unique abilities.\n    #\n    # Step 1: Define a base class `Ability`:\n    #         __init__(self, name, power_cost)\n    #         Store both attributes\n    #         Add method describe(self) returning:\n    #         \"[name] (costs [power_cost] energy)\"\n    #\n    # Step 2: Define `AttackAbility` inheriting from Ability:\n    #         __init__(self, name, power_cost, damage)\n    #         Call super and add self.damage\n    #         Add method use(self, target) that:\n    #             Prints \"[name] deals [damage] damage to [target]!\"\n    #\n    # Step 3: Define `HealAbility` inheriting from Ability:\n    #         __init__(self, name, power_cost, heal_amount)\n    #         Call super and add self.heal_amount\n    #         Add method use(self, target) that:\n    #             Prints \"[name] heals [target] for [heal_amount]!\"\n    #\n    # Step 4: Test your abilities:\n    #         fireball = AttackAbility(\"{{spell2}}\", 30, 50)\n    #         print(fireball.describe())  # Inherited\n    #         fireball.use(\"{{villain}}\")  # AttackAbility's method\n    #\n    #         heal = HealAbility(\"{{spell1}}\", 20, 35)\n    #         print(heal.describe())  # Inherited\n    #         heal.use(\"{{hero}}\")  # HealAbility's method\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{PHASE_1_TITLE}} ===\")\n    exercise_a()\n\n    print(\"\\n=== {{PHASE_2_TITLE}} ===\")\n    exercise_b()\n\n    print(\"\\n=== {{PHASE_3_TITLE}} ===\")\n    exercise_c()\n\n    print(\"\\n=== {{PHASE_4_TITLE}} ===\")\n    exercise_d()\n\n    print(\"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "write_code"
      ],
      "source_file": "module_9_oop/write_code/exercise_5_inheritance.py"
    },
    {
      "id": "module_9_oop.write_code.exercise_6_method_override",
      "topic_id": "oop.classes",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Method Override",
      "title_en": "Method Override",
      "title_he": "Method Override",
      "description_en": "Object-Oriented Programming: Method Override\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn to override methods - replacing or extending\nparent class behavior in child classes. Overriding allows subclasses to\nprovide specialized implementations while maintaining the same interface.",
      "description_he": "תכנות מונחה עצמים: Method Override\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn to override methods - replacing or extending\nparent class behavior in child classes. Overriding allows subclasses to\nprovide specialized implementations while maintaining the same interface.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nIn this exercise, you'll learn to override methods - replacing or extending\nparent class behavior in child classes. Overriding allows subclasses to\nprovide specialized implementations while maintaining the same interface.\n\"\"\"\n\n\n# ============================================================\n# {{PHASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n\n\n# Parent class (provided for you)\nclass Character:\n    \"\"\"Base character class.\"\"\"\n\n    def __init__(self, name, health):\n        self.name = name\n        self.health = health\n\n    def get_attack_power(self):\n        \"\"\"Default attack power is 10.\"\"\"\n        return 10\n\n    def describe(self):\n        \"\"\"Default description.\"\"\"\n        return f\"{self.name} (HP: {self.health})\"\n\n\ndef exercise_a():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create a subclass that OVERRIDES a method.\n    #\n    # Step 1: Define `Warrior` that inherits from Character:\n    #         class Warrior(Character):\n    #\n    # Step 2: In __init__, call super() and add self.strength attribute\n    #\n    # Step 3: Override get_attack_power to return strength instead of 10:\n    #         def get_attack_power(self):\n    #             return self.strength\n    #\n    # Step 4: Test that the override works:\n    #         base = Character(\"Guard\", 50)\n    #         print(f\"Character attack: {base.get_attack_power()}\")  # 10\n    #\n    #         warrior = Warrior(\"{{hero}}\", 100, 25)\n    #         print(f\"Warrior attack: {warrior.get_attack_power()}\")  # 25\n    pass\n\n\n# ============================================================\n# {{PHASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n\n\n# Parent class (provided for you)\nclass Entity:\n    \"\"\"Base entity class.\"\"\"\n\n    def __init__(self, name):\n        self.name = name\n\n    def __str__(self):\n        return f\"Entity: {self.name}\"\n\n    def make_sound(self):\n        return \"...\"\n\n\ndef exercise_b():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create multiple subclasses that override the same method differently.\n    #\n    # Step 1: Define `Hero` that inherits from Entity:\n    #         Override make_sound() to return \"[name] says: For justice!\"\n    #         Override __str__ to return \"[name] the Hero\"\n    #\n    # Step 2: Define `Creature` that inherits from Entity:\n    #         Override make_sound() to return \"[name] growls menacingly!\"\n    #         Override __str__ to return \"[name] the Creature\"\n    #\n    # Step 3: Test polymorphism - different behavior, same method name:\n    #         hero = Hero(\"{{hero}}\")\n    #         creature = Creature(\"{{creature}}\")\n    #\n    #         entities = [hero, creature]\n    #         for entity in entities:\n    #             print(entity)  # Uses __str__\n    #             print(f\"  Sound: {entity.make_sound()}\")\n    pass\n\n\n# ============================================================\n# {{PHASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n\n\n# Parent class (provided for you)\nclass BaseCalculator:\n    \"\"\"Base calculator for game mechanics.\"\"\"\n\n    def __init__(self, base_value):\n        self.base_value = base_value\n\n    def calculate(self):\n        \"\"\"Return the base value.\"\"\"\n        return self.base_value\n\n    def describe_calculation(self):\n        return f\"Base: {self.base_value}\"\n\n\ndef exercise_c():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Override a method and EXTEND it using super().\n    #\n    # Step 1: Define `BonusCalculator` inheriting from BaseCalculator:\n    #         Add a bonus attribute in __init__\n    #\n    # Step 2: Override calculate() to ADD the bonus to the base value:\n    #         def calculate(self):\n    #             base = super().calculate()  # Get parent's result\n    #             return base + self.bonus    # Add to it\n    #\n    # Step 3: Override describe_calculation() to extend the description:\n    #         def describe_calculation(self):\n    #             parent_desc = super().describe_calculation()\n    #             return f\"{parent_desc} + Bonus: {self.bonus}\"\n    #\n    # Step 4: Test the extension:\n    #         basic = BaseCalculator(100)\n    #         print(f\"Basic: {basic.calculate()}\")  # 100\n    #         print(basic.describe_calculation())\n    #\n    #         with_bonus = BonusCalculator(100, 25)\n    #         print(f\"With bonus: {with_bonus.calculate()}\")  # 125\n    #         print(with_bonus.describe_calculation())\n    pass\n\n\n# ============================================================\n# {{PHASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n\n\ndef exercise_d():\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create a hierarchy with specialized behavior at each level.\n    #\n    # Step 1: Define base class `Unit`:\n    #         __init__(self, name)\n    #         Method get_info() returning just the name\n    #         Method get_power() returning 0\n    #\n    # Step 2: Define `CombatUnit` inheriting from Unit:\n    #         __init__(self, name, attack)\n    #         Override get_power() to return self.attack\n    #         Override get_info() to return:\n    #             super().get_info() + f\" (ATK: {self.attack})\"\n    #\n    # Step 3: Define `EliteUnit` inheriting from CombatUnit:\n    #         __init__(self, name, attack, special_power)\n    #         Override get_power() to return attack + special_power\n    #         Override get_info() to return:\n    #             super().get_info() + f\" [ELITE +{self.special_power}]\"\n    #\n    # Step 4: Test the hierarchy:\n    #         basic = Unit(\"Recruit\")\n    #         print(f\"{basic.get_info()} - Power: {basic.get_power()}\")\n    #\n    #         combat = CombatUnit(\"Soldier\", 15)\n    #         print(f\"{combat.get_info()} - Power: {combat.get_power()}\")\n    #\n    #         elite = EliteUnit(\"{{hero}}\", 20, 10)\n    #         print(f\"{elite.get_info()} - Power: {elite.get_power()}\")\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{PHASE_1_TITLE}} ===\")\n    exercise_a()\n\n    print(\"\\n=== {{PHASE_2_TITLE}} ===\")\n    exercise_b()\n\n    print(\"\\n=== {{PHASE_3_TITLE}} ===\")\n    exercise_c()\n\n    print(\"\\n=== {{PHASE_4_TITLE}} ===\")\n    exercise_d()\n\n    print(\"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_9_oop",
        "write_code"
      ],
      "source_file": "module_9_oop/write_code/exercise_6_method_override.py"
    }
  ]
}