{
  "version": "3.0.0",
  "theme_support": true,
  "generated_at": "2026-02-03T10:37:11.610033",
  "module": "module_5_games",
  "count": 10,
  "exercise_types": [
    "add_error_handling",
    "bug_hunt",
    "hybrid",
    "write_code"
  ],
  "exercises": [
    {
      "id": "module_5_games.add_error_handling.exercise_1_input_validation",
      "topic_id": "loops.while",
      "exercise_type": "add_error_handling",
      "category": "improvement",
      "title": "Input Validation",
      "title_en": "Input Validation",
      "title_he": "Input Validation",
      "description_en": "Games: Input Validation\n\n{{CONTEXT_ERROR_HANDLING_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Adding input validation loops\nDifficulty: 3\n\nInput validation ensures users provide valid data before proceeding.\nUse while loops with string checking to validate input.\n\nNOTE: We use while loops and string methods (like .isdigit()) for validation,\nnot try/except blocks. This teaches the fundamental pattern of validation loops.",
      "description_he": "משחקים: Input Validation\n\n{{CONTEXT_ERROR_HANDLING_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Adding input validation loops\nDifficulty: 3\n\nInput validation ensures users provide valid data before proceeding.\nUse while loops with string checking to validate input.\n\nNOTE: We use while loops and string methods (like .isdigit()) for validation,\nnot try/except blocks. This teaches the fundamental pattern of validation loops.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "defensive_programming",
        "exceptions",
        "robustness"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_ERROR_HANDLING_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Adding input validation loops\nDifficulty: 3\n\nInput validation ensures users provide valid data before proceeding.\nUse while loops with string checking to validate input.\n\nNOTE: We use while loops and string methods (like .isdigit()) for validation,\nnot try/except blocks. This teaches the fundamental pattern of validation loops.\n\"\"\"\n\n\n# ============================================================\n# {{HANDLING_1_TITLE}}\n# ============================================================\n# {{CONTEXT_HANDLING_1_NARRATIVE}}\n#\n# This function accepts any input and crashes on invalid numbers.\n\n\ndef original_get_number():\n    \"\"\"ORIGINAL: Crashes if user enters non-numeric text\"\"\"\n    user_input = input(\"Enter a number: \")\n    number = int(user_input)  # Crashes on \"abc\"!\n    return number\n\n\ndef safe_get_number():\n    \"\"\"\n    Get a valid integer from the user.\n    Keep asking until they enter a valid number.\n\n    Returns:\n        int: A valid integer entered by the user\n\n    Validation:\n    - If input is not numeric, print \"Please enter a valid number.\"\n    - Keep asking until valid\n    - Handle negative numbers (starts with '-')\n    \"\"\"\n    # ✏️ ADD VALIDATION LOOP ✏️\n    #\n    # {{CONTEXT_HANDLING_HINT_1}}\n    #\n    # Step 1: Start while True loop\n    # Step 2: Get input\n    # Step 3: Check if valid:\n    #         - For positive: input.isdigit()\n    #         - For negative: input.startswith('-') and input[1:].isdigit()\n    # Step 4: If valid, convert and return\n    # Step 5: If invalid, print error message (loop continues)\n    pass\n\n\n# ============================================================\n# {{HANDLING_2_TITLE}}\n# ============================================================\n# {{CONTEXT_HANDLING_2_NARRATIVE}}\n#\n# This function accepts numbers outside the valid range.\n\n\ndef original_get_score():\n    \"\"\"ORIGINAL: Accepts any number, even invalid scores\"\"\"\n    score = int(input(\"Enter score (0-100): \"))\n    return score\n\n\ndef safe_get_score():\n    \"\"\"\n    Get a valid score from 0 to 100.\n    Keep asking until input is valid.\n\n    Returns:\n        int: A score between 0 and 100 (inclusive)\n\n    Validation:\n    - Must be a number\n    - Must be between 0 and 100\n    \"\"\"\n    # ✏️ ADD VALIDATION LOOP ✏️\n    #\n    # {{CONTEXT_HANDLING_HINT_2}}\n    #\n    # Step 1: Start while True loop\n    # Step 2: Get input\n    # Step 3: Check if numeric (handle with .isdigit())\n    #         If not, print \"Please enter a number.\" and continue\n    # Step 4: Convert to int\n    # Step 5: Check if in range 0-100\n    #         If not, print \"Score must be between 0 and 100.\" and continue\n    # Step 6: Return valid score\n    pass\n\n\n# ============================================================\n# {{HANDLING_3_TITLE}}\n# ============================================================\n# {{CONTEXT_HANDLING_3_NARRATIVE}}\n#\n# This function accepts any text, even empty strings.\n\n\ndef original_get_name():\n    \"\"\"ORIGINAL: Accepts empty names\"\"\"\n    name = input(\"Enter your name: \")\n    return name\n\n\ndef safe_get_name():\n    \"\"\"\n    Get a non-empty name from the user.\n    Keep asking until they enter something.\n\n    Returns:\n        str: A non-empty, stripped name\n\n    Validation:\n    - Must not be empty after stripping whitespace\n    - Strip leading/trailing whitespace from result\n    \"\"\"\n    # ✏️ ADD VALIDATION LOOP ✏️\n    #\n    # {{CONTEXT_HANDLING_HINT_3}}\n    #\n    # Step 1: Start while True loop\n    # Step 2: Get input and strip whitespace\n    # Step 3: If empty string, print \"Name cannot be empty.\" and continue\n    # Step 4: Return the stripped name\n    pass\n\n\n# ============================================================\n# {{HANDLING_4_TITLE}}\n# ============================================================\n# {{CONTEXT_HANDLING_4_NARRATIVE}}\n#\n# This function accepts any choice, not just valid options.\n\n\ndef original_get_choice():\n    \"\"\"ORIGINAL: Accepts any choice, even invalid ones\"\"\"\n    print(\"Choose: (a) {{spell1}}, (b) {{spell2}}, (c) {{spell3}}\")\n    choice = input(\"Your choice: \")\n    return choice\n\n\ndef safe_get_choice():\n    \"\"\"\n    Get a valid choice from the user (a, b, or c).\n    Keep asking until valid.\n\n    Returns:\n        str: 'a', 'b', or 'c'\n\n    Validation:\n    - Must be exactly 'a', 'b', or 'c' (case insensitive)\n    - Show valid options in error message\n    \"\"\"\n    # ✏️ ADD VALIDATION LOOP ✏️\n    #\n    # {{CONTEXT_HANDLING_HINT_4}}\n    #\n    # Step 1: Define valid_choices = ['a', 'b', 'c']\n    # Step 2: Print the menu\n    # Step 3: Start while True loop\n    # Step 4: Get input and convert to lowercase\n    # Step 5: If choice in valid_choices, return it\n    # Step 6: Otherwise print \"Invalid choice. Please enter a, b, or c.\"\n    pass\n\n\n# ============================================================\n# {{HANDLING_5_TITLE}}\n# ============================================================\n# {{CONTEXT_HANDLING_5_NARRATIVE}}\n#\n# This yes/no function accepts any input.\n\n\ndef original_confirm():\n    \"\"\"ORIGINAL: Accepts any response as yes\"\"\"\n    response = input(\"Confirm? (yes/no): \")\n    return response == \"yes\"\n\n\ndef safe_confirm(prompt):\n    \"\"\"\n    Get a yes/no confirmation from the user.\n    Keep asking until they enter yes or no.\n\n    Args:\n        prompt: The question to ask\n\n    Returns:\n        bool: True for yes, False for no\n\n    Validation:\n    - Accept 'yes', 'y', 'no', 'n' (case insensitive)\n    - Keep asking for other inputs\n    \"\"\"\n    # ✏️ ADD VALIDATION LOOP ✏️\n    #\n    # {{CONTEXT_HANDLING_HINT_5}}\n    #\n    # Step 1: Start while True loop\n    # Step 2: Print prompt and get input (lowercase, stripped)\n    # Step 3: If response is 'yes' or 'y', return True\n    # Step 4: If response is 'no' or 'n', return False\n    # Step 5: Otherwise print \"Please enter yes or no.\"\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_ERROR_HANDLING_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{HANDLING_1_TITLE}} ===\")\n    print(\"Getting a valid number:\")\n    # number = safe_get_number()\n    # print(f\"You entered: {number}\")\n\n    print(\"\\n=== {{HANDLING_2_TITLE}} ===\")\n    print(\"Getting a valid score:\")\n    # score = safe_get_score()\n    # print(f\"Score recorded: {score}\")\n\n    print(\"\\n=== {{HANDLING_3_TITLE}} ===\")\n    print(\"Getting a valid name:\")\n    # name = safe_get_name()\n    # print(f\"Hello, {name}!\")\n\n    print(\"\\n=== {{HANDLING_4_TITLE}} ===\")\n    print(\"Getting a valid choice:\")\n    # choice = safe_get_choice()\n    # print(f\"You chose: {choice}\")\n\n    print(\"\\n=== {{HANDLING_5_TITLE}} ===\")\n    print(\"Getting confirmation:\")\n    # if safe_confirm(\"Do you want to continue? (yes/no): \"):\n    #     print(\"Continuing...\")\n    # else:\n    #     print(\"Cancelled.\")\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"{{CONTEXT_ROBUSTNESS_COMPLETE}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "add_error_handling"
      ],
      "source_file": "module_5_games/add_error_handling/exercise_1_input_validation.py"
    },
    {
      "id": "module_5_games.bug_hunt.exercise_1_infinite_loops",
      "topic_id": "loops.while",
      "exercise_type": "bug_hunt",
      "category": "debugging",
      "title": "Infinite Loops",
      "title_en": "Infinite Loops",
      "title_he": "Infinite Loops",
      "description_en": "Games: Infinite Loops\n\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding infinite loop bugs\nDifficulty: 1-2\n\nInfinite loops are one of the most common bugs when learning while loops.\nIn this exercise, you'll find and fix loops that never end.",
      "description_he": "משחקים: Infinite Loops\n\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding infinite loop bugs\nDifficulty: 1-2\n\nInfinite loops are one of the most common bugs when learning while loops.\nIn this exercise, you'll find and fix loops that never end.",
      "difficulty": 3,
      "requires_running": false,
      "estimated_time_minutes": 8,
      "skills": [
        "debugging",
        "critical_reading",
        "common_mistakes"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding infinite loop bugs\nDifficulty: 1-2\n\nInfinite loops are one of the most common bugs when learning while loops.\nIn this exercise, you'll find and fix loops that never end.\n\"\"\"\n\n\n# ============================================================\n# {{CASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_1_NARRATIVE}}\n#\n# {{hero}} wrote this code to count items, but it runs forever!\n#\n# EXPECTED BEHAVIOR:\n# Print numbers 1 through 5, then stop\n#\n# ACTUAL BEHAVIOR:\n# Prints 1 forever without stopping\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_1}}\n\n\ndef buggy_counter():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    count = 1\n    while count <= 5:\n        print(count)\n        # The counter never changes! Loop runs forever.\n\n\ndef fix_counter():\n    \"\"\"\n    Fix the infinite loop.\n\n    Expected output:\n        1\n        2\n        3\n        4\n        5\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_2_NARRATIVE}}\n#\n# This countdown should go from 5 to 1, but something's wrong.\n#\n# EXPECTED BEHAVIOR:\n# Print 5, 4, 3, 2, 1, \"Done!\"\n#\n# ACTUAL BEHAVIOR:\n# Counts the wrong direction and never reaches 0\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_2}}\n\n\ndef buggy_countdown():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    num = 5\n    while num > 0:\n        print(num)\n        num += 1  # Oops! Going the wrong way!\n\n\ndef fix_countdown():\n    \"\"\"\n    Fix the countdown direction.\n\n    Expected output:\n        5\n        4\n        3\n        2\n        1\n        Done!\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_3_NARRATIVE}}\n#\n# This loop should process a list, but it never terminates.\n#\n# EXPECTED BEHAVIOR:\n# Process each item and stop when list is empty\n#\n# ACTUAL BEHAVIOR:\n# The list never gets shorter\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_3}}\n\n\ndef buggy_list_processor():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    items = [\"{{item}}\", \"{{pet}}\", \"{{creature}}\"]\n    index = 0\n    while index < len(items):\n        print(f\"Processing: {items[index]}\")\n        # Forgot to move to next item!\n\n\ndef fix_list_processor():\n    \"\"\"\n    Fix the list processor.\n\n    Expected output:\n        Processing: {{item}}\n        Processing: {{pet}}\n        Processing: {{creature}}\n        All items processed!\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_4_NARRATIVE}}\n#\n# This accumulator should add up numbers, but it loops forever.\n#\n# EXPECTED BEHAVIOR:\n# Add numbers until total exceeds 20, then stop\n#\n# ACTUAL BEHAVIOR:\n# Total never changes, condition never becomes False\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_4}}\n\n\ndef buggy_accumulator():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    total = 0\n    amount = 5\n    while total < 20:\n        print(f\"Adding {amount}, total would be {total + amount}\")\n        # total + amount doesn't save the result!\n\n\ndef fix_accumulator():\n    \"\"\"\n    Fix the accumulator.\n\n    Expected output:\n        Adding 5, total is now 5\n        Adding 5, total is now 10\n        Adding 5, total is now 15\n        Adding 5, total is now 20\n        Final total: 20\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_INVESTIGATION_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{CASE_1_TITLE}} ===\")\n    print(\"Buggy version (DON'T RUN - infinite loop):\")\n    print(\"# buggy_counter()\")\n    print(\"\\nFixed version:\")\n    fix_counter()\n\n    print(\"\\n=== {{CASE_2_TITLE}} ===\")\n    print(\"Buggy version (DON'T RUN - infinite loop):\")\n    print(\"# buggy_countdown()\")\n    print(\"\\nFixed version:\")\n    fix_countdown()\n\n    print(\"\\n=== {{CASE_3_TITLE}} ===\")\n    print(\"Buggy version (DON'T RUN - infinite loop):\")\n    print(\"# buggy_list_processor()\")\n    print(\"\\nFixed version:\")\n    fix_list_processor()\n\n    print(\"\\n=== {{CASE_4_TITLE}} ===\")\n    print(\"Buggy version (DON'T RUN - infinite loop):\")\n    print(\"# buggy_accumulator()\")\n    print(\"\\nFixed version:\")\n    fix_accumulator()\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"{{CONTEXT_INVESTIGATION_COMPLETE}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "bug_hunt"
      ],
      "source_file": "module_5_games/bug_hunt/exercise_1_infinite_loops.py"
    },
    {
      "id": "module_5_games.bug_hunt.exercise_2_break_continue",
      "topic_id": "loops.while",
      "exercise_type": "bug_hunt",
      "category": "debugging",
      "title": "Break Continue",
      "title_en": "Break Continue",
      "title_he": "Break Continue",
      "description_en": "Games: Break Continue\n\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding bugs with break and continue\nDifficulty: 2-3\n\nbreak and continue are powerful but can cause subtle bugs\nwhen placed incorrectly or when the logic is inverted.",
      "description_he": "משחקים: Break Continue\n\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding bugs with break and continue\nDifficulty: 2-3\n\nbreak and continue are powerful but can cause subtle bugs\nwhen placed incorrectly or when the logic is inverted.",
      "difficulty": 3,
      "requires_running": false,
      "estimated_time_minutes": 8,
      "skills": [
        "debugging",
        "critical_reading",
        "common_mistakes"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding bugs with break and continue\nDifficulty: 2-3\n\nbreak and continue are powerful but can cause subtle bugs\nwhen placed incorrectly or when the logic is inverted.\n\"\"\"\n\n\n# ============================================================\n# {{CASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_1_NARRATIVE}}\n#\n# This search function should find an item and return its index.\n#\n# EXPECTED BEHAVIOR:\n# Return the index where target is found, or -1 if not found\n#\n# ACTUAL BEHAVIOR:\n# Always returns -1, even when the item exists\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_1}}\n\n\ndef buggy_search(items, target):\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    index = 0\n    while index < len(items):\n        if items[index] == target:\n            break  # Found it!\n        index += 1\n    return -1  # BUG: Always returns -1, never returns the found index\n\n\ndef fix_search(items, target):\n    \"\"\"\n    Fix the search function.\n\n    Example:\n        fix_search([\"{{item}}\", \"{{pet}}\", \"{{creature}}\"], \"{{pet}}\")\n        Returns: 1\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_2_NARRATIVE}}\n#\n# This function should skip negative numbers and sum the positives.\n#\n# EXPECTED BEHAVIOR:\n# Sum only the positive numbers, skip negatives\n#\n# ACTUAL BEHAVIOR:\n# Returns 0 because it breaks on the first negative\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_2}}\n\n\ndef buggy_sum_positives(numbers):\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    total = 0\n    for num in numbers:\n        if num < 0:\n            break  # BUG: Should be continue, not break!\n        total += num\n    return total\n\n\ndef fix_sum_positives(numbers):\n    \"\"\"\n    Fix the function to sum only positive numbers.\n\n    Example:\n        fix_sum_positives([5, -3, 10, -1, 7])\n        Returns: 22 (5 + 10 + 7)\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_3_NARRATIVE}}\n#\n# This collector should stop when the user enters 'quit'.\n#\n# EXPECTED BEHAVIOR:\n# Collect items until user types 'quit', then return the list\n#\n# ACTUAL BEHAVIOR:\n# Never stops, keeps asking forever\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_3}}\n\n\ndef buggy_collector():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    items = []\n    while True:\n        user_input = input(\"Enter item (or 'quit'): \")\n        if user_input == \"quit\":\n            continue  # BUG: Should be break, not continue!\n        items.append(user_input)\n    return items\n\n\ndef fix_collector():\n    \"\"\"\n    Fix the collector to stop on 'quit'.\n\n    Returns:\n        list: Items collected before 'quit'\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_4_NARRATIVE}}\n#\n# This validator should stop validating after finding one error.\n#\n# EXPECTED BEHAVIOR:\n# Check items until finding an invalid one, then stop\n#\n# ACTUAL BEHAVIOR:\n# The break is inside the else, so it breaks on VALID items\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_4}}\n\n\ndef buggy_validator(items):\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    valid_items = []\n    for item in items:\n        if item == \"\" or item is None:\n            print(f\"Invalid item found!\")\n        else:\n            valid_items.append(item)\n            break  # BUG: Break is in wrong branch!\n    return valid_items\n\n\ndef fix_validator(items):\n    \"\"\"\n    Fix the validator to stop after finding first invalid item.\n\n    Example:\n        fix_validator([\"{{hero}}\", \"{{villain}}\", \"\", \"{{friend}}\"])\n        Returns: [\"{{hero}}\", \"{{villain}}\"]  # Stops at empty string\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_5_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_5_NARRATIVE}}\n#\n# This function should find the first item that matches a condition.\n#\n# EXPECTED BEHAVIOR:\n# Return the first item longer than 5 characters\n#\n# ACTUAL BEHAVIOR:\n# Skips items that match! Returns wrong result.\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_5}}\n\n\ndef buggy_find_long_item(items):\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    for item in items:\n        if len(item) > 5:\n            continue  # BUG: Should return item, not continue!\n        # Falls through without returning the match\n    return None\n\n\ndef fix_find_long_item(items):\n    \"\"\"\n    Fix the function to return first item longer than 5 characters.\n\n    Example:\n        fix_find_long_item([\"cat\", \"elephant\", \"dog\"])\n        Returns: \"elephant\"\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_INVESTIGATION_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{CASE_1_TITLE}} ===\")\n    print(\"Testing search:\")\n    items = [\"{{item}}\", \"{{pet}}\", \"{{creature}}\"]\n    buggy_result = buggy_search(items, \"{{pet}}\")\n    print(f\"Buggy result: {buggy_result} (should be 1)\")\n    # fixed_result = fix_search(items, \"{{pet}}\")\n    # print(f\"Fixed result: {fixed_result}\")\n\n    print(\"\\n=== {{CASE_2_TITLE}} ===\")\n    print(\"Testing sum positives:\")\n    numbers = [5, -3, 10, -1, 7]\n    buggy_result = buggy_sum_positives(numbers)\n    print(f\"Buggy result: {buggy_result} (should be 22)\")\n    # fixed_result = fix_sum_positives(numbers)\n    # print(f\"Fixed result: {fixed_result}\")\n\n    print(\"\\n=== {{CASE_3_TITLE}} ===\")\n    print(\"Testing collector:\")\n    print(\"(Buggy version would loop forever - don't run!)\")\n    # fixed_items = fix_collector()\n    # print(f\"Collected: {fixed_items}\")\n\n    print(\"\\n=== {{CASE_4_TITLE}} ===\")\n    print(\"Testing validator:\")\n    test_items = [\"{{hero}}\", \"{{villain}}\", \"\", \"{{friend}}\"]\n    buggy_result = buggy_validator(test_items.copy())\n    print(f\"Buggy result: {buggy_result} (should be ['{{{{hero}}}}', '{{{{villain}}}}'])\")\n    # fixed_result = fix_validator(test_items)\n    # print(f\"Fixed result: {fixed_result}\")\n\n    print(\"\\n=== {{CASE_5_TITLE}} ===\")\n    print(\"Testing find long item:\")\n    words = [\"cat\", \"elephant\", \"dog\", \"hippopotamus\"]\n    buggy_result = buggy_find_long_item(words)\n    print(f\"Buggy result: {buggy_result} (should be 'elephant')\")\n    # fixed_result = fix_find_long_item(words)\n    # print(f\"Fixed result: {fixed_result}\")\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"{{CONTEXT_INVESTIGATION_COMPLETE}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "bug_hunt"
      ],
      "source_file": "module_5_games/bug_hunt/exercise_2_break_continue.py"
    },
    {
      "id": "module_5_games.bug_hunt.exercise_3_random_bugs",
      "topic_id": "loops.while",
      "exercise_type": "bug_hunt",
      "category": "debugging",
      "title": "Random Bugs",
      "title_en": "Random Bugs",
      "title_he": "Random Bugs",
      "description_en": "Games: Random Bugs\n\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding bugs in random module usage\nDifficulty: 2-3\n\nThe random module has some common pitfalls:\n- randint is INCLUSIVE on both ends (unlike range)\n- Forgetting to import random\n- Using wrong function for the task",
      "description_he": "משחקים: Random Bugs\n\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding bugs in random module usage\nDifficulty: 2-3\n\nThe random module has some common pitfalls:\n- randint is INCLUSIVE on both ends (unlike range)\n- Forgetting to import random\n- Using wrong function for the task",
      "difficulty": 3,
      "requires_running": false,
      "estimated_time_minutes": 8,
      "skills": [
        "debugging",
        "critical_reading",
        "common_mistakes"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding bugs in random module usage\nDifficulty: 2-3\n\nThe random module has some common pitfalls:\n- randint is INCLUSIVE on both ends (unlike range)\n- Forgetting to import random\n- Using wrong function for the task\n\"\"\"\n\nimport random\n\n\n# ============================================================\n# {{CASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_1_NARRATIVE}}\n#\n# This die roller should roll from 1 to 6, but something's off.\n#\n# EXPECTED BEHAVIOR:\n# Return values from 1 to 6 (inclusive)\n#\n# ACTUAL BEHAVIOR:\n# Returns values from 0 to 5 (never returns 6!)\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_1}}\n\n\ndef buggy_roll_die():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    return random.randint(0, 5)  # BUG: Range should be 1 to 6\n\n\ndef fix_roll_die():\n    \"\"\"\n    Fix the die roller to return 1-6.\n\n    Returns:\n        int: A random number from 1 to 6 (inclusive)\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_2_NARRATIVE}}\n#\n# This picker should select from a list, but picks indices instead.\n#\n# EXPECTED BEHAVIOR:\n# Return one of: \"{{hero}}\", \"{{villain}}\", \"{{friend}}\"\n#\n# ACTUAL BEHAVIOR:\n# Returns 0, 1, or 2 (the indices, not the names!)\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_2}}\n\n\ndef buggy_pick_character():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    characters = [\"{{hero}}\", \"{{villain}}\", \"{{friend}}\"]\n    return random.randint(0, len(characters) - 1)  # BUG: Returns index, not item\n\n\ndef fix_pick_character():\n    \"\"\"\n    Fix the picker to return an actual character name.\n\n    Returns:\n        str: A randomly chosen character name\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # Hint: Use random.choice() instead of randint for picking from lists\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_3_NARRATIVE}}\n#\n# This chance function should return True about 70% of the time.\n#\n# EXPECTED BEHAVIOR:\n# Returns True approximately 70% of the time\n#\n# ACTUAL BEHAVIOR:\n# Returns True approximately 30% of the time (inverted!)\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_3}}\n\n\ndef buggy_seventy_percent_chance():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    roll = random.random()\n    return roll > 0.7  # BUG: Condition is inverted! Should be < 0.7\n\n\ndef fix_seventy_percent_chance():\n    \"\"\"\n    Fix the function to return True about 70% of the time.\n\n    Returns:\n        bool: True approximately 70% of the time\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_4_NARRATIVE}}\n#\n# This damage calculator has an off-by-one error in its range.\n#\n# EXPECTED BEHAVIOR:\n# Deal base damage plus 1-5 bonus (so 11-15 if base is 10)\n#\n# ACTUAL BEHAVIOR:\n# Deals base damage plus 1-6 bonus (includes 6, which is too high)\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_4}}\n\n\ndef buggy_calculate_damage(base_damage):\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    bonus = random.randint(1, 6)  # BUG: Should be 1-5, not 1-6\n    return base_damage + bonus\n\n\ndef fix_calculate_damage(base_damage):\n    \"\"\"\n    Fix the damage calculator.\n\n    Args:\n        base_damage: The base damage amount\n\n    Returns:\n        int: base_damage plus a random bonus from 1 to 5\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_5_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_5_NARRATIVE}}\n#\n# This coin flipper should return \"heads\" or \"tails\" randomly.\n#\n# EXPECTED BEHAVIOR:\n# Return \"heads\" or \"tails\" with equal probability\n#\n# ACTUAL BEHAVIOR:\n# Always returns \"heads\" (the variable is assigned but never used)\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_5}}\n\n\ndef buggy_flip_coin():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    result = random.choice([\"heads\", \"tails\"])\n    return \"heads\"  # BUG: Ignores the random result, always returns \"heads\"\n\n\ndef fix_flip_coin():\n    \"\"\"\n    Fix the coin flipper.\n\n    Returns:\n        str: Either \"heads\" or \"tails\" randomly\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_6_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_6_NARRATIVE}}\n#\n# This stat generator should create balanced stats (total around 30).\n#\n# EXPECTED BEHAVIOR:\n# Generate three stats of 8-12 each, total 24-36\n#\n# ACTUAL BEHAVIOR:\n# All three stats are the SAME value (rolled once, used three times)\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_6}}\n\n\ndef buggy_generate_balanced_stats():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    roll = random.randint(8, 12)\n    return {\n        \"strength\": roll,  # BUG: Same roll used for all three!\n        \"agility\": roll,\n        \"wisdom\": roll\n    }\n\n\ndef fix_generate_balanced_stats():\n    \"\"\"\n    Fix the stat generator to give different values.\n\n    Returns:\n        dict: Three stats, each independently rolled 8-12\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_INVESTIGATION_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{CASE_1_TITLE}} ===\")\n    print(\"Testing die roller (should be 1-6):\")\n    results = [buggy_roll_die() for _ in range(10)]\n    print(f\"Buggy rolls: {results}\")\n    print(\"Notice: never gets 6, sometimes gets 0!\")\n\n    print(\"\\n=== {{CASE_2_TITLE}} ===\")\n    print(\"Testing character picker:\")\n    print(f\"Buggy result: {buggy_pick_character()} (should be a name, not number)\")\n\n    print(\"\\n=== {{CASE_3_TITLE}} ===\")\n    print(\"Testing 70% chance (100 trials):\")\n    successes = sum(1 for _ in range(100) if buggy_seventy_percent_chance())\n    print(f\"Buggy successes: {successes}/100 (should be ~70)\")\n\n    print(\"\\n=== {{CASE_4_TITLE}} ===\")\n    print(\"Testing damage calculator (base 10):\")\n    damages = [buggy_calculate_damage(10) for _ in range(10)]\n    print(f\"Buggy damages: {damages}\")\n    print(\"Notice: might include 16 (10+6), which shouldn't be possible!\")\n\n    print(\"\\n=== {{CASE_5_TITLE}} ===\")\n    print(\"Testing coin flipper (10 flips):\")\n    flips = [buggy_flip_coin() for _ in range(10)]\n    print(f\"Buggy flips: {flips}\")\n    print(\"Notice: always heads!\")\n\n    print(\"\\n=== {{CASE_6_TITLE}} ===\")\n    print(\"Testing stat generator:\")\n    stats = buggy_generate_balanced_stats()\n    print(f\"Buggy stats: {stats}\")\n    print(\"Notice: all stats are identical!\")\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"{{CONTEXT_INVESTIGATION_COMPLETE}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "bug_hunt"
      ],
      "source_file": "module_5_games/bug_hunt/exercise_3_random_bugs.py"
    },
    {
      "id": "module_5_games.hybrid.exercise_1_rivalry_loop_duel",
      "topic_id": "loops.while",
      "exercise_type": "hybrid",
      "category": "hybrid",
      "title": "Rivalry Loop Duel",
      "title_en": "Rivalry Loop Duel",
      "title_he": "Rivalry Loop Duel",
      "description_en": "Games: Rivalry Loop Duel\n\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise following {{hero}}'s journey from defeat to victory.\nComplete each part in order.\n\nProgramming concepts: while loops, random, game state, conditionals",
      "description_he": "משחקים: Rivalry Loop Duel\n\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise following {{hero}}'s journey from defeat to victory.\nComplete each part in order.\n\nProgramming concepts: while loops, random, game state, conditionals",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "mental_execution",
        "syntax_recall",
        "implementation",
        "pattern_recognition",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise following {{hero}}'s journey from defeat to victory.\nComplete each part in order.\n\nProgramming concepts: while loops, random, game state, conditionals\n\"\"\"\n\nimport random\n\n# ============================================================\n# PART 1: The Defeat\n# ============================================================\n# {{CONTEXT_SETBACK_NARRATIVE}}\n#\n# {{hero}}'s code from the last match had bugs. That's why {{villain}} won.\n# Find and fix the 3 bugs so this never happens again.\n#\n# BUGS TO FIND: 3\n\n\ndef buggy_match():\n    \"\"\"The buggy code that caused {{hero}} to lose.\"\"\"\n    player_a_score = 0\n    player_b_score = 0\n    rounds_played = 0\n    max_rounds = 5\n\n    print(f\"=== {{{{hero}}}} vs {{{{villain}}}} ===\")\n    print()\n\n    while rounds_played < max_rounds:  # BUG 1: Should be <=, misses round 5\n        rounds_played += 1\n        print(f\"--- Round {rounds_played} ---\")\n\n        # {{hero}}'s turn\n        player_a_result = random.choice([\"success\", \"success\", \"fail\"])\n        if player_a_result == \"success\":\n            player_a_score + 1  # BUG 2: Should be player_a_score += 1\n            print(f\"{{{{hero}}}} scores! Total: {player_a_score}\")\n        else:\n            print(f\"{{{{hero}}}} misses...\")\n\n        # {{villain}}'s turn\n        player_b_result = random.choice([\"success\", \"success\", \"fail\"])\n        if player_b_result == \"success\":\n            player_b_score += 1\n            print(f\"{{{{villain}}}} scores. Total: {player_b_score}\")\n        else:\n            print(f\"{{{{villain}}}} misses!\")\n\n        print()\n\n    print(\"=== FINAL RESULT ===\")\n    print(f\"{{{{hero}}}}: {player_a_score}\")\n    print(f\"{{{{villain}}}}: {player_b_score}\")\n\n    if player_a_score >= player_b_score:  # BUG 3: Should be > for hero win, = is tie\n        print(f\"{{{{villain}}}} wins!\")\n    else:\n        print(f\"{{{{hero}}}} wins!\")\n\n\n# ✏️ FIX THE CODE BELOW ✏️\ndef fixed_match():\n    \"\"\"\n    Fix all 3 bugs from buggy_match().\n\n    Bug hints:\n    1. How many rounds should be played?\n    2. Is the score actually increasing?\n    3. What should happen when scores are equal?\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\n# ============================================================\n# PART 2: Training\n# ============================================================\n# {{CONTEXT_GROWTH_INTRO}}\n# {{CONTEXT_GROWTH_NARRATIVE}}\n#\n# {{hero}} needs a new ability: the POWER MOVE.\n#\n# A power move is high risk, high reward:\n# - 40% chance: CRITICAL SUCCESS (2 points!)\n# - 30% chance: Normal success (1 point)\n# - 30% chance: Fail (0 points)\n#\n# Implement the power move and a training loop to practice it.\n\n\ndef attempt_power_move():\n    \"\"\"\n    Attempt a risky power move.\n\n    Returns:\n        int: Points scored (0, 1, or 2)\n\n    Use random.random() which returns 0.0 to 1.0:\n    - 0.0 to 0.4 (40%): Critical success, return 2\n    - 0.4 to 0.7 (30%): Normal success, return 1\n    - 0.7 to 1.0 (30%): Fail, return 0\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef attempt_regular_move():\n    \"\"\"\n    Attempt a safe regular move.\n\n    Returns:\n        int: Points scored (0 or 1)\n\n    66% chance of success (1 point), 34% chance of fail (0 points).\n    \"\"\"\n    result = random.choice([\"success\", \"success\", \"fail\"])\n    if result == \"success\":\n        return 1\n    return 0\n\n\ndef training_session():\n    \"\"\"\n    Practice session where {{hero}} can try both move types.\n\n    Loop until the player types 'q' to quit:\n    - 'r' = regular move (safe)\n    - 'p' = power move (risky)\n    - 'q' = quit training\n\n    Track and display:\n    - Total points scored\n    - Number of attempts\n    - Success rate\n    \"\"\"\n    total_points = 0\n    attempts = 0\n\n    print(\"=== TRAINING SESSION ===\")\n    print(f\"{{{{hero}}}} practices for the rematch against {{{{villain}}}}.\")\n    print()\n    print(\"Commands: 'r' = regular move, 'p' = power move, 'q' = quit\")\n    print()\n\n    # ✏️ YOUR CODE HERE ✏️\n    # Implement the training loop:\n    # 1. Ask for input (r/p/q)\n    # 2. Execute the chosen move\n    # 3. Display result and running totals\n    # 4. Continue until 'q'\n    pass\n\n    print()\n    print(\"=== TRAINING COMPLETE ===\")\n    print(f\"Total points: {total_points}\")\n    print(f\"Attempts: {attempts}\")\n    if attempts > 0:\n        print(f\"Average: {total_points / attempts:.2f} points per attempt\")\n\n\n# ============================================================\n# PART 3: The Showdown\n# ============================================================\n# {{CONTEXT_CONFRONTATION_INTRO}}\n# {{CONTEXT_CONFRONTATION_NARRATIVE}}\n#\n# The rematch! Build the complete showdown:\n# - 5 rounds of competition\n# - {{hero}} can choose regular or power move each round\n# - {{villain}} always uses regular moves\n# - If tied after 5 rounds: sudden death until someone leads\n#\n# Use everything you've learned. This is the final test.\n\n\ndef player_a_turn():\n    \"\"\"\n    {{hero}}'s turn. Ask for move type and execute.\n\n    Returns:\n        int: Points scored\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef player_b_turn():\n    \"\"\"\n    {{villain}}'s turn. Always uses regular move.\n\n    Returns:\n        int: Points scored\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef play_round(round_num, player_a_score, player_b_score):\n    \"\"\"\n    Play one round of the showdown.\n\n    Args:\n        round_num: Current round number\n        player_a_score: {{hero}}'s current score\n        player_b_score: {{villain}}'s current score\n\n    Returns:\n        tuple: (hero_points_this_round, villain_points_this_round)\n    \"\"\"\n    print(f\"--- Round {round_num} ---\")\n    print(f\"Score: {{{{hero}}}} {player_a_score} - {player_b_score} {{{{villain}}}}\")\n\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef the_showdown():\n    \"\"\"\n    The complete championship match!\n\n    Structure:\n    1. Play 5 regular rounds\n    2. If tied: sudden death rounds until someone leads\n    3. Announce the winner with appropriate drama\n\n    Remember:\n    - {{hero}} chooses move type each turn\n    - {{villain}} always uses regular moves\n    - Display scores after each round\n    \"\"\"\n    print(\"=\" * 50)\n    print(\"   THE FINAL SHOWDOWN\")\n    print(f\"   {{{{hero}}}} vs {{{{villain}}}}\")\n    print(\"=\" * 50)\n    print()\n\n    player_a_score = 0\n    player_b_score = 0\n\n    # ✏️ YOUR CODE HERE ✏️\n    # 1. Main match: 5 rounds\n    # 2. Check for winner\n    # 3. If tied: sudden death\n    # 4. Announce winner\n    pass\n\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_SETBACK_INTRO}}\")\n    print(\"=\" * 60)\n    print()\n\n    print(\">>> PART 1: Analyzing the defeat...\")\n    print(\"(Review buggy_match() and implement fixed_match())\")\n    print()\n    # Uncomment to test:\n    # fixed_match()\n\n    print()\n    print(\">>> PART 2: Training begins...\")\n    print(\"(Implement attempt_power_move() and training_session())\")\n    print()\n    # Uncomment to test:\n    # training_session()\n\n    print()\n    print(\">>> PART 3: The showdown awaits...\")\n    print(\"(Implement all showdown functions)\")\n    print()\n    # Uncomment to test:\n    # the_showdown()\n\n    print()\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_TRIUMPH_COMPLETE}}\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "hybrid"
      ],
      "source_file": "module_5_games/hybrid/exercise_1_rivalry_loop_duel.py"
    },
    {
      "id": "module_5_games.hybrid.exercise_3_rivalry_guessing",
      "topic_id": "loops.while",
      "exercise_type": "hybrid",
      "category": "hybrid",
      "title": "Rivalry Guessing",
      "title_en": "Rivalry Guessing",
      "title_he": "Rivalry Guessing",
      "description_en": "Games: Rivalry Guessing\n\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise following the journey to build a number guessing game.\nComplete each part in order.\n\nProgramming concepts: while loops, random, comparisons, input validation",
      "description_he": "משחקים: Rivalry Guessing\n\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise following the journey to build a number guessing game.\nComplete each part in order.\n\nProgramming concepts: while loops, random, comparisons, input validation",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "mental_execution",
        "syntax_recall",
        "implementation",
        "pattern_recognition",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise following the journey to build a number guessing game.\nComplete each part in order.\n\nProgramming concepts: while loops, random, comparisons, input validation\n\"\"\"\n\nimport random\n\n\n# ============================================================\n# PART 1: The Broken Game\n# ============================================================\n# {{CONTEXT_SETBACK_NARRATIVE}}\n#\n# {{hero}}'s first attempt at a guessing game had bugs.\n# {{villain}} found all the flaws and exploited them!\n#\n# Find and fix the 3 bugs in the code below.\n#\n# BUGS TO FIND: 3\n\n\ndef buggy_guessing_game():\n    \"\"\"\n    A buggy guessing game. Find the 3 bugs!\n\n    BUG 1: The secret number range is wrong\n    BUG 2: The comparison logic is inverted\n    BUG 3: The guess counter never increases\n    \"\"\"\n    secret = random.randint(0, 9)  # BUG 1: Should be 1-10, not 0-9\n    guesses = 0\n    max_guesses = 5\n\n    print(\"Guess my number (1-10)!\")\n\n    while guesses < max_guesses:\n        guess_str = input(\"Your guess: \")\n\n        if not guess_str.isdigit():\n            print(\"Please enter a number!\")\n            continue\n\n        guess = int(guess_str)\n\n        if guess < secret:  # BUG 2: Logic inverted! < should give \"higher\" hint\n            print(\"Go lower!\")\n        elif guess > secret:\n            print(\"Go higher!\")\n        else:\n            print(f\"Correct! You got it in {guesses} guesses!\")\n            return True\n        # BUG 3: guesses is never incremented!\n\n    print(f\"Out of guesses! The number was {secret}\")\n    return False\n\n\ndef fixed_guessing_game():\n    \"\"\"\n    Fix all 3 bugs from the buggy version.\n\n    Bug fixes needed:\n    1. Secret number should be 1-10 (inclusive)\n    2. Hints should be correct (guess < secret means \"go higher\")\n    3. Increment guesses after each guess\n    \"\"\"\n    # ✏️ FIX THE BUGS ✏️\n    #\n    # What I found:\n    # Bug 1: ________________________________\n    # Bug 2: ________________________________\n    # Bug 3: ________________________________\n    pass\n\n\n# ============================================================\n# PART 2: Building Better\n# ============================================================\n# {{CONTEXT_GROWTH_INTRO}}\n# {{CONTEXT_GROWTH_NARRATIVE}}\n#\n# Now build a proper guessing game with these features:\n# - Configurable range (min to max)\n# - Unlimited guesses\n# - Track guess count\n# - Validate input is within range\n\n\ndef validate_guess(guess_str, min_val, max_val):\n    \"\"\"\n    Validate that a guess string is a valid number within range.\n\n    Args:\n        guess_str: The string input from user\n        min_val: Minimum valid value\n        max_val: Maximum valid value\n\n    Returns:\n        tuple: (is_valid, value_or_error_message)\n            - If valid: (True, integer_value)\n            - If invalid: (False, error_message)\n\n    Examples:\n        validate_guess(\"5\", 1, 10) returns (True, 5)\n        validate_guess(\"abc\", 1, 10) returns (False, \"Not a number\")\n        validate_guess(\"15\", 1, 10) returns (False, \"Out of range (1-10)\")\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Check if guess_str is a digit (use .lstrip('-').isdigit() for negatives)\n    #         If not, return (False, \"Not a number\")\n    # Step 2: Convert to integer\n    # Step 3: Check if in range\n    #         If not, return (False, f\"Out of range ({min_val}-{max_val})\")\n    # Step 4: Return (True, integer_value)\n    pass\n\n\ndef give_hint(guess, secret):\n    \"\"\"\n    Give a hint based on the guess.\n\n    Args:\n        guess: The player's guess\n        secret: The secret number\n\n    Returns:\n        str: \"higher\", \"lower\", or \"correct\"\n\n    Also prints an appropriate message:\n        \"Too low! Guess higher.\"\n        \"Too high! Guess lower.\"\n        \"{{exclamation}} Correct!\"\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Compare guess to secret and return/print appropriate response\n    pass\n\n\ndef play_guessing_round(min_val, max_val):\n    \"\"\"\n    Play one round of the guessing game.\n\n    Args:\n        min_val: Minimum value for secret number\n        max_val: Maximum value for secret number\n\n    Returns:\n        int: Number of guesses it took to win\n\n    Game flow:\n    1. Generate secret number\n    2. Loop: get guess, validate, give hint\n    3. Continue until correct\n    4. Return guess count\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Generate secret with random.randint(min_val, max_val)\n    # Step 2: Initialize guess_count = 0\n    # Step 3: Loop until guessed correctly:\n    #         - Get input\n    #         - Validate with validate_guess()\n    #         - If invalid, print error and continue\n    #         - Increment guess_count\n    #         - Get hint with give_hint()\n    #         - If correct, break\n    # Step 4: Return guess_count\n    pass\n\n\n# ============================================================\n# PART 3: The Championship\n# ============================================================\n# {{CONTEXT_CONFRONTATION_INTRO}}\n# {{CONTEXT_CONFRONTATION_NARRATIVE}}\n#\n# Build the complete championship guessing game:\n# - Best of 3 rounds\n# - Track wins for {{hero}} and {{villain}}\n# - {{villain}} guesses using a simple strategy\n# - Whoever guesses in fewer tries wins the round\n\n\ndef computer_guess(min_val, max_val, secret):\n    \"\"\"\n    Simulate {{villain}}'s guessing strategy (binary search).\n\n    Args:\n        min_val: Current minimum possibility\n        max_val: Current maximum possibility\n        secret: The secret number (to determine result)\n\n    Returns:\n        tuple: (guess, new_min, new_max)\n\n    Strategy: Always guess the middle value\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Calculate middle = (min_val + max_val) // 2\n    # Step 2: If middle < secret, new range is (middle + 1, max_val)\n    # Step 3: If middle > secret, new range is (min_val, middle - 1)\n    # Step 4: Return (middle, new_min, new_max)\n    pass\n\n\ndef computer_play_round(min_val, max_val):\n    \"\"\"\n    {{villain}} plays a guessing round using binary search.\n\n    Args:\n        min_val: Minimum value\n        max_val: Maximum value\n\n    Returns:\n        int: Number of guesses to find the secret\n    \"\"\"\n    secret = random.randint(min_val, max_val)\n    guesses = 0\n    current_min = min_val\n    current_max = max_val\n\n    print(f\"\\n{{{{villain}}}}'s turn! (Secret: {secret})\")\n\n    while True:\n        guess, current_min, current_max = computer_guess(\n            current_min, current_max, secret\n        )\n        guesses += 1\n        print(f\"{{{{villain}}}} guesses: {guess}\")\n\n        if guess == secret:\n            print(f\"{{{{villain}}}} got it in {guesses} guesses!\")\n            return guesses\n        elif guess < secret:\n            print(\"Too low...\")\n        else:\n            print(\"Too high...\")\n\n\ndef championship_match():\n    \"\"\"\n    The championship: {{hero}} vs {{villain}} in best of 3!\n\n    Game structure:\n    - 3 rounds, each with range 1-100\n    - Each round: both players guess a NEW secret number\n    - Fewer guesses wins the round\n    - First to 2 round wins takes the championship\n\n    Display:\n    - Current score before each round\n    - Winner of each round\n    - Final champion announcement\n    \"\"\"\n    print(\"=\" * 50)\n    print(\"   GUESSING CHAMPIONSHIP\")\n    print(f\"   {{{{hero}}}} vs {{{{villain}}}}\")\n    print(\"=\" * 50)\n    print()\n\n    hero_wins = 0\n    villain_wins = 0\n    round_num = 0\n\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # While neither player has 2 wins:\n    #   1. Increment round number\n    #   2. Print round header and current score\n    #   3. {{hero}} guesses (use play_guessing_round)\n    #   4. {{villain}} guesses (use computer_play_round)\n    #   5. Compare guess counts, award point to winner\n    #   6. Announce round winner\n    #\n    # After loop: Announce championship winner\n    pass\n\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_SETBACK_INTRO}}\")\n    print(\"=\" * 60)\n    print()\n\n    print(\">>> PART 1: Fix the broken game...\")\n    print(\"(Review buggy_guessing_game() and implement fixed_guessing_game())\")\n    print()\n    # Uncomment to test:\n    # fixed_guessing_game()\n\n    print()\n    print(\">>> PART 2: Build better validation and hints...\")\n    print(\"(Implement validate_guess, give_hint, play_guessing_round)\")\n    print()\n    # Uncomment to test:\n    # guesses = play_guessing_round(1, 20)\n    # print(f\"You won in {guesses} guesses!\")\n\n    print()\n    print(\">>> PART 3: The Championship awaits...\")\n    print(\"(Implement computer_guess and championship_match)\")\n    print()\n    # Uncomment to test:\n    # championship_match()\n\n    print()\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_TRIUMPH_COMPLETE}}\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "hybrid"
      ],
      "source_file": "module_5_games/hybrid/exercise_3_rivalry_guessing.py"
    },
    {
      "id": "module_5_games.write_code.exercise_1_basic_while",
      "topic_id": "loops.while",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Basic While",
      "title_en": "Basic While",
      "title_he": "Basic While",
      "description_en": "Games: Basic While\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Basic while loops with counter variables\nDifficulty: 1-2\n\nIn this exercise, you'll learn the fundamental pattern of while loops:\nsetting up a counter, checking a condition, and updating the counter.",
      "description_he": "משחקים: Basic While\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Basic while loops with counter variables\nDifficulty: 1-2\n\nIn this exercise, you'll learn the fundamental pattern of while loops:\nsetting up a counter, checking a condition, and updating the counter.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Basic while loops with counter variables\nDifficulty: 1-2\n\nIn this exercise, you'll learn the fundamental pattern of while loops:\nsetting up a counter, checking a condition, and updating the counter.\n\"\"\"\n\n\n# ============================================================\n# {{PHASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n#\n# A while loop repeats as long as its condition is True.\n# The pattern: initialize -> check condition -> do work -> update\n\n\ndef countdown_from_five():\n    \"\"\"\n    Print a countdown from 5 to 1, then print a final message.\n\n    Expected output:\n        5\n        4\n        3\n        2\n        1\n        {{exclamation}}\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create a variable called 'count' starting at 5\n    # Step 2: While count is greater than 0:\n    #         - Print the current count\n    #         - Decrease count by 1\n    # Step 3: After the loop, print \"{{exclamation}}\"\n    #\n    # Hint: Don't forget to decrease count, or the loop never ends!\n    pass\n\n\n# ============================================================\n# {{PHASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n#\n# While loops are perfect for counting up to a target.\n\n\ndef count_up_to(target):\n    \"\"\"\n    Print numbers from 1 up to and including target.\n\n    Args:\n        target: The number to count up to\n\n    Example:\n        count_up_to(4) prints:\n        1\n        2\n        3\n        4\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create a variable called 'current' starting at 1\n    # Step 2: While current is less than or equal to target:\n    #         - Print current\n    #         - Increase current by 1\n    pass\n\n\n# ============================================================\n# {{PHASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n#\n# While loops can track totals as they iterate.\n\n\ndef sum_until_limit(limit):\n    \"\"\"\n    Add numbers 1, 2, 3, ... until the sum would exceed the limit.\n    Return the sum and how many numbers were added.\n\n    Args:\n        limit: Stop before the sum exceeds this value\n\n    Returns:\n        tuple: (final_sum, count_of_numbers)\n\n    Example:\n        sum_until_limit(10) returns (10, 4)\n        Because: 1+2+3+4=10, and 1+2+3+4+5=15 would exceed 10\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Initialize total = 0, next_number = 1, count = 0\n    # Step 2: While total + next_number <= limit:\n    #         - Add next_number to total\n    #         - Increase count by 1\n    #         - Increase next_number by 1\n    # Step 3: Return (total, count)\n    pass\n\n\n# ============================================================\n# {{PHASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n#\n# While loops with multiple conditions using 'and' or 'or'.\n\n\ndef process_batch(items_to_process, max_iterations):\n    \"\"\"\n    Process items one at a time, but stop early if you run out of items\n    OR if you reach max_iterations.\n\n    Args:\n        items_to_process: Starting number of items\n        max_iterations: Maximum number of processing rounds\n\n    Returns:\n        tuple: (items_processed, iterations_used)\n\n    Example:\n        process_batch(3, 10) returns (3, 3)  # Ran out of items\n        process_batch(100, 5) returns (5, 5)  # Hit iteration limit\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Initialize items_left = items_to_process, iterations = 0\n    # Step 2: While items_left > 0 AND iterations < max_iterations:\n    #         - Decrease items_left by 1\n    #         - Increase iterations by 1\n    #         - Print f\"Processed item. {items_left} remaining.\"\n    # Step 3: Return (iterations, iterations)  # items processed = iterations\n    pass\n\n\n# ============================================================\n# {{PHASE_5_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_5}}\n#\n# Accumulating results in a list while looping.\n\n\ndef generate_sequence(start, multiplier, length):\n    \"\"\"\n    Generate a sequence where each number is the previous times multiplier.\n\n    Args:\n        start: First number in sequence\n        multiplier: What to multiply by each time\n        length: How many numbers to generate\n\n    Returns:\n        list: The generated sequence\n\n    Example:\n        generate_sequence(2, 3, 4) returns [2, 6, 18, 54]\n        Because: 2, 2*3=6, 6*3=18, 18*3=54\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create an empty list called 'sequence'\n    # Step 2: Set current = start\n    # Step 3: While len(sequence) < length:\n    #         - Append current to sequence\n    #         - Multiply current by multiplier\n    # Step 4: Return sequence\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{PHASE_1_TITLE}} ===\")\n    print(\"Countdown:\")\n    countdown_from_five()\n\n    print(\"\\n=== {{PHASE_2_TITLE}} ===\")\n    print(\"Counting to 5:\")\n    count_up_to(5)\n\n    print(\"\\n=== {{PHASE_3_TITLE}} ===\")\n    result = sum_until_limit(10)\n    print(f\"Sum until 10: {result}\")\n\n    print(\"\\n=== {{PHASE_4_TITLE}} ===\")\n    print(\"Processing batch of 7 items with max 5 iterations:\")\n    result = process_batch(7, 5)\n    print(f\"Result: {result}\")\n\n    print(\"\\n=== {{PHASE_5_TITLE}} ===\")\n    seq = generate_sequence(2, 3, 5)\n    print(f\"Sequence: {seq}\")\n\n    print(\"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "write_code"
      ],
      "source_file": "module_5_games/write_code/exercise_1_basic_while.py"
    },
    {
      "id": "module_5_games.write_code.exercise_2_break_loops",
      "topic_id": "loops.while",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Break Loops",
      "title_en": "Break Loops",
      "title_he": "Break Loops",
      "description_en": "Games: Break Loops\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using break to exit loops early\nDifficulty: 2-3\n\nThe 'break' statement immediately exits the current loop.\nUse it when you've found what you're looking for or need to stop early.",
      "description_he": "משחקים: Break Loops\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using break to exit loops early\nDifficulty: 2-3\n\nThe 'break' statement immediately exits the current loop.\nUse it when you've found what you're looking for or need to stop early.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using break to exit loops early\nDifficulty: 2-3\n\nThe 'break' statement immediately exits the current loop.\nUse it when you've found what you're looking for or need to stop early.\n\"\"\"\n\n\n# ============================================================\n# {{PHASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n#\n# Use break to exit a loop when a condition is met.\n\n\ndef find_first_negative(numbers):\n    \"\"\"\n    Find the first negative number in a list.\n\n    Args:\n        numbers: A list of integers\n\n    Returns:\n        The first negative number, or None if all are non-negative\n\n    Example:\n        find_first_negative([3, 7, -2, 5, -8]) returns -2\n        find_first_negative([1, 2, 3]) returns None\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Set result = None\n    # Step 2: Loop through each number in numbers\n    # Step 3: If the number is negative:\n    #         - Set result to that number\n    #         - Break out of the loop\n    # Step 4: Return result\n    pass\n\n\n# ============================================================\n# {{PHASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n#\n# Use break with user input to create exit conditions.\n\n\ndef collect_names_until_done():\n    \"\"\"\n    Collect names from the user until they type 'done'.\n\n    Returns:\n        list: All the names collected (not including 'done')\n\n    The function should:\n    - Ask \"Enter a name (or 'done' to finish): \"\n    - Keep asking until user types 'done'\n    - Return the list of names collected\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create an empty list for names\n    # Step 2: Start an infinite loop (while True)\n    # Step 3: Ask for input\n    # Step 4: If input is 'done', break\n    # Step 5: Otherwise, add the name to the list\n    # Step 6: After the loop, return the list\n    pass\n\n\n# ============================================================\n# {{PHASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n#\n# Use break in a search to stop once you find the target.\n\n\ndef search_inventory(inventory, target):\n    \"\"\"\n    Search for a target item in an inventory.\n    Print each item checked, and stop when found.\n\n    Args:\n        inventory: List of items\n        target: Item to find\n\n    Returns:\n        int: Index where found, or -1 if not found\n\n    Example:\n        search_inventory([\"{{item}}\", \"{{pet}}\", \"{{creature}}\"], \"{{pet}}\")\n        Prints:\n            Checking: {{item}}\n            Checking: {{pet}}\n            Found {{pet}}!\n        Returns: 1\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Loop through inventory with index (use range(len(...)))\n    # Step 2: Print f\"Checking: {item}\"\n    # Step 3: If item equals target:\n    #         - Print f\"Found {target}!\"\n    #         - Return the index (using break or direct return)\n    # Step 4: After the loop, print f\"{target} not found.\"\n    # Step 5: Return -1\n    pass\n\n\n# ============================================================\n# {{PHASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n#\n# Use break with a counter limit to prevent infinite loops.\n\n\ndef safe_guess_loop():\n    \"\"\"\n    Let the user guess a secret word with a maximum of 5 attempts.\n\n    The secret word is \"{{password}}\".\n\n    Returns:\n        bool: True if guessed correctly, False if ran out of attempts\n\n    The function should:\n    - Give the user up to 5 attempts\n    - If they guess correctly, print a success message and return True\n    - If they run out of attempts, print failure message and return False\n    \"\"\"\n    secret = \"{{password}}\"\n    max_attempts = 5\n\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Set attempts = 0\n    # Step 2: While attempts < max_attempts:\n    #         - Increase attempts\n    #         - Ask for a guess\n    #         - If guess equals secret, print success and return True\n    # Step 3: After the loop, print failure message\n    # Step 4: Return False\n    pass\n\n\n# ============================================================\n# {{PHASE_5_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_5}}\n#\n# Combine break with complex conditions.\n\n\ndef process_until_error(data):\n    \"\"\"\n    Process data items until you encounter an error value.\n    Error values are: \"ERROR\", \"\", or None.\n\n    Args:\n        data: List of values to process\n\n    Returns:\n        list: Successfully processed values (before the error)\n\n    Example:\n        process_until_error([\"a\", \"b\", \"ERROR\", \"c\"]) returns [\"A\", \"B\"]\n        (Values are uppercased during processing, stops at ERROR)\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create an empty list for results\n    # Step 2: Loop through each item in data\n    # Step 3: If item is \"ERROR\", \"\", or None:\n    #         - Print f\"Error encountered! Stopping.\"\n    #         - Break\n    # Step 4: Process the item (convert to uppercase) and add to results\n    #         - Print f\"Processed: {processed_item}\"\n    # Step 5: Return results\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{PHASE_1_TITLE}} ===\")\n    numbers = [5, 12, 8, -3, 7, -1]\n    result = find_first_negative(numbers)\n    print(f\"First negative in {numbers}: {result}\")\n\n    print(\"\\n=== {{PHASE_2_TITLE}} ===\")\n    print(\"Collecting names (type 'done' to finish):\")\n    # Uncomment to test:\n    # names = collect_names_until_done()\n    # print(f\"Collected: {names}\")\n\n    print(\"\\n=== {{PHASE_3_TITLE}} ===\")\n    inventory = [\"{{item}}\", \"{{pet}}\", \"{{creature}}\", \"{{transport}}\"]\n    index = search_inventory(inventory, \"{{creature}}\")\n    print(f\"Found at index: {index}\")\n\n    print(\"\\n=== {{PHASE_4_TITLE}} ===\")\n    print(\"Guess the secret word:\")\n    # Uncomment to test:\n    # success = safe_guess_loop()\n    # print(f\"Result: {'Success!' if success else 'Failed'}\")\n\n    print(\"\\n=== {{PHASE_5_TITLE}} ===\")\n    test_data = [\"{{hero}}\", \"{{heroine}}\", \"ERROR\", \"{{friend}}\"]\n    processed = process_until_error(test_data)\n    print(f\"Processed items: {processed}\")\n\n    print(\"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "write_code"
      ],
      "source_file": "module_5_games/write_code/exercise_2_break_loops.py"
    },
    {
      "id": "module_5_games.write_code.exercise_3_continue_loops",
      "topic_id": "loops.while",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Continue Loops",
      "title_en": "Continue Loops",
      "title_he": "Continue Loops",
      "description_en": "Games: Continue Loops\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using continue to skip iterations\nDifficulty: 2-3\n\nThe 'continue' statement skips the rest of the current iteration\nand moves to the next one. Use it to skip unwanted items.",
      "description_he": "משחקים: Continue Loops\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using continue to skip iterations\nDifficulty: 2-3\n\nThe 'continue' statement skips the rest of the current iteration\nand moves to the next one. Use it to skip unwanted items.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using continue to skip iterations\nDifficulty: 2-3\n\nThe 'continue' statement skips the rest of the current iteration\nand moves to the next one. Use it to skip unwanted items.\n\"\"\"\n\n\n# ============================================================\n# {{PHASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n#\n# Use continue to skip items that don't match criteria.\n\n\ndef print_positive_only(numbers):\n    \"\"\"\n    Print only the positive numbers from a list.\n    Skip zeros and negative numbers using continue.\n\n    Args:\n        numbers: A list of integers\n\n    Example:\n        print_positive_only([3, -1, 0, 5, -2, 8])\n        Prints:\n            3\n            5\n            8\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Loop through each number in numbers\n    # Step 2: If number is less than or equal to 0, continue\n    # Step 3: Print the number\n    pass\n\n\n# ============================================================\n# {{PHASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n#\n# Use continue to filter during processing.\n\n\ndef filter_and_transform(items):\n    \"\"\"\n    Process items but skip any that are empty strings.\n    Transform valid items to uppercase.\n\n    Args:\n        items: A list of strings\n\n    Returns:\n        list: Uppercase versions of non-empty strings\n\n    Example:\n        filter_and_transform([\"{{hero}}\", \"\", \"{{villain}}\", \"\"])\n        Returns: [\"{{HERO}}\", \"{{VILLAIN}}\"]  # (uppercase versions)\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create an empty result list\n    # Step 2: Loop through each item\n    # Step 3: If item is an empty string \"\", continue\n    # Step 4: Convert to uppercase and add to result\n    # Step 5: Return result\n    pass\n\n\n# ============================================================\n# {{PHASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n#\n# Use continue with index-based loops.\n\n\ndef process_every_other(values):\n    \"\"\"\n    Process only items at even indices (0, 2, 4, ...).\n    Skip items at odd indices using continue.\n\n    Args:\n        values: A list of values\n\n    Returns:\n        list: Items from even indices only\n\n    Example:\n        process_every_other([\"A\", \"B\", \"C\", \"D\", \"E\"])\n        Returns: [\"A\", \"C\", \"E\"]  # indices 0, 2, 4\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create an empty result list\n    # Step 2: Loop with index: for i in range(len(values))\n    # Step 3: If i is odd (i % 2 != 0), continue\n    # Step 4: Add values[i] to result\n    # Step 5: Return result\n    pass\n\n\n# ============================================================\n# {{PHASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n#\n# Combine continue with while loops.\n\n\ndef sum_valid_inputs():\n    \"\"\"\n    Collect numbers from user and sum them.\n    Skip invalid inputs (non-numeric) using continue.\n    Stop when user enters 'done'.\n\n    Returns:\n        int: Sum of all valid numbers entered\n\n    The function should:\n    - Ask for input repeatedly\n    - If input is 'done', stop and return the sum\n    - If input is not a valid integer, print error and continue\n    - If input is valid, add to sum\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Set total = 0\n    # Step 2: While True:\n    #         - Get input\n    #         - If input is 'done', break\n    #         - If input.isdigit() or (input.startswith('-') and input[1:].isdigit()):\n    #           Add int(input) to total\n    #         - Else: print \"Invalid number, skipping.\" and continue\n    # Step 3: Return total\n    #\n    # Note: Use .lstrip('-').isdigit() to check for negative numbers\n    pass\n\n\n# ============================================================\n# {{PHASE_5_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_5}}\n#\n# Use continue with complex skip conditions.\n\n\ndef process_approved_items(items, blocked_list):\n    \"\"\"\n    Process items unless they are in the blocked list.\n    Skip blocked items using continue.\n\n    Args:\n        items: List of items to process\n        blocked_list: List of items to skip\n\n    Returns:\n        list: Processed (lowercase) items that weren't blocked\n\n    Example:\n        process_approved_items(\n            [\"{{hero}}\", \"{{villain}}\", \"{{friend}}\"],\n            [\"{{villain}}\"]\n        )\n        Returns: [\"{{hero}}\", \"{{friend}}\"]  # lowercase versions\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create an empty result list\n    # Step 2: Loop through each item\n    # Step 3: If item is in blocked_list:\n    #         - Print f\"Blocked: {item}\"\n    #         - Continue\n    # Step 4: Process item (convert to lowercase) and add to result\n    #         - Print f\"Approved: {item}\"\n    # Step 5: Return result\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{PHASE_1_TITLE}} ===\")\n    numbers = [5, -3, 0, 8, -1, 12, 0, -7]\n    print(f\"Numbers: {numbers}\")\n    print(\"Positive only:\")\n    print_positive_only(numbers)\n\n    print(\"\\n=== {{PHASE_2_TITLE}} ===\")\n    items = [\"{{hero}}\", \"\", \"{{villain}}\", \"\", \"{{friend}}\"]\n    result = filter_and_transform(items)\n    print(f\"Filtered and transformed: {result}\")\n\n    print(\"\\n=== {{PHASE_3_TITLE}} ===\")\n    values = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]\n    result = process_every_other(values)\n    print(f\"Every other item: {result}\")\n\n    print(\"\\n=== {{PHASE_4_TITLE}} ===\")\n    print(\"Sum numbers (type 'done' to finish):\")\n    # Uncomment to test:\n    # total = sum_valid_inputs()\n    # print(f\"Sum: {total}\")\n\n    print(\"\\n=== {{PHASE_5_TITLE}} ===\")\n    all_items = [\"{{hero}}\", \"{{villain}}\", \"{{friend}}\", \"{{mentor}}\"]\n    blocked = [\"{{villain}}\"]\n    result = process_approved_items(all_items, blocked)\n    print(f\"Approved items: {result}\")\n\n    print(\"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "write_code"
      ],
      "source_file": "module_5_games/write_code/exercise_3_continue_loops.py"
    },
    {
      "id": "module_5_games.write_code.exercise_4_random_basics",
      "topic_id": "loops.while",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Random Basics",
      "title_en": "Random Basics",
      "title_he": "Random Basics",
      "description_en": "Games: Random Basics\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using the random module\nDifficulty: 2-3\n\nThe random module lets you generate random numbers and make random choices.\nEssential for games with unpredictable elements!",
      "description_he": "משחקים: Random Basics\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using the random module\nDifficulty: 2-3\n\nThe random module lets you generate random numbers and make random choices.\nEssential for games with unpredictable elements!",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using the random module\nDifficulty: 2-3\n\nThe random module lets you generate random numbers and make random choices.\nEssential for games with unpredictable elements!\n\"\"\"\n\nimport random\n\n\n# ============================================================\n# {{PHASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n#\n# random.randint(a, b) returns a random integer from a to b INCLUSIVE.\n# Unlike range(), both endpoints are included!\n\n\ndef roll_dice(num_sides):\n    \"\"\"\n    Roll a single die with the given number of sides.\n\n    Args:\n        num_sides: Number of sides on the die (e.g., 6 for standard die)\n\n    Returns:\n        int: A random number from 1 to num_sides\n\n    Example:\n        roll_dice(6) might return 1, 2, 3, 4, 5, or 6\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Use random.randint(1, num_sides) to get a number from 1 to num_sides\n    pass\n\n\ndef roll_multiple_dice(num_dice, num_sides):\n    \"\"\"\n    Roll multiple dice and return the total.\n\n    Args:\n        num_dice: How many dice to roll\n        num_sides: Number of sides per die\n\n    Returns:\n        int: Sum of all dice rolls\n\n    Example:\n        roll_multiple_dice(2, 6) might return any value from 2 to 12\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Initialize total = 0\n    # Step 2: Loop num_dice times\n    # Step 3: Add a random roll to total\n    # Step 4: Return total\n    pass\n\n\n# ============================================================\n# {{PHASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n#\n# random.choice(sequence) picks a random item from a list or string.\n\n\ndef pick_random_item(items):\n    \"\"\"\n    Pick a random item from a list.\n\n    Args:\n        items: A non-empty list\n\n    Returns:\n        A randomly selected item from the list\n\n    Example:\n        pick_random_item([\"{{hero}}\", \"{{villain}}\", \"{{friend}}\"])\n        might return any of those three names\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Use random.choice(items)\n    pass\n\n\ndef generate_random_name():\n    \"\"\"\n    Generate a random name by combining a random adjective and noun.\n\n    Returns:\n        str: A randomly generated name like \"Swift {{creature}}\"\n\n    Use these lists:\n        adjectives = [\"Swift\", \"Brave\", \"Clever\", \"Mighty\", \"Silent\"]\n        nouns = [\"{{creature}}\", \"{{hero}}\", \"{{villain}}\"]\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create the adjectives list\n    # Step 2: Create the nouns list\n    # Step 3: Pick random adjective with random.choice()\n    # Step 4: Pick random noun with random.choice()\n    # Step 5: Return f\"{adjective} {noun}\"\n    pass\n\n\n# ============================================================\n# {{PHASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n#\n# random.random() returns a float from 0.0 to 1.0 (exclusive).\n# Useful for percentage-based chances.\n\n\ndef chance_event(probability):\n    \"\"\"\n    Return True with the given probability, False otherwise.\n\n    Args:\n        probability: Float from 0.0 to 1.0 (e.g., 0.7 for 70% chance)\n\n    Returns:\n        bool: True if the event happens, False otherwise\n\n    Example:\n        chance_event(0.5) returns True about 50% of the time\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # If random.random() < probability, return True\n    # Otherwise return False\n    pass\n\n\ndef attempt_action(success_rate):\n    \"\"\"\n    Attempt an action that might succeed or fail.\n\n    Args:\n        success_rate: Float from 0.0 to 1.0 (chance of success)\n\n    Returns:\n        str: \"success\" or \"failure\"\n\n    Also prints the result:\n        \"{{exclamation}} Success!\" or \"Failed...\"\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Use chance_event() to determine if successful\n    # Print the appropriate message\n    # Return \"success\" or \"failure\"\n    pass\n\n\n# ============================================================\n# {{PHASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n#\n# Combine random functions to create game mechanics.\n\n\ndef weighted_random_choice(options, weights):\n    \"\"\"\n    Choose from options with weighted probabilities.\n\n    Args:\n        options: List of choices\n        weights: List of weights (must sum to 1.0)\n\n    Returns:\n        A randomly chosen option based on weights\n\n    Example:\n        weighted_random_choice([\"common\", \"rare\", \"legendary\"], [0.7, 0.25, 0.05])\n        Returns \"common\" 70%, \"rare\" 25%, \"legendary\" 5%\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Get a random float with random.random()\n    # Step 2: Track cumulative probability\n    # Step 3: Loop through options and weights together\n    #         - Add weight to cumulative\n    #         - If random value < cumulative, return that option\n    # Step 4: Return last option (safety fallback)\n    #\n    # Hint: Use zip(options, weights) to loop through both\n    pass\n\n\ndef generate_loot():\n    \"\"\"\n    Generate random loot with rarities.\n\n    Returns:\n        tuple: (item_name, rarity)\n\n    Rarities:\n        - \"common\" (60% chance)\n        - \"uncommon\" (25% chance)\n        - \"rare\" (12% chance)\n        - \"legendary\" (3% chance)\n\n    Use placeholder items based on rarity:\n        - common: \"{{item}}\"\n        - uncommon: \"Enhanced {{item}}\"\n        - rare: \"{{creature}}'s {{item}}\"\n        - legendary: \"{{hero}}'s Legendary {{item}}\"\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Define rarities and weights\n    # Step 2: Use weighted_random_choice to pick rarity\n    # Step 3: Create item name based on rarity\n    # Step 4: Return (item_name, rarity)\n    pass\n\n\n# ============================================================\n# {{PHASE_5_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_5}}\n#\n# Generate random numbers within ranges for game scenarios.\n\n\ndef generate_stats():\n    \"\"\"\n    Generate random stats for a character.\n\n    Returns:\n        dict: Character stats\n\n    Stats to generate:\n        - \"strength\": random 5-15\n        - \"agility\": random 5-15\n        - \"wisdom\": random 5-15\n        - \"luck\": random 1-10\n\n    Also calculate:\n        - \"power\": strength + agility\n        - \"total\": sum of all four base stats\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Generate each base stat with random.randint()\n    # Step 2: Calculate derived stats\n    # Step 3: Return dictionary with all stats\n    pass\n\n\ndef simulate_battle_round(attacker_power, defender_power):\n    \"\"\"\n    Simulate one round of battle between attacker and defender.\n\n    Args:\n        attacker_power: Attacker's power stat\n        defender_power: Defender's power stat\n\n    Returns:\n        tuple: (attacker_damage_dealt, defender_damage_dealt)\n\n    Damage formula:\n        base_damage = power // 3\n        actual_damage = base_damage + random.randint(0, 5)\n\n    Example:\n        simulate_battle_round(15, 12) might return (7, 6)\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Calculate attacker's damage\n    # Calculate defender's damage\n    # Return both as a tuple\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{PHASE_1_TITLE}} ===\")\n    print(f\"Rolling a 6-sided die: {roll_dice(6)}\")\n    print(f\"Rolling a 20-sided die: {roll_dice(20)}\")\n    print(f\"Rolling 3d6: {roll_multiple_dice(3, 6)}\")\n\n    print(\"\\n=== {{PHASE_2_TITLE}} ===\")\n    characters = [\"{{hero}}\", \"{{villain}}\", \"{{friend}}\", \"{{mentor}}\"]\n    print(f\"Random character: {pick_random_item(characters)}\")\n    print(f\"Random name: {generate_random_name()}\")\n\n    print(\"\\n=== {{PHASE_3_TITLE}} ===\")\n    print(\"Attempting action with 75% success rate:\")\n    attempt_action(0.75)\n\n    print(\"\\n=== {{PHASE_4_TITLE}} ===\")\n    print(\"Generating loot:\")\n    item, rarity = generate_loot()\n    print(f\"Found: {item} ({rarity})\")\n\n    print(\"\\n=== {{PHASE_5_TITLE}} ===\")\n    print(\"Generating character stats:\")\n    stats = generate_stats()\n    print(f\"Stats: {stats}\")\n    print(\"\\nSimulating battle round (power 15 vs 12):\")\n    atk_dmg, def_dmg = simulate_battle_round(15, 12)\n    print(f\"Attacker dealt {atk_dmg}, Defender dealt {def_dmg}\")\n\n    print(\"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "write_code"
      ],
      "source_file": "module_5_games/write_code/exercise_4_random_basics.py"
    }
  ]
}