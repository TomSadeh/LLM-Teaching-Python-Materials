{
  "version": "3.0.0",
  "theme_support": true,
  "generated_at": "2026-02-03T12:37:49.693815",
  "module": "module_5_games",
  "count": 18,
  "exercise_types": [
    "add_error_handling",
    "bug_hunt",
    "hybrid",
    "write_code"
  ],
  "exercises": [
    {
      "id": "module_5_games.add_error_handling.exercise_1_input_validation",
      "topic_id": "loops.while",
      "exercise_type": "add_error_handling",
      "category": "improvement",
      "title": "Input Validation",
      "title_en": "Input Validation",
      "title_he": "Input Validation",
      "description_en": "Games: Input Validation\n\n{{CONTEXT_ERROR_HANDLING_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Adding input validation loops\nDifficulty: 3\n\nInput validation ensures users provide valid data before proceeding.\nUse while loops with string checking to validate input.\n\nNOTE: We use while loops and string methods (like .isdigit()) for validation,\nnot try/except blocks. This teaches the fundamental pattern of validation loops.",
      "description_he": "משחקים: Input Validation\n\n{{CONTEXT_ERROR_HANDLING_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Adding input validation loops\nDifficulty: 3\n\nInput validation ensures users provide valid data before proceeding.\nUse while loops with string checking to validate input.\n\nNOTE: We use while loops and string methods (like .isdigit()) for validation,\nnot try/except blocks. This teaches the fundamental pattern of validation loops.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "defensive_programming",
        "exceptions",
        "robustness"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_ERROR_HANDLING_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Adding input validation loops\nDifficulty: 3\n\nInput validation ensures users provide valid data before proceeding.\nUse while loops with string checking to validate input.\n\nNOTE: We use while loops and string methods (like .isdigit()) for validation,\nnot try/except blocks. This teaches the fundamental pattern of validation loops.\n\"\"\"\n\n\n# ============================================================\n# {{HANDLING_1_TITLE}}\n# ============================================================\n# {{CONTEXT_HANDLING_1_NARRATIVE}}\n#\n# This function accepts any input and crashes on invalid numbers.\n\n\ndef original_get_number():\n    \"\"\"ORIGINAL: Crashes if user enters non-numeric text\"\"\"\n    user_input = input(\"Enter a number: \")\n    number = int(user_input)  # Crashes on \"abc\"!\n    return number\n\n\ndef safe_get_number():\n    \"\"\"\n    Get a valid integer from the user.\n    Keep asking until they enter a valid number.\n\n    Returns:\n        int: A valid integer entered by the user\n\n    Validation:\n    - If input is not numeric, print \"Please enter a valid number.\"\n    - Keep asking until valid\n    - Handle negative numbers (starts with '-')\n    \"\"\"\n    # ✏️ ADD VALIDATION LOOP ✏️\n    #\n    # {{CONTEXT_HANDLING_HINT_1}}\n    #\n    # Step 1: Start while True loop\n    # Step 2: Get input\n    # Step 3: Check if valid:\n    #         - For positive: input.isdigit()\n    #         - For negative: input.startswith('-') and input[1:].isdigit()\n    # Step 4: If valid, convert and return\n    # Step 5: If invalid, print error message (loop continues)\n    pass\n\n\n# ============================================================\n# {{HANDLING_2_TITLE}}\n# ============================================================\n# {{CONTEXT_HANDLING_2_NARRATIVE}}\n#\n# This function accepts numbers outside the valid range.\n\n\ndef original_get_score():\n    \"\"\"ORIGINAL: Accepts any number, even invalid scores\"\"\"\n    score = int(input(\"Enter score (0-100): \"))\n    return score\n\n\ndef safe_get_score():\n    \"\"\"\n    Get a valid score from 0 to 100.\n    Keep asking until input is valid.\n\n    Returns:\n        int: A score between 0 and 100 (inclusive)\n\n    Validation:\n    - Must be a number\n    - Must be between 0 and 100\n    \"\"\"\n    # ✏️ ADD VALIDATION LOOP ✏️\n    #\n    # {{CONTEXT_HANDLING_HINT_2}}\n    #\n    # Step 1: Start while True loop\n    # Step 2: Get input\n    # Step 3: Check if numeric (handle with .isdigit())\n    #         If not, print \"Please enter a number.\" and continue\n    # Step 4: Convert to int\n    # Step 5: Check if in range 0-100\n    #         If not, print \"Score must be between 0 and 100.\" and continue\n    # Step 6: Return valid score\n    pass\n\n\n# ============================================================\n# {{HANDLING_3_TITLE}}\n# ============================================================\n# {{CONTEXT_HANDLING_3_NARRATIVE}}\n#\n# This function accepts any text, even empty strings.\n\n\ndef original_get_name():\n    \"\"\"ORIGINAL: Accepts empty names\"\"\"\n    name = input(\"Enter your name: \")\n    return name\n\n\ndef safe_get_name():\n    \"\"\"\n    Get a non-empty name from the user.\n    Keep asking until they enter something.\n\n    Returns:\n        str: A non-empty, stripped name\n\n    Validation:\n    - Must not be empty after stripping whitespace\n    - Strip leading/trailing whitespace from result\n    \"\"\"\n    # ✏️ ADD VALIDATION LOOP ✏️\n    #\n    # {{CONTEXT_HANDLING_HINT_3}}\n    #\n    # Step 1: Start while True loop\n    # Step 2: Get input and strip whitespace\n    # Step 3: If empty string, print \"Name cannot be empty.\" and continue\n    # Step 4: Return the stripped name\n    pass\n\n\n# ============================================================\n# {{HANDLING_4_TITLE}}\n# ============================================================\n# {{CONTEXT_HANDLING_4_NARRATIVE}}\n#\n# This function accepts any choice, not just valid options.\n\n\ndef original_get_choice():\n    \"\"\"ORIGINAL: Accepts any choice, even invalid ones\"\"\"\n    print(\"Choose: (a) {{spell1}}, (b) {{spell2}}, (c) {{spell3}}\")\n    choice = input(\"Your choice: \")\n    return choice\n\n\ndef safe_get_choice():\n    \"\"\"\n    Get a valid choice from the user (a, b, or c).\n    Keep asking until valid.\n\n    Returns:\n        str: 'a', 'b', or 'c'\n\n    Validation:\n    - Must be exactly 'a', 'b', or 'c' (case insensitive)\n    - Show valid options in error message\n    \"\"\"\n    # ✏️ ADD VALIDATION LOOP ✏️\n    #\n    # {{CONTEXT_HANDLING_HINT_4}}\n    #\n    # Step 1: Define valid_choices = ['a', 'b', 'c']\n    # Step 2: Print the menu\n    # Step 3: Start while True loop\n    # Step 4: Get input and convert to lowercase\n    # Step 5: If choice in valid_choices, return it\n    # Step 6: Otherwise print \"Invalid choice. Please enter a, b, or c.\"\n    pass\n\n\n# ============================================================\n# {{HANDLING_5_TITLE}}\n# ============================================================\n# {{CONTEXT_HANDLING_5_NARRATIVE}}\n#\n# This yes/no function accepts any input.\n\n\ndef original_confirm():\n    \"\"\"ORIGINAL: Accepts any response as yes\"\"\"\n    response = input(\"Confirm? (yes/no): \")\n    return response == \"yes\"\n\n\ndef safe_confirm(prompt):\n    \"\"\"\n    Get a yes/no confirmation from the user.\n    Keep asking until they enter yes or no.\n\n    Args:\n        prompt: The question to ask\n\n    Returns:\n        bool: True for yes, False for no\n\n    Validation:\n    - Accept 'yes', 'y', 'no', 'n' (case insensitive)\n    - Keep asking for other inputs\n    \"\"\"\n    # ✏️ ADD VALIDATION LOOP ✏️\n    #\n    # {{CONTEXT_HANDLING_HINT_5}}\n    #\n    # Step 1: Start while True loop\n    # Step 2: Print prompt and get input (lowercase, stripped)\n    # Step 3: If response is 'yes' or 'y', return True\n    # Step 4: If response is 'no' or 'n', return False\n    # Step 5: Otherwise print \"Please enter yes or no.\"\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_ERROR_HANDLING_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{HANDLING_1_TITLE}} ===\")\n    print(\"Getting a valid number:\")\n    # number = safe_get_number()\n    # print(f\"You entered: {number}\")\n\n    print(\"\\n=== {{HANDLING_2_TITLE}} ===\")\n    print(\"Getting a valid score:\")\n    # score = safe_get_score()\n    # print(f\"Score recorded: {score}\")\n\n    print(\"\\n=== {{HANDLING_3_TITLE}} ===\")\n    print(\"Getting a valid name:\")\n    # name = safe_get_name()\n    # print(f\"Hello, {name}!\")\n\n    print(\"\\n=== {{HANDLING_4_TITLE}} ===\")\n    print(\"Getting a valid choice:\")\n    # choice = safe_get_choice()\n    # print(f\"You chose: {choice}\")\n\n    print(\"\\n=== {{HANDLING_5_TITLE}} ===\")\n    print(\"Getting confirmation:\")\n    # if safe_confirm(\"Do you want to continue? (yes/no): \"):\n    #     print(\"Continuing...\")\n    # else:\n    #     print(\"Cancelled.\")\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"{{CONTEXT_ROBUSTNESS_COMPLETE}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "add_error_handling"
      ],
      "source_file": "module_5_games/add_error_handling/exercise_1_input_validation.py"
    },
    {
      "id": "module_5_games.add_error_handling.exercise_2_game_commands",
      "topic_id": "loops.while",
      "exercise_type": "add_error_handling",
      "category": "improvement",
      "title": "Game Commands",
      "title_en": "Game Commands",
      "title_he": "Game Commands",
      "description_en": "Games: Game Commands\n\n{{CONTEXT_ERROR_HANDLING_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Handling invalid game commands gracefully\nDifficulty: 3-4\n\nGames need robust command handling - players will type anything!\nMake the game respond helpfully to invalid input.",
      "description_he": "משחקים: Game Commands\n\n{{CONTEXT_ERROR_HANDLING_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Handling invalid game commands gracefully\nDifficulty: 3-4\n\nGames need robust command handling - players will type anything!\nMake the game respond helpfully to invalid input.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "defensive_programming",
        "exceptions",
        "robustness"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_ERROR_HANDLING_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Handling invalid game commands gracefully\nDifficulty: 3-4\n\nGames need robust command handling - players will type anything!\nMake the game respond helpfully to invalid input.\n\"\"\"\n\n\n# ============================================================\n# {{HANDLING_1_TITLE}}\n# ============================================================\n# {{CONTEXT_HANDLING_1_NARRATIVE}}\n#\n# This movement system crashes on invalid directions.\n\n\ndef original_move(direction):\n    \"\"\"ORIGINAL: Crashes on invalid direction\"\"\"\n    moves = {\"north\": (0, 1), \"south\": (0, -1), \"east\": (1, 0), \"west\": (-1, 0)}\n    dx, dy = moves[direction]  # KeyError if direction invalid!\n    return dx, dy\n\n\ndef safe_move(direction):\n    \"\"\"\n    Get movement delta for a direction, handling invalid input.\n\n    Args:\n        direction: A string like \"north\", \"south\", \"east\", \"west\"\n\n    Returns:\n        tuple: (dx, dy) movement delta, or (0, 0) for invalid\n\n    Should:\n    - Accept any case (North, NORTH, north all work)\n    - Return (0, 0) and print error for invalid direction\n    - Print \"Invalid direction. Use north/south/east/west.\"\n    \"\"\"\n    # ✏️ ADD ERROR HANDLING ✏️\n    #\n    # {{CONTEXT_HANDLING_HINT_1}}\n    #\n    # Step 1: Define moves dictionary\n    # Step 2: Convert direction to lowercase\n    # Step 3: If direction in moves, return the delta\n    # Step 4: Otherwise, print error and return (0, 0)\n    pass\n\n\n# ============================================================\n# {{HANDLING_2_TITLE}}\n# ============================================================\n# {{CONTEXT_HANDLING_2_NARRATIVE}}\n#\n# This attack command crashes if target doesn't exist.\n\n\ndef original_attack(enemies, target_name):\n    \"\"\"ORIGINAL: Crashes if target not in list\"\"\"\n    for i, enemy in enumerate(enemies):\n        if enemy[\"name\"] == target_name:\n            enemies[i][\"hp\"] -= 10\n            return True\n    return False\n\n\ndef safe_attack(enemies, target_name):\n    \"\"\"\n    Attack a target by name, handling invalid targets.\n\n    Args:\n        enemies: List of enemy dicts with \"name\" and \"hp\" keys\n        target_name: Name of enemy to attack\n\n    Returns:\n        str: Result message\n\n    Should handle:\n    - Target not found: \"No enemy named {target_name}\"\n    - Target already defeated (hp <= 0): \"{target_name} is already defeated\"\n    - Successful attack: \"Hit {target_name} for 10 damage!\"\n    - Enemy defeated by this attack: \"{target_name} defeated!\"\n    \"\"\"\n    # ✏️ ADD ERROR HANDLING ✏️\n    #\n    # {{CONTEXT_HANDLING_HINT_2}}\n    #\n    # Step 1: Loop through enemies to find target\n    # Step 2: If not found after loop, return not found message\n    # Step 3: If found but hp <= 0, return already defeated message\n    # Step 4: Apply damage\n    # Step 5: If hp now <= 0, return defeated message\n    # Step 6: Otherwise return hit message\n    pass\n\n\n# ============================================================\n# {{HANDLING_3_TITLE}}\n# ============================================================\n# {{CONTEXT_HANDLING_3_NARRATIVE}}\n#\n# This inventory use command has multiple failure modes.\n\n\ndef original_use_item(inventory, item_name):\n    \"\"\"ORIGINAL: Crashes if item not in inventory\"\"\"\n    inventory.remove(item_name)  # ValueError if not present!\n    return f\"Used {item_name}\"\n\n\ndef safe_use_item(inventory, item_name):\n    \"\"\"\n    Use an item from inventory, handling errors.\n\n    Args:\n        inventory: List of item names\n        item_name: Item to use\n\n    Returns:\n        tuple: (success, message)\n\n    Should handle:\n    - Empty inventory: \"Inventory is empty!\"\n    - Item not found: \"{item_name} not in inventory\"\n    - Success: \"Used {item_name}!\" and remove from inventory\n    \"\"\"\n    # ✏️ ADD ERROR HANDLING ✏️\n    #\n    # {{CONTEXT_HANDLING_HINT_3}}\n    #\n    # Step 1: Check if inventory is empty\n    # Step 2: Check if item_name is in inventory\n    # Step 3: If present, remove and return success\n    # Step 4: Otherwise return appropriate error\n    pass\n\n\n# ============================================================\n# {{HANDLING_4_TITLE}}\n# ============================================================\n# {{CONTEXT_HANDLING_4_NARRATIVE}}\n#\n# This shop system has multiple ways to fail.\n\n\ndef original_buy_item(gold, item_prices, item_name):\n    \"\"\"ORIGINAL: Crashes if item doesn't exist\"\"\"\n    price = item_prices[item_name]\n    return gold - price, item_name\n\n\ndef safe_buy_item(gold, item_prices, item_name):\n    \"\"\"\n    Buy an item from the shop, handling all error cases.\n\n    Args:\n        gold: Player's current gold\n        item_prices: Dict of {item_name: price}\n        item_name: Item to purchase\n\n    Returns:\n        tuple: (new_gold, message)\n\n    Should handle:\n    - Item not in shop: \"Shop doesn't sell {item_name}\"\n    - Not enough gold: \"Need {price} gold, you have {gold}\"\n    - Success: Return (gold - price, \"Bought {item_name}!\")\n    \"\"\"\n    # ✏️ ADD ERROR HANDLING ✏️\n    #\n    # {{CONTEXT_HANDLING_HINT_4}}\n    #\n    # Step 1: Check if item_name in item_prices\n    # Step 2: Get the price\n    # Step 3: Check if player has enough gold\n    # Step 4: If all good, return new gold and success message\n    pass\n\n\n# ============================================================\n# {{HANDLING_5_TITLE}}\n# ============================================================\n# {{CONTEXT_HANDLING_5_NARRATIVE}}\n#\n# Build a complete command parser with validation.\n\n\ndef parse_game_command(command_string):\n    \"\"\"\n    Parse a game command string into action and arguments.\n\n    Valid commands:\n    - \"move <direction>\" (north/south/east/west)\n    - \"attack <target>\"\n    - \"use <item>\"\n    - \"look\"\n    - \"help\"\n    - \"quit\"\n\n    Args:\n        command_string: Raw input from player\n\n    Returns:\n        tuple: (action, args) or (None, error_message)\n\n    Examples:\n        parse_game_command(\"move north\") returns (\"move\", \"north\")\n        parse_game_command(\"attack goblin\") returns (\"attack\", \"goblin\")\n        parse_game_command(\"look\") returns (\"look\", None)\n        parse_game_command(\"dance\") returns (None, \"Unknown command: dance\")\n        parse_game_command(\"\") returns (None, \"Please enter a command\")\n    \"\"\"\n    # ✏️ ADD ERROR HANDLING ✏️\n    #\n    # {{CONTEXT_HANDLING_HINT_5}}\n    #\n    # Step 1: Strip and lowercase the command\n    # Step 2: If empty, return error\n    # Step 3: Split into parts\n    # Step 4: First part is the action\n    # Step 5: Check if action is valid\n    # Step 6: For commands needing args (move, attack, use):\n    #         - Check args provided\n    #         - For move, validate direction\n    # Step 7: Return (action, args) or appropriate error\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_ERROR_HANDLING_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{HANDLING_1_TITLE}} ===\")\n    print(\"Testing safe movement:\")\n    directions = [\"north\", \"SOUTH\", \"left\", \"east\"]\n    for d in directions:\n        result = safe_move(d)\n        print(f\"  {d} -> {result}\")\n\n    print(\"\\n=== {{HANDLING_2_TITLE}} ===\")\n    print(\"Testing safe attack:\")\n    enemies = [\n        {\"name\": \"{{creature}}\", \"hp\": 20},\n        {\"name\": \"{{villain}}\", \"hp\": 0}\n    ]\n    targets = [\"{{creature}}\", \"{{villain}}\", \"ghost\"]\n    for t in targets:\n        result = safe_attack(enemies, t)\n        print(f\"  Attack {t}: {result}\")\n\n    print(\"\\n=== {{HANDLING_3_TITLE}} ===\")\n    print(\"Testing safe use item:\")\n    inv = [\"{{item}}\", \"{{spell1}}\"]\n    items_to_use = [\"{{item}}\", \"{{spell2}}\"]\n    for item in items_to_use:\n        result = safe_use_item(inv, item)\n        print(f\"  Use {item}: {result}\")\n\n    print(\"\\n=== {{HANDLING_4_TITLE}} ===\")\n    print(\"Testing safe shop:\")\n    prices = {\"{{item}}\": 50, \"{{spell1}}\": 100}\n    purchases = [(\"{{item}}\", 60), (\"{{spell1}}\", 50), (\"potion\", 100)]\n    for item, gold in purchases:\n        new_gold, msg = safe_buy_item(gold, prices, item)\n        print(f\"  Buy {item} with {gold}g: {msg}\")\n\n    print(\"\\n=== {{HANDLING_5_TITLE}} ===\")\n    print(\"Testing command parser:\")\n    commands = [\"move north\", \"attack goblin\", \"look\", \"dance\", \"\", \"move\"]\n    for cmd in commands:\n        result = parse_game_command(cmd)\n        print(f\"  '{cmd}' -> {result}\")\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"{{CONTEXT_ROBUSTNESS_COMPLETE}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "add_error_handling"
      ],
      "source_file": "module_5_games/add_error_handling/exercise_2_game_commands.py"
    },
    {
      "id": "module_5_games.bug_hunt.exercise_1_infinite_loops",
      "topic_id": "loops.while",
      "exercise_type": "bug_hunt",
      "category": "debugging",
      "title": "Infinite Loops",
      "title_en": "Infinite Loops",
      "title_he": "Infinite Loops",
      "description_en": "Games: Infinite Loops\n\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding infinite loop bugs\nDifficulty: 1-2\n\nInfinite loops are one of the most common bugs when learning while loops.\nIn this exercise, you'll find and fix loops that never end.",
      "description_he": "משחקים: Infinite Loops\n\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding infinite loop bugs\nDifficulty: 1-2\n\nInfinite loops are one of the most common bugs when learning while loops.\nIn this exercise, you'll find and fix loops that never end.",
      "difficulty": 3,
      "requires_running": false,
      "estimated_time_minutes": 8,
      "skills": [
        "debugging",
        "critical_reading",
        "common_mistakes"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding infinite loop bugs\nDifficulty: 1-2\n\nInfinite loops are one of the most common bugs when learning while loops.\nIn this exercise, you'll find and fix loops that never end.\n\"\"\"\n\n\n# ============================================================\n# {{CASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_1_NARRATIVE}}\n#\n# {{hero}} wrote this code to count items, but it runs forever!\n#\n# EXPECTED BEHAVIOR:\n# Print numbers 1 through 5, then stop\n#\n# ACTUAL BEHAVIOR:\n# Prints 1 forever without stopping\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_1}}\n\n\ndef buggy_counter():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    count = 1\n    while count <= 5:\n        print(count)\n        # The counter never changes! Loop runs forever.\n\n\ndef fix_counter():\n    \"\"\"\n    Fix the infinite loop.\n\n    Expected output:\n        1\n        2\n        3\n        4\n        5\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_2_NARRATIVE}}\n#\n# This countdown should go from 5 to 1, but something's wrong.\n#\n# EXPECTED BEHAVIOR:\n# Print 5, 4, 3, 2, 1, \"Done!\"\n#\n# ACTUAL BEHAVIOR:\n# Counts the wrong direction and never reaches 0\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_2}}\n\n\ndef buggy_countdown():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    num = 5\n    while num > 0:\n        print(num)\n        num += 1  # Oops! Going the wrong way!\n\n\ndef fix_countdown():\n    \"\"\"\n    Fix the countdown direction.\n\n    Expected output:\n        5\n        4\n        3\n        2\n        1\n        Done!\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_3_NARRATIVE}}\n#\n# This loop should process a list, but it never terminates.\n#\n# EXPECTED BEHAVIOR:\n# Process each item and stop when list is empty\n#\n# ACTUAL BEHAVIOR:\n# The list never gets shorter\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_3}}\n\n\ndef buggy_list_processor():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    items = [\"{{item}}\", \"{{pet}}\", \"{{creature}}\"]\n    index = 0\n    while index < len(items):\n        print(f\"Processing: {items[index]}\")\n        # Forgot to move to next item!\n\n\ndef fix_list_processor():\n    \"\"\"\n    Fix the list processor.\n\n    Expected output:\n        Processing: {{item}}\n        Processing: {{pet}}\n        Processing: {{creature}}\n        All items processed!\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_4_NARRATIVE}}\n#\n# This accumulator should add up numbers, but it loops forever.\n#\n# EXPECTED BEHAVIOR:\n# Add numbers until total exceeds 20, then stop\n#\n# ACTUAL BEHAVIOR:\n# Total never changes, condition never becomes False\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_4}}\n\n\ndef buggy_accumulator():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    total = 0\n    amount = 5\n    while total < 20:\n        print(f\"Adding {amount}, total would be {total + amount}\")\n        # total + amount doesn't save the result!\n\n\ndef fix_accumulator():\n    \"\"\"\n    Fix the accumulator.\n\n    Expected output:\n        Adding 5, total is now 5\n        Adding 5, total is now 10\n        Adding 5, total is now 15\n        Adding 5, total is now 20\n        Final total: 20\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_INVESTIGATION_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{CASE_1_TITLE}} ===\")\n    print(\"Buggy version (DON'T RUN - infinite loop):\")\n    print(\"# buggy_counter()\")\n    print(\"\\nFixed version:\")\n    fix_counter()\n\n    print(\"\\n=== {{CASE_2_TITLE}} ===\")\n    print(\"Buggy version (DON'T RUN - infinite loop):\")\n    print(\"# buggy_countdown()\")\n    print(\"\\nFixed version:\")\n    fix_countdown()\n\n    print(\"\\n=== {{CASE_3_TITLE}} ===\")\n    print(\"Buggy version (DON'T RUN - infinite loop):\")\n    print(\"# buggy_list_processor()\")\n    print(\"\\nFixed version:\")\n    fix_list_processor()\n\n    print(\"\\n=== {{CASE_4_TITLE}} ===\")\n    print(\"Buggy version (DON'T RUN - infinite loop):\")\n    print(\"# buggy_accumulator()\")\n    print(\"\\nFixed version:\")\n    fix_accumulator()\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"{{CONTEXT_INVESTIGATION_COMPLETE}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "bug_hunt"
      ],
      "source_file": "module_5_games/bug_hunt/exercise_1_infinite_loops.py"
    },
    {
      "id": "module_5_games.bug_hunt.exercise_2_break_continue",
      "topic_id": "loops.while",
      "exercise_type": "bug_hunt",
      "category": "debugging",
      "title": "Break Continue",
      "title_en": "Break Continue",
      "title_he": "Break Continue",
      "description_en": "Games: Break Continue\n\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding bugs with break and continue\nDifficulty: 2-3\n\nbreak and continue are powerful but can cause subtle bugs\nwhen placed incorrectly or when the logic is inverted.",
      "description_he": "משחקים: Break Continue\n\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding bugs with break and continue\nDifficulty: 2-3\n\nbreak and continue are powerful but can cause subtle bugs\nwhen placed incorrectly or when the logic is inverted.",
      "difficulty": 3,
      "requires_running": false,
      "estimated_time_minutes": 8,
      "skills": [
        "debugging",
        "critical_reading",
        "common_mistakes"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding bugs with break and continue\nDifficulty: 2-3\n\nbreak and continue are powerful but can cause subtle bugs\nwhen placed incorrectly or when the logic is inverted.\n\"\"\"\n\n\n# ============================================================\n# {{CASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_1_NARRATIVE}}\n#\n# This search function should find an item and return its index.\n#\n# EXPECTED BEHAVIOR:\n# Return the index where target is found, or -1 if not found\n#\n# ACTUAL BEHAVIOR:\n# Always returns -1, even when the item exists\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_1}}\n\n\ndef buggy_search(items, target):\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    index = 0\n    while index < len(items):\n        if items[index] == target:\n            break  # Found it!\n        index += 1\n    return -1  # BUG: Always returns -1, never returns the found index\n\n\ndef fix_search(items, target):\n    \"\"\"\n    Fix the search function.\n\n    Example:\n        fix_search([\"{{item}}\", \"{{pet}}\", \"{{creature}}\"], \"{{pet}}\")\n        Returns: 1\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_2_NARRATIVE}}\n#\n# This function should skip negative numbers and sum the positives.\n#\n# EXPECTED BEHAVIOR:\n# Sum only the positive numbers, skip negatives\n#\n# ACTUAL BEHAVIOR:\n# Returns 0 because it breaks on the first negative\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_2}}\n\n\ndef buggy_sum_positives(numbers):\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    total = 0\n    for num in numbers:\n        if num < 0:\n            break  # BUG: Should be continue, not break!\n        total += num\n    return total\n\n\ndef fix_sum_positives(numbers):\n    \"\"\"\n    Fix the function to sum only positive numbers.\n\n    Example:\n        fix_sum_positives([5, -3, 10, -1, 7])\n        Returns: 22 (5 + 10 + 7)\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_3_NARRATIVE}}\n#\n# This collector should stop when the user enters 'quit'.\n#\n# EXPECTED BEHAVIOR:\n# Collect items until user types 'quit', then return the list\n#\n# ACTUAL BEHAVIOR:\n# Never stops, keeps asking forever\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_3}}\n\n\ndef buggy_collector():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    items = []\n    while True:\n        user_input = input(\"Enter item (or 'quit'): \")\n        if user_input == \"quit\":\n            continue  # BUG: Should be break, not continue!\n        items.append(user_input)\n    return items\n\n\ndef fix_collector():\n    \"\"\"\n    Fix the collector to stop on 'quit'.\n\n    Returns:\n        list: Items collected before 'quit'\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_4_NARRATIVE}}\n#\n# This validator should stop validating after finding one error.\n#\n# EXPECTED BEHAVIOR:\n# Check items until finding an invalid one, then stop\n#\n# ACTUAL BEHAVIOR:\n# The break is inside the else, so it breaks on VALID items\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_4}}\n\n\ndef buggy_validator(items):\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    valid_items = []\n    for item in items:\n        if item == \"\" or item is None:\n            print(f\"Invalid item found!\")\n        else:\n            valid_items.append(item)\n            break  # BUG: Break is in wrong branch!\n    return valid_items\n\n\ndef fix_validator(items):\n    \"\"\"\n    Fix the validator to stop after finding first invalid item.\n\n    Example:\n        fix_validator([\"{{hero}}\", \"{{villain}}\", \"\", \"{{friend}}\"])\n        Returns: [\"{{hero}}\", \"{{villain}}\"]  # Stops at empty string\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_5_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_5_NARRATIVE}}\n#\n# This function should find the first item that matches a condition.\n#\n# EXPECTED BEHAVIOR:\n# Return the first item longer than 5 characters\n#\n# ACTUAL BEHAVIOR:\n# Skips items that match! Returns wrong result.\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_5}}\n\n\ndef buggy_find_long_item(items):\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    for item in items:\n        if len(item) > 5:\n            continue  # BUG: Should return item, not continue!\n        # Falls through without returning the match\n    return None\n\n\ndef fix_find_long_item(items):\n    \"\"\"\n    Fix the function to return first item longer than 5 characters.\n\n    Example:\n        fix_find_long_item([\"cat\", \"elephant\", \"dog\"])\n        Returns: \"elephant\"\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_INVESTIGATION_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{CASE_1_TITLE}} ===\")\n    print(\"Testing search:\")\n    items = [\"{{item}}\", \"{{pet}}\", \"{{creature}}\"]\n    buggy_result = buggy_search(items, \"{{pet}}\")\n    print(f\"Buggy result: {buggy_result} (should be 1)\")\n    # fixed_result = fix_search(items, \"{{pet}}\")\n    # print(f\"Fixed result: {fixed_result}\")\n\n    print(\"\\n=== {{CASE_2_TITLE}} ===\")\n    print(\"Testing sum positives:\")\n    numbers = [5, -3, 10, -1, 7]\n    buggy_result = buggy_sum_positives(numbers)\n    print(f\"Buggy result: {buggy_result} (should be 22)\")\n    # fixed_result = fix_sum_positives(numbers)\n    # print(f\"Fixed result: {fixed_result}\")\n\n    print(\"\\n=== {{CASE_3_TITLE}} ===\")\n    print(\"Testing collector:\")\n    print(\"(Buggy version would loop forever - don't run!)\")\n    # fixed_items = fix_collector()\n    # print(f\"Collected: {fixed_items}\")\n\n    print(\"\\n=== {{CASE_4_TITLE}} ===\")\n    print(\"Testing validator:\")\n    test_items = [\"{{hero}}\", \"{{villain}}\", \"\", \"{{friend}}\"]\n    buggy_result = buggy_validator(test_items.copy())\n    print(f\"Buggy result: {buggy_result} (should be ['{{{{hero}}}}', '{{{{villain}}}}'])\")\n    # fixed_result = fix_validator(test_items)\n    # print(f\"Fixed result: {fixed_result}\")\n\n    print(\"\\n=== {{CASE_5_TITLE}} ===\")\n    print(\"Testing find long item:\")\n    words = [\"cat\", \"elephant\", \"dog\", \"hippopotamus\"]\n    buggy_result = buggy_find_long_item(words)\n    print(f\"Buggy result: {buggy_result} (should be 'elephant')\")\n    # fixed_result = fix_find_long_item(words)\n    # print(f\"Fixed result: {fixed_result}\")\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"{{CONTEXT_INVESTIGATION_COMPLETE}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "bug_hunt"
      ],
      "source_file": "module_5_games/bug_hunt/exercise_2_break_continue.py"
    },
    {
      "id": "module_5_games.bug_hunt.exercise_3_random_bugs",
      "topic_id": "loops.while",
      "exercise_type": "bug_hunt",
      "category": "debugging",
      "title": "Random Bugs",
      "title_en": "Random Bugs",
      "title_he": "Random Bugs",
      "description_en": "Games: Random Bugs\n\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding bugs in random module usage\nDifficulty: 2-3\n\nThe random module has some common pitfalls:\n- randint is INCLUSIVE on both ends (unlike range)\n- Forgetting to import random\n- Using wrong function for the task",
      "description_he": "משחקים: Random Bugs\n\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding bugs in random module usage\nDifficulty: 2-3\n\nThe random module has some common pitfalls:\n- randint is INCLUSIVE on both ends (unlike range)\n- Forgetting to import random\n- Using wrong function for the task",
      "difficulty": 3,
      "requires_running": false,
      "estimated_time_minutes": 8,
      "skills": [
        "debugging",
        "critical_reading",
        "common_mistakes"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding bugs in random module usage\nDifficulty: 2-3\n\nThe random module has some common pitfalls:\n- randint is INCLUSIVE on both ends (unlike range)\n- Forgetting to import random\n- Using wrong function for the task\n\"\"\"\n\nimport random\n\n\n# ============================================================\n# {{CASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_1_NARRATIVE}}\n#\n# This die roller should roll from 1 to 6, but something's off.\n#\n# EXPECTED BEHAVIOR:\n# Return values from 1 to 6 (inclusive)\n#\n# ACTUAL BEHAVIOR:\n# Returns values from 0 to 5 (never returns 6!)\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_1}}\n\n\ndef buggy_roll_die():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    return random.randint(0, 5)  # BUG: Range should be 1 to 6\n\n\ndef fix_roll_die():\n    \"\"\"\n    Fix the die roller to return 1-6.\n\n    Returns:\n        int: A random number from 1 to 6 (inclusive)\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_2_NARRATIVE}}\n#\n# This picker should select from a list, but picks indices instead.\n#\n# EXPECTED BEHAVIOR:\n# Return one of: \"{{hero}}\", \"{{villain}}\", \"{{friend}}\"\n#\n# ACTUAL BEHAVIOR:\n# Returns 0, 1, or 2 (the indices, not the names!)\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_2}}\n\n\ndef buggy_pick_character():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    characters = [\"{{hero}}\", \"{{villain}}\", \"{{friend}}\"]\n    return random.randint(0, len(characters) - 1)  # BUG: Returns index, not item\n\n\ndef fix_pick_character():\n    \"\"\"\n    Fix the picker to return an actual character name.\n\n    Returns:\n        str: A randomly chosen character name\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # Hint: Use random.choice() instead of randint for picking from lists\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_3_NARRATIVE}}\n#\n# This chance function should return True about 70% of the time.\n#\n# EXPECTED BEHAVIOR:\n# Returns True approximately 70% of the time\n#\n# ACTUAL BEHAVIOR:\n# Returns True approximately 30% of the time (inverted!)\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_3}}\n\n\ndef buggy_seventy_percent_chance():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    roll = random.random()\n    return roll > 0.7  # BUG: Condition is inverted! Should be < 0.7\n\n\ndef fix_seventy_percent_chance():\n    \"\"\"\n    Fix the function to return True about 70% of the time.\n\n    Returns:\n        bool: True approximately 70% of the time\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_4_NARRATIVE}}\n#\n# This damage calculator has an off-by-one error in its range.\n#\n# EXPECTED BEHAVIOR:\n# Deal base damage plus 1-5 bonus (so 11-15 if base is 10)\n#\n# ACTUAL BEHAVIOR:\n# Deals base damage plus 1-6 bonus (includes 6, which is too high)\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_4}}\n\n\ndef buggy_calculate_damage(base_damage):\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    bonus = random.randint(1, 6)  # BUG: Should be 1-5, not 1-6\n    return base_damage + bonus\n\n\ndef fix_calculate_damage(base_damage):\n    \"\"\"\n    Fix the damage calculator.\n\n    Args:\n        base_damage: The base damage amount\n\n    Returns:\n        int: base_damage plus a random bonus from 1 to 5\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_5_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_5_NARRATIVE}}\n#\n# This coin flipper should return \"heads\" or \"tails\" randomly.\n#\n# EXPECTED BEHAVIOR:\n# Return \"heads\" or \"tails\" with equal probability\n#\n# ACTUAL BEHAVIOR:\n# Always returns \"heads\" (the variable is assigned but never used)\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_5}}\n\n\ndef buggy_flip_coin():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    result = random.choice([\"heads\", \"tails\"])\n    return \"heads\"  # BUG: Ignores the random result, always returns \"heads\"\n\n\ndef fix_flip_coin():\n    \"\"\"\n    Fix the coin flipper.\n\n    Returns:\n        str: Either \"heads\" or \"tails\" randomly\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_6_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_6_NARRATIVE}}\n#\n# This stat generator should create balanced stats (total around 30).\n#\n# EXPECTED BEHAVIOR:\n# Generate three stats of 8-12 each, total 24-36\n#\n# ACTUAL BEHAVIOR:\n# All three stats are the SAME value (rolled once, used three times)\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_6}}\n\n\ndef buggy_generate_balanced_stats():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    roll = random.randint(8, 12)\n    return {\n        \"strength\": roll,  # BUG: Same roll used for all three!\n        \"agility\": roll,\n        \"wisdom\": roll\n    }\n\n\ndef fix_generate_balanced_stats():\n    \"\"\"\n    Fix the stat generator to give different values.\n\n    Returns:\n        dict: Three stats, each independently rolled 8-12\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_INVESTIGATION_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{CASE_1_TITLE}} ===\")\n    print(\"Testing die roller (should be 1-6):\")\n    results = [buggy_roll_die() for _ in range(10)]\n    print(f\"Buggy rolls: {results}\")\n    print(\"Notice: never gets 6, sometimes gets 0!\")\n\n    print(\"\\n=== {{CASE_2_TITLE}} ===\")\n    print(\"Testing character picker:\")\n    print(f\"Buggy result: {buggy_pick_character()} (should be a name, not number)\")\n\n    print(\"\\n=== {{CASE_3_TITLE}} ===\")\n    print(\"Testing 70% chance (100 trials):\")\n    successes = sum(1 for _ in range(100) if buggy_seventy_percent_chance())\n    print(f\"Buggy successes: {successes}/100 (should be ~70)\")\n\n    print(\"\\n=== {{CASE_4_TITLE}} ===\")\n    print(\"Testing damage calculator (base 10):\")\n    damages = [buggy_calculate_damage(10) for _ in range(10)]\n    print(f\"Buggy damages: {damages}\")\n    print(\"Notice: might include 16 (10+6), which shouldn't be possible!\")\n\n    print(\"\\n=== {{CASE_5_TITLE}} ===\")\n    print(\"Testing coin flipper (10 flips):\")\n    flips = [buggy_flip_coin() for _ in range(10)]\n    print(f\"Buggy flips: {flips}\")\n    print(\"Notice: always heads!\")\n\n    print(\"\\n=== {{CASE_6_TITLE}} ===\")\n    print(\"Testing stat generator:\")\n    stats = buggy_generate_balanced_stats()\n    print(f\"Buggy stats: {stats}\")\n    print(\"Notice: all stats are identical!\")\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"{{CONTEXT_INVESTIGATION_COMPLETE}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "bug_hunt"
      ],
      "source_file": "module_5_games/bug_hunt/exercise_3_random_bugs.py"
    },
    {
      "id": "module_5_games.bug_hunt.exercise_4_game_logic",
      "topic_id": "loops.while",
      "exercise_type": "bug_hunt",
      "category": "debugging",
      "title": "Game Logic",
      "title_en": "Game Logic",
      "title_he": "Game Logic",
      "description_en": "Games: Game Logic\n\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding bugs in game logic\nDifficulty: 3-4\n\nGame logic bugs are subtle - the code runs but the game doesn't work right.\nThese bugs involve game state, win conditions, and scoring.",
      "description_he": "משחקים: Game Logic\n\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding bugs in game logic\nDifficulty: 3-4\n\nGame logic bugs are subtle - the code runs but the game doesn't work right.\nThese bugs involve game state, win conditions, and scoring.",
      "difficulty": 3,
      "requires_running": false,
      "estimated_time_minutes": 8,
      "skills": [
        "debugging",
        "critical_reading",
        "common_mistakes"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_INVESTIGATION_INTRO}}\n{{CONTEXT_INVESTIGATION_MISSION}}\n\nTopic: Finding bugs in game logic\nDifficulty: 3-4\n\nGame logic bugs are subtle - the code runs but the game doesn't work right.\nThese bugs involve game state, win conditions, and scoring.\n\"\"\"\n\nimport random\n\n\n# ============================================================\n# {{CASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_1_NARRATIVE}}\n#\n# This game should end when a player reaches 10 points.\n#\n# EXPECTED BEHAVIOR:\n# Game ends immediately when someone reaches 10 points\n#\n# ACTUAL BEHAVIOR:\n# Game always plays all 10 rounds, even after someone wins\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_1}}\n\n\ndef buggy_score_game():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    player_score = 0\n    computer_score = 0\n    rounds = 0\n\n    print(\"First to 10 wins!\")\n\n    while rounds < 10:  # BUG: Should check score conditions too!\n        rounds += 1\n        print(f\"\\n--- Round {rounds} ---\")\n\n        # Random scoring\n        if random.random() < 0.5:\n            player_score += 2\n            print(f\"You score! ({player_score}-{computer_score})\")\n        else:\n            computer_score += 2\n            print(f\"Computer scores! ({player_score}-{computer_score})\")\n\n    # Winner announcement\n    if player_score > computer_score:\n        print(\"You win!\")\n    else:\n        print(\"Computer wins!\")\n\n\ndef fix_score_game():\n    \"\"\"\n    Fix the game to end when someone reaches 10 points.\n\n    The while condition should check both:\n    - rounds < 10 (maximum rounds)\n    - player_score < 10 (player hasn't won yet)\n    - computer_score < 10 (computer hasn't won yet)\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_2_NARRATIVE}}\n#\n# This game should reset scores between rounds.\n#\n# EXPECTED BEHAVIOR:\n# Each new game starts with 0-0 score\n#\n# ACTUAL BEHAVIOR:\n# Scores carry over from previous games!\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_2}}\n\n\nplayer_total = 0  # BUG: Global variables persist between games!\nenemy_total = 0\n\n\ndef buggy_battle():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    global player_total, enemy_total\n    # BUG: Never reset! Should set both to 0 here.\n\n    print(f\"Battle start! Scores: {player_total}-{enemy_total}\")\n\n    for round_num in range(1, 4):\n        print(f\"Round {round_num}\")\n        if random.random() < 0.6:\n            player_total += 1\n            print(\"You hit!\")\n        else:\n            enemy_total += 1\n            print(\"Enemy hits!\")\n\n    print(f\"Final: {player_total}-{enemy_total}\")\n\n\ndef fix_battle():\n    \"\"\"\n    Fix the battle to reset scores at the start.\n\n    Add score reset at the beginning of the function:\n    player_total = 0\n    enemy_total = 0\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix (don't use globals - use local variables):\n    pass\n\n\n# ============================================================\n# {{CASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_3_NARRATIVE}}\n#\n# This turn-based game should alternate between players.\n#\n# EXPECTED BEHAVIOR:\n# Player 1, Player 2, Player 1, Player 2, ...\n#\n# ACTUAL BEHAVIOR:\n# Player 1 goes twice, then alternates wrong\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_3}}\n\n\ndef buggy_turns():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    current_player = 1\n    turns_taken = 0\n\n    while turns_taken < 6:\n        print(f\"Player {current_player}'s turn\")\n        turns_taken += 1\n\n        # Switch players\n        if current_player == 1:\n            current_player = 2\n        if current_player == 2:  # BUG: Should be elif!\n            current_player = 1\n\n\ndef fix_turns():\n    \"\"\"\n    Fix the turn alternation.\n\n    The second 'if' should be 'elif' - otherwise after\n    setting player to 2, it immediately sets back to 1!\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_4_NARRATIVE}}\n#\n# This game should track high scores correctly.\n#\n# EXPECTED BEHAVIOR:\n# New high score only if current > previous high\n#\n# ACTUAL BEHAVIOR:\n# Always says \"New high score!\" even for lower scores\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_4}}\n\n\ndef buggy_high_score(current_score, high_score):\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    print(f\"Your score: {current_score}\")\n    print(f\"High score: {high_score}\")\n\n    if current_score > high_score:\n        high_score = current_score  # Updates local only!\n\n    print(\"New high score!\")  # BUG: This runs unconditionally!\n    return high_score\n\n\ndef fix_high_score(current_score, high_score):\n    \"\"\"\n    Fix the high score checker.\n\n    The \"New high score!\" message should only print\n    when the score is actually updated.\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\n# ============================================================\n# {{CASE_5_TITLE}}\n# ============================================================\n# {{CONTEXT_CASE_5_NARRATIVE}}\n#\n# This game loop should handle the \"play again\" correctly.\n#\n# EXPECTED BEHAVIOR:\n# Ask to play again after each game, quit on \"no\"\n#\n# ACTUAL BEHAVIOR:\n# Only plays once, never asks to play again\n#\n# {{CONTEXT_INVESTIGATION_PROMPT_5}}\n\n\ndef buggy_play_again():\n    \"\"\"This code has exactly ONE bug. Find it!\"\"\"\n    playing = True\n\n    while playing:\n        print(\"Playing a round...\")\n        score = random.randint(1, 100)\n        print(f\"You scored: {score}\")\n\n        response = input(\"Play again? (yes/no): \")\n        if response.lower() == \"no\":\n            playing = False\n            break  # BUG: break exits immediately, print below never runs\n        # Missing: if yes, should continue loop\n        # But also: the break prevents \"Thanks for playing\" from showing\n\n        print(\"Thanks for playing!\")  # This line is unreachable after \"no\"\n\n\ndef fix_play_again():\n    \"\"\"\n    Fix the play again loop.\n\n    The \"Thanks for playing!\" should print after the loop ends,\n    not inside it. Also consider the flow for both yes and no.\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    #\n    # What I found: ________________________________\n    #\n    # The fix:\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_INVESTIGATION_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{CASE_1_TITLE}} ===\")\n    print(\"Testing score game:\")\n    # buggy_score_game()\n    print(\"(Notice: plays all 10 rounds even if someone wins early)\")\n\n    print(\"\\n=== {{CASE_2_TITLE}} ===\")\n    print(\"Testing battle (run twice to see the bug):\")\n    # buggy_battle()\n    # print()\n    # buggy_battle()  # Second time has wrong starting scores!\n\n    print(\"\\n=== {{CASE_3_TITLE}} ===\")\n    print(\"Testing turn system:\")\n    buggy_turns()\n    print(\"(Notice: Player 1 only appears once!)\")\n\n    print(\"\\n=== {{CASE_4_TITLE}} ===\")\n    print(\"Testing high score:\")\n    result = buggy_high_score(50, 100)  # 50 is NOT a high score!\n    print(f\"Returned: {result}\")\n    print(\"(Says 'New high score' even though 50 < 100)\")\n\n    print(\"\\n=== {{CASE_5_TITLE}} ===\")\n    print(\"Testing play again:\")\n    # buggy_play_again()\n\n    print(\"\\n\" + \"=\" * 50)\n    print(\"{{CONTEXT_INVESTIGATION_COMPLETE}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "bug_hunt"
      ],
      "source_file": "module_5_games/bug_hunt/exercise_4_game_logic.py"
    },
    {
      "id": "module_5_games.hybrid.exercise_1_rivalry_loop_duel",
      "topic_id": "loops.while",
      "exercise_type": "hybrid",
      "category": "hybrid",
      "title": "Rivalry Loop Duel",
      "title_en": "Rivalry Loop Duel",
      "title_he": "Rivalry Loop Duel",
      "description_en": "Games: Rivalry Loop Duel\n\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise following {{hero}}'s journey from defeat to victory.\nComplete each part in order.\n\nProgramming concepts: while loops, random, game state, conditionals",
      "description_he": "משחקים: Rivalry Loop Duel\n\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise following {{hero}}'s journey from defeat to victory.\nComplete each part in order.\n\nProgramming concepts: while loops, random, game state, conditionals",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "mental_execution",
        "syntax_recall",
        "implementation",
        "pattern_recognition",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise following {{hero}}'s journey from defeat to victory.\nComplete each part in order.\n\nProgramming concepts: while loops, random, game state, conditionals\n\"\"\"\n\nimport random\n\n# ============================================================\n# PART 1: The Defeat\n# ============================================================\n# {{CONTEXT_SETBACK_NARRATIVE}}\n#\n# {{hero}}'s code from the last match had bugs. That's why {{villain}} won.\n# Find and fix the 3 bugs so this never happens again.\n#\n# BUGS TO FIND: 3\n\n\ndef buggy_match():\n    \"\"\"The buggy code that caused {{hero}} to lose.\"\"\"\n    player_a_score = 0\n    player_b_score = 0\n    rounds_played = 0\n    max_rounds = 5\n\n    print(f\"=== {{{{hero}}}} vs {{{{villain}}}} ===\")\n    print()\n\n    while rounds_played < max_rounds:  # BUG 1: Should be <=, misses round 5\n        rounds_played += 1\n        print(f\"--- Round {rounds_played} ---\")\n\n        # {{hero}}'s turn\n        player_a_result = random.choice([\"success\", \"success\", \"fail\"])\n        if player_a_result == \"success\":\n            player_a_score + 1  # BUG 2: Should be player_a_score += 1\n            print(f\"{{{{hero}}}} scores! Total: {player_a_score}\")\n        else:\n            print(f\"{{{{hero}}}} misses...\")\n\n        # {{villain}}'s turn\n        player_b_result = random.choice([\"success\", \"success\", \"fail\"])\n        if player_b_result == \"success\":\n            player_b_score += 1\n            print(f\"{{{{villain}}}} scores. Total: {player_b_score}\")\n        else:\n            print(f\"{{{{villain}}}} misses!\")\n\n        print()\n\n    print(\"=== FINAL RESULT ===\")\n    print(f\"{{{{hero}}}}: {player_a_score}\")\n    print(f\"{{{{villain}}}}: {player_b_score}\")\n\n    if player_a_score >= player_b_score:  # BUG 3: Should be > for hero win, = is tie\n        print(f\"{{{{villain}}}} wins!\")\n    else:\n        print(f\"{{{{hero}}}} wins!\")\n\n\n# ✏️ FIX THE CODE BELOW ✏️\ndef fixed_match():\n    \"\"\"\n    Fix all 3 bugs from buggy_match().\n\n    Bug hints:\n    1. How many rounds should be played?\n    2. Is the score actually increasing?\n    3. What should happen when scores are equal?\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\n# ============================================================\n# PART 2: Training\n# ============================================================\n# {{CONTEXT_GROWTH_INTRO}}\n# {{CONTEXT_GROWTH_NARRATIVE}}\n#\n# {{hero}} needs a new ability: the POWER MOVE.\n#\n# A power move is high risk, high reward:\n# - 40% chance: CRITICAL SUCCESS (2 points!)\n# - 30% chance: Normal success (1 point)\n# - 30% chance: Fail (0 points)\n#\n# Implement the power move and a training loop to practice it.\n\n\ndef attempt_power_move():\n    \"\"\"\n    Attempt a risky power move.\n\n    Returns:\n        int: Points scored (0, 1, or 2)\n\n    Use random.random() which returns 0.0 to 1.0:\n    - 0.0 to 0.4 (40%): Critical success, return 2\n    - 0.4 to 0.7 (30%): Normal success, return 1\n    - 0.7 to 1.0 (30%): Fail, return 0\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef attempt_regular_move():\n    \"\"\"\n    Attempt a safe regular move.\n\n    Returns:\n        int: Points scored (0 or 1)\n\n    66% chance of success (1 point), 34% chance of fail (0 points).\n    \"\"\"\n    result = random.choice([\"success\", \"success\", \"fail\"])\n    if result == \"success\":\n        return 1\n    return 0\n\n\ndef training_session():\n    \"\"\"\n    Practice session where {{hero}} can try both move types.\n\n    Loop until the player types 'q' to quit:\n    - 'r' = regular move (safe)\n    - 'p' = power move (risky)\n    - 'q' = quit training\n\n    Track and display:\n    - Total points scored\n    - Number of attempts\n    - Success rate\n    \"\"\"\n    total_points = 0\n    attempts = 0\n\n    print(\"=== TRAINING SESSION ===\")\n    print(f\"{{{{hero}}}} practices for the rematch against {{{{villain}}}}.\")\n    print()\n    print(\"Commands: 'r' = regular move, 'p' = power move, 'q' = quit\")\n    print()\n\n    # ✏️ YOUR CODE HERE ✏️\n    # Implement the training loop:\n    # 1. Ask for input (r/p/q)\n    # 2. Execute the chosen move\n    # 3. Display result and running totals\n    # 4. Continue until 'q'\n    pass\n\n    print()\n    print(\"=== TRAINING COMPLETE ===\")\n    print(f\"Total points: {total_points}\")\n    print(f\"Attempts: {attempts}\")\n    if attempts > 0:\n        print(f\"Average: {total_points / attempts:.2f} points per attempt\")\n\n\n# ============================================================\n# PART 3: The Showdown\n# ============================================================\n# {{CONTEXT_CONFRONTATION_INTRO}}\n# {{CONTEXT_CONFRONTATION_NARRATIVE}}\n#\n# The rematch! Build the complete showdown:\n# - 5 rounds of competition\n# - {{hero}} can choose regular or power move each round\n# - {{villain}} always uses regular moves\n# - If tied after 5 rounds: sudden death until someone leads\n#\n# Use everything you've learned. This is the final test.\n\n\ndef player_a_turn():\n    \"\"\"\n    {{hero}}'s turn. Ask for move type and execute.\n\n    Returns:\n        int: Points scored\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef player_b_turn():\n    \"\"\"\n    {{villain}}'s turn. Always uses regular move.\n\n    Returns:\n        int: Points scored\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef play_round(round_num, player_a_score, player_b_score):\n    \"\"\"\n    Play one round of the showdown.\n\n    Args:\n        round_num: Current round number\n        player_a_score: {{hero}}'s current score\n        player_b_score: {{villain}}'s current score\n\n    Returns:\n        tuple: (hero_points_this_round, villain_points_this_round)\n    \"\"\"\n    print(f\"--- Round {round_num} ---\")\n    print(f\"Score: {{{{hero}}}} {player_a_score} - {player_b_score} {{{{villain}}}}\")\n\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef the_showdown():\n    \"\"\"\n    The complete championship match!\n\n    Structure:\n    1. Play 5 regular rounds\n    2. If tied: sudden death rounds until someone leads\n    3. Announce the winner with appropriate drama\n\n    Remember:\n    - {{hero}} chooses move type each turn\n    - {{villain}} always uses regular moves\n    - Display scores after each round\n    \"\"\"\n    print(\"=\" * 50)\n    print(\"   THE FINAL SHOWDOWN\")\n    print(f\"   {{{{hero}}}} vs {{{{villain}}}}\")\n    print(\"=\" * 50)\n    print()\n\n    player_a_score = 0\n    player_b_score = 0\n\n    # ✏️ YOUR CODE HERE ✏️\n    # 1. Main match: 5 rounds\n    # 2. Check for winner\n    # 3. If tied: sudden death\n    # 4. Announce winner\n    pass\n\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_SETBACK_INTRO}}\")\n    print(\"=\" * 60)\n    print()\n\n    print(\">>> PART 1: Analyzing the defeat...\")\n    print(\"(Review buggy_match() and implement fixed_match())\")\n    print()\n    # Uncomment to test:\n    # fixed_match()\n\n    print()\n    print(\">>> PART 2: Training begins...\")\n    print(\"(Implement attempt_power_move() and training_session())\")\n    print()\n    # Uncomment to test:\n    # training_session()\n\n    print()\n    print(\">>> PART 3: The showdown awaits...\")\n    print(\"(Implement all showdown functions)\")\n    print()\n    # Uncomment to test:\n    # the_showdown()\n\n    print()\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_TRIUMPH_COMPLETE}}\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "hybrid"
      ],
      "source_file": "module_5_games/hybrid/exercise_1_rivalry_loop_duel.py"
    },
    {
      "id": "module_5_games.hybrid.exercise_2_rescue_stuck_game",
      "topic_id": "loops.while",
      "exercise_type": "hybrid",
      "category": "hybrid",
      "title": "Rescue Stuck Game",
      "title_en": "Rescue Stuck Game",
      "title_he": "Rescue Stuck Game",
      "description_en": "Games: Rescue Stuck Game\n\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise where you rescue a stuck game.\nThe game freezes and crashes - find out why and fix it!\n\nProgramming concepts: while loops, infinite loops, input validation",
      "description_he": "משחקים: Rescue Stuck Game\n\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise where you rescue a stuck game.\nThe game freezes and crashes - find out why and fix it!\n\nProgramming concepts: while loops, infinite loops, input validation",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "mental_execution",
        "syntax_recall",
        "implementation",
        "pattern_recognition",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise where you rescue a stuck game.\nThe game freezes and crashes - find out why and fix it!\n\nProgramming concepts: while loops, infinite loops, input validation\n\"\"\"\n\n\n# ============================================================\n# PART 1: The Freeze\n# ============================================================\n# {{CONTEXT_SETBACK_NARRATIVE}}\n#\n# {{friend}}'s game freezes every time! The loop never ends.\n# Examine the code and find where it gets stuck.\n#\n# BUGS TO FIND: 2 infinite loop bugs\n\n\ndef buggy_game_loop():\n    \"\"\"\n    This game loop freezes. Find the 2 bugs!\n\n    BUG 1: The main game loop counter never updates\n    BUG 2: The score display loop has wrong condition\n    \"\"\"\n    print(\"=== {{school}} Adventure ===\")\n    print()\n\n    score = 0\n    round_num = 1\n    max_rounds = 3\n\n    # Game loop\n    while round_num <= max_rounds:\n        print(f\"Round {round_num}\")\n\n        # Player gains some points\n        score += 10\n        print(f\"Score: {score}\")\n\n        # BUG 1: round_num never increments! Loop runs forever!\n\n    print()\n    print(\"=== Final Scores ===\")\n\n    # Display score with stars\n    stars_shown = 0\n    while stars_shown < score:  # BUG 2: If score > 0, shows infinite stars!\n        print(\"*\", end=\"\")\n        # stars_shown never increases!\n\n    print()\n    print(f\"Final score: {score}\")\n\n\ndef fixed_game_loop():\n    \"\"\"\n    Fix both infinite loop bugs.\n\n    Bug 1: Add round_num += 1 inside the game loop\n    Bug 2: Add stars_shown += 1 inside the stars loop\n    \"\"\"\n    # ✏️ FIX THE BUGS ✏️\n    #\n    # What I found:\n    # Bug 1: ________________________________\n    # Bug 2: ________________________________\n    pass\n\n\n# ============================================================\n# PART 2: More Problems\n# ============================================================\n# {{CONTEXT_INVESTIGATION_INTRO}}\n# {{CONTEXT_INVESTIGATION_NARRATIVE}}\n#\n# After fixing the freezes, {{friend}} found more issues.\n# Find and fix these additional loop bugs.\n#\n# BUGS TO FIND: 2 more bugs\n\n\ndef buggy_inventory_system():\n    \"\"\"\n    This inventory system has issues. Find the 2 bugs!\n\n    BUG 1: The exit condition is wrong (= instead of ==)\n    BUG 2: Items are added but loop condition never changes\n    \"\"\"\n    inventory = []\n    max_items = 5\n\n    print(\"=== {{hero}}'s Inventory ===\")\n    print(\"Commands: 'add <item>' or 'done'\")\n    print()\n\n    while len(inventory) < max_items:\n        command = input(\"> \")\n\n        # BUG 1: Assignment instead of comparison!\n        if command = \"done\":  # Should be ==\n            break\n\n        if command.startswith(\"add \"):\n            item = command[4:]  # Get text after \"add \"\n            # Items get added correctly\n            print(f\"Added: {item}\")\n            # BUG 2: Forgot to actually add to inventory!\n            # inventory.append(item) is missing!\n        else:\n            print(\"Unknown command\")\n\n    print(f\"Inventory: {inventory}\")\n\n\ndef fixed_inventory_system():\n    \"\"\"\n    Fix both bugs in the inventory system.\n\n    Bug 1: Change = to == in the condition\n    Bug 2: Add inventory.append(item) when adding\n    \"\"\"\n    # ✏️ FIX THE BUGS ✏️\n    #\n    # What I found:\n    # Bug 1: ________________________________\n    # Bug 2: ________________________________\n    pass\n\n\n# ============================================================\n# PART 3: Make It Robust\n# ============================================================\n# {{CONTEXT_IMPROVEMENT_INTRO}}\n# {{CONTEXT_IMPROVEMENT_NARRATIVE}}\n#\n# Now that the bugs are fixed, add input validation\n# to prevent future crashes!\n\n\ndef robust_number_input():\n    \"\"\"\n    Add validation to this number input function.\n    Currently crashes if user enters non-numeric input.\n\n    Requirements:\n    - Ask for a number between 1 and 10\n    - If input is not a number, show error and ask again\n    - If number is out of range, show error and ask again\n    - Return the valid number\n\n    Returns:\n        int: A valid number from 1 to 10\n    \"\"\"\n    # ✏️ ADD INPUT VALIDATION ✏️\n    #\n    # Step 1: Start while True loop\n    # Step 2: Get input\n    # Step 3: Check if input.isdigit()\n    #         If not, print \"Please enter a number.\" and continue\n    # Step 4: Convert to int\n    # Step 5: Check if 1 <= number <= 10\n    #         If not, print \"Number must be 1-10.\" and continue\n    # Step 6: Return the valid number\n    pass\n\n\ndef robust_command_parser():\n    \"\"\"\n    Add validation to this command parser.\n    Currently accepts any input, even garbage.\n\n    Valid commands:\n    - \"attack\" - Attack the {{villain}}\n    - \"defend\" - Defend against attacks\n    - \"heal\" - Restore {{primary_stat}}\n    - \"quit\" - Exit the game\n\n    Requirements:\n    - Show menu of valid commands\n    - If invalid command, show error and valid options\n    - Case insensitive\n    - Return the valid command (lowercase)\n\n    Returns:\n        str: A valid command\n    \"\"\"\n    # ✏️ ADD INPUT VALIDATION ✏️\n    #\n    # Step 1: Define valid_commands list\n    # Step 2: Print the menu\n    # Step 3: Start while True loop\n    # Step 4: Get input and convert to lowercase\n    # Step 5: If in valid_commands, return it\n    # Step 6: Otherwise print \"Invalid. Commands: attack, defend, heal, quit\"\n    pass\n\n\ndef robust_game_menu():\n    \"\"\"\n    Create a complete game menu with full validation.\n\n    Menu options:\n    1. Start new game\n    2. Load game\n    3. Settings\n    4. Quit\n\n    Requirements:\n    - Display numbered menu\n    - Accept number (1-4) or text (e.g., \"start\", \"quit\")\n    - Case insensitive for text\n    - Return the choice as a lowercase string\n\n    Returns:\n        str: \"start\", \"load\", \"settings\", or \"quit\"\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Define menu options mapping\n    #         options = {\"1\": \"start\", \"start\": \"start\", \"new\": \"start\",\n    #                    \"2\": \"load\", \"load\": \"load\", ...}\n    # Step 2: Print menu\n    # Step 3: Start while True loop\n    # Step 4: Get input lowercase\n    # Step 5: If input in options, return options[input]\n    # Step 6: Print \"Invalid choice. Enter 1-4 or command name.\"\n    pass\n\n\n# ============================================================\n# PART 4: The Better Game\n# ============================================================\n# {{CONTEXT_GROWTH_INTRO}}\n# {{CONTEXT_GROWTH_NARRATIVE}}\n#\n# Now build a complete, crash-proof mini-game using\n# everything you've learned!\n\n\ndef battle_game():\n    \"\"\"\n    A simple turn-based battle game with full input validation.\n\n    Game loop:\n    1. Show player and enemy {{primary_stat}}\n    2. Get valid command (attack, defend, heal, quit)\n    3. Process command\n    4. Enemy attacks (if not quit)\n    5. Check for win/lose\n    6. Repeat until someone wins or player quits\n\n    Stats:\n    - Player starts with 30 {{primary_stat}}\n    - {{villain}} starts with 25 {{primary_stat}}\n    - Attack deals 5-8 damage\n    - Defend reduces incoming damage by half\n    - Heal restores 5-10 {{primary_stat}}\n    - {{villain}} always attacks for 3-6 damage\n    \"\"\"\n    import random\n\n    print(\"=\" * 40)\n    print(f\"   {{{{hero}}}} vs {{{{villain}}}}\")\n    print(\"=\" * 40)\n    print()\n\n    player_hp = 30\n    enemy_hp = 25\n    defending = False\n\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # While both player and enemy have {{primary_stat}} > 0:\n    #   1. Display current {{primary_stat}}\n    #   2. Get command with robust_command_parser()\n    #   3. If \"quit\", print farewell and return\n    #   4. Process player action:\n    #      - \"attack\": enemy loses 5-8 {{primary_stat}}\n    #      - \"defend\": set defending = True\n    #      - \"heal\": player gains 5-10 {{primary_stat}}\n    #   5. If enemy still alive, enemy attacks:\n    #      - Base damage = random 3-6\n    #      - If defending, damage = damage // 2\n    #      - Player loses that much {{primary_stat}}\n    #   6. Reset defending to False\n    #   7. Check win/lose conditions\n    #\n    # After loop: Announce winner\n    pass\n\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_SETBACK_INTRO}}\")\n    print(\"=\" * 60)\n    print()\n\n    print(\">>> PART 1: Find the infinite loops...\")\n    print(\"(DON'T RUN buggy_game_loop - it freezes!)\")\n    print(\"(Implement fixed_game_loop)\")\n    print()\n    # Uncomment to test:\n    # fixed_game_loop()\n\n    print()\n    print(\">>> PART 2: Find more bugs...\")\n    print(\"(Note: buggy_inventory_system has a syntax error)\")\n    print(\"(Implement fixed_inventory_system)\")\n    print()\n    # Uncomment to test:\n    # fixed_inventory_system()\n\n    print()\n    print(\">>> PART 3: Add validation...\")\n    print(\"(Implement the robust input functions)\")\n    print()\n    # Uncomment to test:\n    # num = robust_number_input()\n    # print(f\"You entered: {num}\")\n    # cmd = robust_command_parser()\n    # print(f\"Command: {cmd}\")\n    # choice = robust_game_menu()\n    # print(f\"Menu choice: {choice}\")\n\n    print()\n    print(\">>> PART 4: Build the better game...\")\n    print(\"(Implement battle_game)\")\n    print()\n    # Uncomment to test:\n    # battle_game()\n\n    print()\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_TRIUMPH_COMPLETE}}\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "hybrid"
      ],
      "source_file": "module_5_games/hybrid/exercise_2_rescue_stuck_game.py"
    },
    {
      "id": "module_5_games.hybrid.exercise_3_rivalry_guessing",
      "topic_id": "loops.while",
      "exercise_type": "hybrid",
      "category": "hybrid",
      "title": "Rivalry Guessing",
      "title_en": "Rivalry Guessing",
      "title_he": "Rivalry Guessing",
      "description_en": "Games: Rivalry Guessing\n\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise following the journey to build a number guessing game.\nComplete each part in order.\n\nProgramming concepts: while loops, random, comparisons, input validation",
      "description_he": "משחקים: Rivalry Guessing\n\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise following the journey to build a number guessing game.\nComplete each part in order.\n\nProgramming concepts: while loops, random, comparisons, input validation",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "mental_execution",
        "syntax_recall",
        "implementation",
        "pattern_recognition",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise following the journey to build a number guessing game.\nComplete each part in order.\n\nProgramming concepts: while loops, random, comparisons, input validation\n\"\"\"\n\nimport random\n\n\n# ============================================================\n# PART 1: The Broken Game\n# ============================================================\n# {{CONTEXT_SETBACK_NARRATIVE}}\n#\n# {{hero}}'s first attempt at a guessing game had bugs.\n# {{villain}} found all the flaws and exploited them!\n#\n# Find and fix the 3 bugs in the code below.\n#\n# BUGS TO FIND: 3\n\n\ndef buggy_guessing_game():\n    \"\"\"\n    A buggy guessing game. Find the 3 bugs!\n\n    BUG 1: The secret number range is wrong\n    BUG 2: The comparison logic is inverted\n    BUG 3: The guess counter never increases\n    \"\"\"\n    secret = random.randint(0, 9)  # BUG 1: Should be 1-10, not 0-9\n    guesses = 0\n    max_guesses = 5\n\n    print(\"Guess my number (1-10)!\")\n\n    while guesses < max_guesses:\n        guess_str = input(\"Your guess: \")\n\n        if not guess_str.isdigit():\n            print(\"Please enter a number!\")\n            continue\n\n        guess = int(guess_str)\n\n        if guess < secret:  # BUG 2: Logic inverted! < should give \"higher\" hint\n            print(\"Go lower!\")\n        elif guess > secret:\n            print(\"Go higher!\")\n        else:\n            print(f\"Correct! You got it in {guesses} guesses!\")\n            return True\n        # BUG 3: guesses is never incremented!\n\n    print(f\"Out of guesses! The number was {secret}\")\n    return False\n\n\ndef fixed_guessing_game():\n    \"\"\"\n    Fix all 3 bugs from the buggy version.\n\n    Bug fixes needed:\n    1. Secret number should be 1-10 (inclusive)\n    2. Hints should be correct (guess < secret means \"go higher\")\n    3. Increment guesses after each guess\n    \"\"\"\n    # ✏️ FIX THE BUGS ✏️\n    #\n    # What I found:\n    # Bug 1: ________________________________\n    # Bug 2: ________________________________\n    # Bug 3: ________________________________\n    pass\n\n\n# ============================================================\n# PART 2: Building Better\n# ============================================================\n# {{CONTEXT_GROWTH_INTRO}}\n# {{CONTEXT_GROWTH_NARRATIVE}}\n#\n# Now build a proper guessing game with these features:\n# - Configurable range (min to max)\n# - Unlimited guesses\n# - Track guess count\n# - Validate input is within range\n\n\ndef validate_guess(guess_str, min_val, max_val):\n    \"\"\"\n    Validate that a guess string is a valid number within range.\n\n    Args:\n        guess_str: The string input from user\n        min_val: Minimum valid value\n        max_val: Maximum valid value\n\n    Returns:\n        tuple: (is_valid, value_or_error_message)\n            - If valid: (True, integer_value)\n            - If invalid: (False, error_message)\n\n    Examples:\n        validate_guess(\"5\", 1, 10) returns (True, 5)\n        validate_guess(\"abc\", 1, 10) returns (False, \"Not a number\")\n        validate_guess(\"15\", 1, 10) returns (False, \"Out of range (1-10)\")\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Check if guess_str is a digit (use .lstrip('-').isdigit() for negatives)\n    #         If not, return (False, \"Not a number\")\n    # Step 2: Convert to integer\n    # Step 3: Check if in range\n    #         If not, return (False, f\"Out of range ({min_val}-{max_val})\")\n    # Step 4: Return (True, integer_value)\n    pass\n\n\ndef give_hint(guess, secret):\n    \"\"\"\n    Give a hint based on the guess.\n\n    Args:\n        guess: The player's guess\n        secret: The secret number\n\n    Returns:\n        str: \"higher\", \"lower\", or \"correct\"\n\n    Also prints an appropriate message:\n        \"Too low! Guess higher.\"\n        \"Too high! Guess lower.\"\n        \"{{exclamation}} Correct!\"\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Compare guess to secret and return/print appropriate response\n    pass\n\n\ndef play_guessing_round(min_val, max_val):\n    \"\"\"\n    Play one round of the guessing game.\n\n    Args:\n        min_val: Minimum value for secret number\n        max_val: Maximum value for secret number\n\n    Returns:\n        int: Number of guesses it took to win\n\n    Game flow:\n    1. Generate secret number\n    2. Loop: get guess, validate, give hint\n    3. Continue until correct\n    4. Return guess count\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Generate secret with random.randint(min_val, max_val)\n    # Step 2: Initialize guess_count = 0\n    # Step 3: Loop until guessed correctly:\n    #         - Get input\n    #         - Validate with validate_guess()\n    #         - If invalid, print error and continue\n    #         - Increment guess_count\n    #         - Get hint with give_hint()\n    #         - If correct, break\n    # Step 4: Return guess_count\n    pass\n\n\n# ============================================================\n# PART 3: The Championship\n# ============================================================\n# {{CONTEXT_CONFRONTATION_INTRO}}\n# {{CONTEXT_CONFRONTATION_NARRATIVE}}\n#\n# Build the complete championship guessing game:\n# - Best of 3 rounds\n# - Track wins for {{hero}} and {{villain}}\n# - {{villain}} guesses using a simple strategy\n# - Whoever guesses in fewer tries wins the round\n\n\ndef computer_guess(min_val, max_val, secret):\n    \"\"\"\n    Simulate {{villain}}'s guessing strategy (binary search).\n\n    Args:\n        min_val: Current minimum possibility\n        max_val: Current maximum possibility\n        secret: The secret number (to determine result)\n\n    Returns:\n        tuple: (guess, new_min, new_max)\n\n    Strategy: Always guess the middle value\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Calculate middle = (min_val + max_val) // 2\n    # Step 2: If middle < secret, new range is (middle + 1, max_val)\n    # Step 3: If middle > secret, new range is (min_val, middle - 1)\n    # Step 4: Return (middle, new_min, new_max)\n    pass\n\n\ndef computer_play_round(min_val, max_val):\n    \"\"\"\n    {{villain}} plays a guessing round using binary search.\n\n    Args:\n        min_val: Minimum value\n        max_val: Maximum value\n\n    Returns:\n        int: Number of guesses to find the secret\n    \"\"\"\n    secret = random.randint(min_val, max_val)\n    guesses = 0\n    current_min = min_val\n    current_max = max_val\n\n    print(f\"\\n{{{{villain}}}}'s turn! (Secret: {secret})\")\n\n    while True:\n        guess, current_min, current_max = computer_guess(\n            current_min, current_max, secret\n        )\n        guesses += 1\n        print(f\"{{{{villain}}}} guesses: {guess}\")\n\n        if guess == secret:\n            print(f\"{{{{villain}}}} got it in {guesses} guesses!\")\n            return guesses\n        elif guess < secret:\n            print(\"Too low...\")\n        else:\n            print(\"Too high...\")\n\n\ndef championship_match():\n    \"\"\"\n    The championship: {{hero}} vs {{villain}} in best of 3!\n\n    Game structure:\n    - 3 rounds, each with range 1-100\n    - Each round: both players guess a NEW secret number\n    - Fewer guesses wins the round\n    - First to 2 round wins takes the championship\n\n    Display:\n    - Current score before each round\n    - Winner of each round\n    - Final champion announcement\n    \"\"\"\n    print(\"=\" * 50)\n    print(\"   GUESSING CHAMPIONSHIP\")\n    print(f\"   {{{{hero}}}} vs {{{{villain}}}}\")\n    print(\"=\" * 50)\n    print()\n\n    hero_wins = 0\n    villain_wins = 0\n    round_num = 0\n\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # While neither player has 2 wins:\n    #   1. Increment round number\n    #   2. Print round header and current score\n    #   3. {{hero}} guesses (use play_guessing_round)\n    #   4. {{villain}} guesses (use computer_play_round)\n    #   5. Compare guess counts, award point to winner\n    #   6. Announce round winner\n    #\n    # After loop: Announce championship winner\n    pass\n\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_SETBACK_INTRO}}\")\n    print(\"=\" * 60)\n    print()\n\n    print(\">>> PART 1: Fix the broken game...\")\n    print(\"(Review buggy_guessing_game() and implement fixed_guessing_game())\")\n    print()\n    # Uncomment to test:\n    # fixed_guessing_game()\n\n    print()\n    print(\">>> PART 2: Build better validation and hints...\")\n    print(\"(Implement validate_guess, give_hint, play_guessing_round)\")\n    print()\n    # Uncomment to test:\n    # guesses = play_guessing_round(1, 20)\n    # print(f\"You won in {guesses} guesses!\")\n\n    print()\n    print(\">>> PART 3: The Championship awaits...\")\n    print(\"(Implement computer_guess and championship_match)\")\n    print()\n    # Uncomment to test:\n    # championship_match()\n\n    print()\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_TRIUMPH_COMPLETE}}\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "hybrid"
      ],
      "source_file": "module_5_games/hybrid/exercise_3_rivalry_guessing.py"
    },
    {
      "id": "module_5_games.hybrid.exercise_4_rivalry_rps",
      "topic_id": "loops.while",
      "exercise_type": "hybrid",
      "category": "hybrid",
      "title": "Rivalry Rps",
      "title_en": "Rivalry Rps",
      "title_he": "Rivalry Rps",
      "description_en": "Games: Rivalry Rps\n\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise building Rock Paper Scissors.\nComplete each part to go from buggy code to a full game!\n\nProgramming concepts: while loops, random, conditionals, game state",
      "description_he": "משחקים: Rivalry Rps\n\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise building Rock Paper Scissors.\nComplete each part to go from buggy code to a full game!\n\nProgramming concepts: while loops, random, conditionals, game state",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "mental_execution",
        "syntax_recall",
        "implementation",
        "pattern_recognition",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise building Rock Paper Scissors.\nComplete each part to go from buggy code to a full game!\n\nProgramming concepts: while loops, random, conditionals, game state\n\"\"\"\n\nimport random\n\n\n# ============================================================\n# PART 1: The Buggy RPS\n# ============================================================\n# {{CONTEXT_SETBACK_NARRATIVE}}\n#\n# {{hero}}'s first RPS game had bugs. {{villain}} exploited them!\n# Find and fix the 3 bugs.\n#\n# BUGS TO FIND: 3\n\n\ndef buggy_determine_winner(player, computer):\n    \"\"\"\n    Determine who wins a round.\n\n    BUG 1: Paper vs Rock gives wrong result\n    BUG 2: Computer winning is never detected properly\n    BUG 3: Ties return inconsistent result\n    \"\"\"\n    # BUG 1: Wrong comparison - paper vs rock\n    if player == \"rock\" and computer == \"scissors\":\n        return \"player\"\n    elif player == \"paper\" and computer == \"scissors\":  # BUG: should be rock!\n        return \"player\"\n    elif player == \"scissors\" and computer == \"paper\":\n        return \"player\"\n    # BUG 2: These conditions are duplicates of player wins!\n    elif player == \"rock\" and computer == \"paper\":\n        return \"player\"  # BUG: Should return \"computer\"!\n    elif player == \"paper\" and computer == \"scissors\":\n        return \"computer\"\n    elif player == \"scissors\" and computer == \"rock\":\n        return \"computer\"\n    # BUG 3: Missing the equals case properly\n    else:\n        return None  # BUG: Should explicitly check for tie\n\n\ndef buggy_play_rps():\n    \"\"\"Play one round of buggy RPS.\"\"\"\n    choices = [\"rock\", \"paper\", \"scissors\"]\n\n    player = input(\"Choose (rock/paper/scissors): \").lower()\n    computer = random.choice(choices)\n\n    print(f\"You chose: {player}\")\n    print(f\"{{{{villain}}}} chose: {computer}\")\n\n    result = buggy_determine_winner(player, computer)\n    if result == \"player\":\n        print(\"You win!\")\n    elif result == \"computer\":\n        print(\"{{{{villain}}}} wins!\")\n    else:\n        print(\"It's a tie!\")\n\n\ndef fixed_determine_winner(player, computer):\n    \"\"\"\n    Fix all 3 bugs in the winner determination.\n\n    Bug fixes:\n    1. Paper beats Rock (not scissors)\n    2. Computer wins need correct return value\n    3. Explicitly check for ties first\n    \"\"\"\n    # ✏️ FIX THE BUGS ✏️\n    #\n    # Hint: Check ties first with player == computer\n    # Then check all three player win conditions\n    # Then the remaining cases are computer wins\n    pass\n\n\n# ============================================================\n# PART 2: Build the Core\n# ============================================================\n# {{CONTEXT_GROWTH_INTRO}}\n# {{CONTEXT_GROWTH_NARRATIVE}}\n#\n# Build proper RPS functions from scratch.\n\n\ndef get_player_choice():\n    \"\"\"\n    Get a valid choice from the player.\n\n    Returns:\n        str: \"rock\", \"paper\", or \"scissors\"\n\n    Requirements:\n    - Keep asking until valid choice\n    - Case insensitive\n    - Accept 'r', 'p', 's' as shortcuts\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Define valid_choices and shortcuts\n    #         shortcuts = {'r': 'rock', 'p': 'paper', 's': 'scissors'}\n    # Step 2: While True loop\n    # Step 3: Get input, lowercase\n    # Step 4: Check if in shortcuts, convert\n    # Step 5: Check if in valid_choices\n    # Step 6: If valid, return. Otherwise print error.\n    pass\n\n\ndef get_computer_choice():\n    \"\"\"\n    Get a random choice for the computer.\n\n    Returns:\n        str: \"rock\", \"paper\", or \"scissors\"\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef play_round():\n    \"\"\"\n    Play one round of RPS.\n\n    Returns:\n        str: \"player\", \"computer\", or \"tie\"\n\n    Should:\n    - Get player choice\n    - Get computer choice\n    - Print both choices with {{villain}} for computer\n    - Determine and announce winner\n    - Return the result\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Get player choice\n    # Step 2: Get computer choice\n    # Step 3: Print choices (use {{villain}} for computer)\n    # Step 4: Determine winner using fixed_determine_winner\n    # Step 5: Announce result\n    # Step 6: Return result\n    pass\n\n\n# ============================================================\n# PART 3: The Championship\n# ============================================================\n# {{CONTEXT_CONFRONTATION_INTRO}}\n# {{CONTEXT_CONFRONTATION_NARRATIVE}}\n#\n# Build the complete best-of game with:\n# - Score tracking\n# - Play-again loop\n# - Match statistics\n\n\ndef display_score(player_score, computer_score, ties):\n    \"\"\"\n    Display the current score nicely.\n\n    Format:\n        ==================\n        {{hero}}: 2 | {{villain}}: 1 | Ties: 0\n        ==================\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef play_match(rounds_to_win):\n    \"\"\"\n    Play a match - first to rounds_to_win wins.\n\n    Args:\n        rounds_to_win: Number of wins needed\n\n    Returns:\n        str: \"player\" or \"computer\" (the winner)\n\n    Track:\n    - Player wins\n    - Computer wins\n    - Ties\n    - Total rounds played\n\n    Display score after each round.\n    Announce winner when someone reaches rounds_to_win.\n    \"\"\"\n    print(f\"\\n=== First to {rounds_to_win} wins! ===\\n\")\n\n    player_wins = 0\n    computer_wins = 0\n    ties = 0\n\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # While neither player has enough wins:\n    #   1. Play a round\n    #   2. Update appropriate counter\n    #   3. Display current score\n    #   4. Check for winner\n    #\n    # After loop: Announce match winner\n    pass\n\n\ndef championship():\n    \"\"\"\n    The full championship experience!\n\n    Structure:\n    - Welcome message\n    - Ask for match length (best of 3, 5, or 7)\n    - Play match\n    - Show final stats\n    - Ask to play again\n    \"\"\"\n    print(\"=\" * 50)\n    print(\"   ROCK PAPER SCISSORS CHAMPIONSHIP\")\n    print(f\"   {{{{hero}}}} vs {{{{villain}}}}\")\n    print(\"=\" * 50)\n\n    total_games = 0\n    player_championships = 0\n    villain_championships = 0\n\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Play again loop:\n    #   1. Ask for match length (1, 2, or 3 for best of 3/5/7)\n    #   2. Convert to rounds_to_win (2, 3, or 4)\n    #   3. Play match\n    #   4. Update championship stats\n    #   5. Show overall record\n    #   6. Ask to play again\n    #\n    # Final: Show farewell and final record\n    pass\n\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_SETBACK_INTRO}}\")\n    print(\"=\" * 60)\n    print()\n\n    print(\">>> PART 1: Fix the buggy RPS...\")\n    print(\"(Review buggy_determine_winner and implement fixed version)\")\n    print()\n    # Test the fix:\n    # print(\"Testing fixed winner logic:\")\n    # test_cases = [\n    #     (\"rock\", \"scissors\", \"player\"),\n    #     (\"paper\", \"rock\", \"player\"),\n    #     (\"scissors\", \"paper\", \"player\"),\n    #     (\"rock\", \"paper\", \"computer\"),\n    #     (\"paper\", \"scissors\", \"computer\"),\n    #     (\"scissors\", \"rock\", \"computer\"),\n    #     (\"rock\", \"rock\", \"tie\"),\n    # ]\n    # for p, c, expected in test_cases:\n    #     result = fixed_determine_winner(p, c)\n    #     status = \"OK\" if result == expected else \"FAIL\"\n    #     print(f\"  {p} vs {c}: {result} ({status})\")\n\n    print()\n    print(\">>> PART 2: Build the core game...\")\n    print(\"(Implement get_player_choice, get_computer_choice, play_round)\")\n    print()\n    # Uncomment to test:\n    # result = play_round()\n    # print(f\"Result: {result}\")\n\n    print()\n    print(\">>> PART 3: The Championship awaits...\")\n    print(\"(Implement display_score, play_match, championship)\")\n    print()\n    # Uncomment to play:\n    # championship()\n\n    print()\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_TRIUMPH_COMPLETE}}\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "hybrid"
      ],
      "source_file": "module_5_games/hybrid/exercise_4_rivalry_rps.py"
    },
    {
      "id": "module_5_games.hybrid.exercise_5_rescue_adventure",
      "topic_id": "loops.while",
      "exercise_type": "hybrid",
      "category": "hybrid",
      "title": "Rescue Adventure",
      "title_en": "Rescue Adventure",
      "title_he": "Rescue Adventure",
      "description_en": "Games: Rescue Adventure\n\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise rescuing a text adventure game.\nFind bugs, debug navigation, add error handling, then extend it!\n\nProgramming concepts: while loops, dictionaries (preview), command parsing, game state",
      "description_he": "משחקים: Rescue Adventure\n\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise rescuing a text adventure game.\nFind bugs, debug navigation, add error handling, then extend it!\n\nProgramming concepts: while loops, dictionaries (preview), command parsing, game state",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "mental_execution",
        "syntax_recall",
        "implementation",
        "pattern_recognition",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_SETBACK_INTRO}}\n\nThis is a multi-part exercise rescuing a text adventure game.\nFind bugs, debug navigation, add error handling, then extend it!\n\nProgramming concepts: while loops, dictionaries (preview), command parsing, game state\n\"\"\"\n\n\n# ============================================================\n# PART 1: The Broken Adventure\n# ============================================================\n# {{CONTEXT_SETBACK_NARRATIVE}}\n#\n# {{friend}}'s text adventure has critical bugs.\n# Players get stuck and the game crashes!\n#\n# BUGS TO FIND: 3\n\n\n# Game world (simplified - no dictionaries, use parallel lists)\nROOM_NAMES = [\"entrance\", \"hallway\", \"treasure_room\", \"exit\"]\nROOM_DESCRIPTIONS = [\n    \"You are at the entrance of {{location}}.\",\n    \"A long hallway stretches before you.\",\n    \"{{exclamation}} A treasure chest gleams!\",\n    \"The exit! Fresh air awaits.\"\n]\n# Connections: index = from room, value = [north, south, east, west] or -1 if blocked\nROOM_CONNECTIONS = [\n    [-1, -1, 1, -1],   # entrance: east to hallway\n    [2, -1, 3, 0],     # hallway: north to treasure, east to exit, west to entrance\n    [-1, 1, -1, -1],   # treasure: south to hallway\n    [-1, -1, -1, 1]    # exit: west to hallway\n]\n\n\ndef buggy_get_room_description(room_index):\n    \"\"\"Get description for a room. BUG: No bounds checking!\"\"\"\n    return ROOM_DESCRIPTIONS[room_index]  # BUG 1: Crashes if index out of range\n\n\ndef buggy_move(current_room, direction):\n    \"\"\"\n    Move in a direction.\n\n    BUG 2: Direction mapping is wrong\n    BUG 3: Returns wrong room on blocked path\n    \"\"\"\n    # BUG 2: Direction indices are wrong!\n    direction_index = {\n        \"north\": 2,  # Should be 0\n        \"south\": 0,  # Should be 1\n        \"east\": 3,   # Should be 2\n        \"west\": 1    # Should be 3\n    }\n\n    if direction not in direction_index:\n        return current_room\n\n    idx = direction_index[direction]\n    next_room = ROOM_CONNECTIONS[current_room][idx]\n\n    # BUG 3: Returns -1 instead of current_room when blocked!\n    return next_room  # Should check if -1 and return current_room\n\n\ndef buggy_adventure():\n    \"\"\"Play the buggy adventure.\"\"\"\n    current_room = 0\n    print(\"=== {{school}} Adventure ===\")\n    print(buggy_get_room_description(current_room))\n\n    while current_room != 3:  # Exit is room 3\n        command = input(\"\\n> \").lower().strip()\n\n        if command in [\"north\", \"south\", \"east\", \"west\"]:\n            new_room = buggy_move(current_room, command)\n            if new_room == current_room:\n                print(\"You can't go that way.\")\n            else:\n                current_room = new_room\n                print(buggy_get_room_description(current_room))\n        elif command == \"look\":\n            print(buggy_get_room_description(current_room))\n        elif command == \"quit\":\n            break\n        else:\n            print(\"Unknown command.\")\n\n    print(\"\\nThanks for playing!\")\n\n\ndef fixed_get_room_description(room_index):\n    \"\"\"\n    Fix Bug 1: Add bounds checking.\n\n    Return \"Invalid room\" if index out of range.\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    pass\n\n\ndef fixed_move(current_room, direction):\n    \"\"\"\n    Fix Bugs 2 and 3:\n    - Correct direction indices\n    - Return current_room when blocked (not -1)\n    \"\"\"\n    # ✏️ FIX THE BUGS ✏️\n    pass\n\n\n# ============================================================\n# PART 2: Debug the Navigation\n# ============================================================\n# {{CONTEXT_INVESTIGATION_INTRO}}\n# {{CONTEXT_INVESTIGATION_NARRATIVE}}\n#\n# The movement system has more subtle bugs.\n# Find and fix these navigation issues.\n\n\ndef buggy_parse_command(command_string):\n    \"\"\"\n    Parse a movement command.\n\n    BUGS:\n    1. Doesn't handle extra spaces\n    2. Doesn't handle \"go north\" style commands\n    \"\"\"\n    # BUG 1: No stripping of extra spaces\n    # BUG 2: Doesn't extract direction from \"go north\"\n    parts = command_string.split()\n    if len(parts) == 1:\n        return parts[0]\n    return None  # Fails on \"go north\"\n\n\ndef fixed_parse_command(command_string):\n    \"\"\"\n    Fix command parsing to handle:\n    - Extra spaces\n    - \"go <direction>\" format\n    - Just \"<direction>\" format\n    - Return None for invalid commands\n    \"\"\"\n    # ✏️ FIX THE BUGS ✏️\n    #\n    # Step 1: Strip and lowercase\n    # Step 2: Split into parts\n    # Step 3: If one part and it's a direction, return it\n    # Step 4: If two parts and first is \"go\", return second if valid\n    # Step 5: Otherwise return None\n    pass\n\n\ndef buggy_check_item(room_index, has_treasure):\n    \"\"\"\n    Check for items in the room.\n\n    BUG: Always says no treasure even in treasure room!\n    \"\"\"\n    if room_index == 2:  # Treasure room\n        if has_treasure:  # BUG: Logic inverted! Should be \"not has_treasure\"\n            return False\n        print(\"You found the treasure!\")\n        return True\n    return has_treasure\n\n\ndef fixed_check_item(room_index, has_treasure):\n    \"\"\"\n    Fix the item check logic.\n\n    Should return True if player now has treasure.\n    Should only find treasure if in room 2 AND don't already have it.\n    \"\"\"\n    # ✏️ FIX THE BUG ✏️\n    pass\n\n\n# ============================================================\n# PART 3: Add Error Handling\n# ============================================================\n# {{CONTEXT_IMPROVEMENT_INTRO}}\n# {{CONTEXT_IMPROVEMENT_NARRATIVE}}\n#\n# Make the adventure crash-proof!\n\n\ndef safe_get_input(prompt, valid_commands):\n    \"\"\"\n    Get input with validation.\n\n    Args:\n        prompt: What to display\n        valid_commands: List of valid command strings\n\n    Returns:\n        str: A valid command\n\n    Requirements:\n    - Show prompt\n    - Validate input is in valid_commands\n    - Show helpful error with valid options\n    - Keep asking until valid\n    \"\"\"\n    # ✏️ ADD ERROR HANDLING ✏️\n    pass\n\n\ndef safe_move_with_feedback(current_room, direction):\n    \"\"\"\n    Move with clear feedback messages.\n\n    Args:\n        current_room: Current room index\n        direction: Direction string\n\n    Returns:\n        tuple: (new_room, message)\n\n    Messages:\n    - Invalid direction: \"Unknown direction: {direction}\"\n    - Blocked: \"You can't go {direction} from here.\"\n    - Success: \"You move {direction}.\"\n    \"\"\"\n    # ✏️ ADD ERROR HANDLING ✏️\n    pass\n\n\ndef robust_adventure_loop(starting_room):\n    \"\"\"\n    A robust game loop that handles all errors gracefully.\n\n    Args:\n        starting_room: Room index to start in\n\n    Features:\n    - Clear command menu\n    - Handles unknown commands\n    - Tracks items (treasure)\n    - Win condition (exit with treasure)\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Variables:\n    # - current_room = starting_room\n    # - has_treasure = False\n    # - playing = True\n    #\n    # While playing:\n    #   1. Show current room description\n    #   2. Show commands: north/south/east/west/look/inventory/quit\n    #   3. Get input\n    #   4. Process command:\n    #      - directions: move and show feedback\n    #      - look: show description\n    #      - inventory: show if has treasure\n    #      - quit: set playing = False\n    #   5. Check for treasure\n    #   6. Check win condition (at exit with treasure)\n    pass\n\n\n# ============================================================\n# PART 4: Extend the Adventure\n# ============================================================\n# {{CONTEXT_GROWTH_INTRO}}\n# {{CONTEXT_GROWTH_NARRATIVE}}\n#\n# Add new features to make the adventure better!\n\n\ndef add_enemy_encounter(room_index):\n    \"\"\"\n    Check if there's an enemy in this room.\n\n    Args:\n        room_index: Current room\n\n    Returns:\n        bool: True if enemy encountered\n\n    Enemies appear in hallway (room 1) with 30% chance.\n    Print encounter message if enemy appears.\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef simple_combat():\n    \"\"\"\n    Simple combat encounter.\n\n    Returns:\n        bool: True if player survives\n\n    Combat:\n    - Player has 10 HP\n    - Enemy has 5 HP\n    - Each round: player attacks (2-4 damage), enemy attacks (1-3 damage)\n    - Continue until someone reaches 0 HP\n    - Print combat messages\n    \"\"\"\n    import random\n\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef enhanced_adventure():\n    \"\"\"\n    The complete enhanced adventure!\n\n    New features:\n    - Random enemy encounters\n    - Simple combat\n    - Score tracking\n    - Play again option\n    \"\"\"\n    import random\n\n    print(\"=\" * 50)\n    print(f\"   {{{{school}}}} ADVENTURE\")\n    print(\"   Enhanced Edition\")\n    print(\"=\" * 50)\n    print()\n    print(f\"{{{{hero}}}} seeks treasure in {{{{location}}}}!\")\n    print(\"Find the treasure and escape!\")\n    print()\n\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Game loop:\n    # 1. Start in entrance (room 0)\n    # 2. Track: current_room, has_treasure, score, hp\n    # 3. Each room:\n    #    - Check for enemy encounter\n    #    - If enemy, run combat\n    #    - If defeated, game over\n    # 4. Movement and treasure collection\n    # 5. Win: reach exit with treasure\n    # 6. Track high scores\n    # 7. Play again option\n    pass\n\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_SETBACK_INTRO}}\")\n    print(\"=\" * 60)\n    print()\n\n    print(\">>> PART 1: Fix the broken adventure...\")\n    print(\"(DON'T RUN buggy_adventure - it has issues!)\")\n    print(\"(Implement fixed_get_room_description and fixed_move)\")\n    print()\n    # Test fixes:\n    # print(fixed_get_room_description(0))  # Should work\n    # print(fixed_get_room_description(99))  # Should say \"Invalid room\"\n    # print(fixed_move(0, \"east\"))  # Should return 1 (hallway)\n    # print(fixed_move(0, \"north\"))  # Should return 0 (blocked)\n\n    print()\n    print(\">>> PART 2: Debug navigation...\")\n    print(\"(Implement fixed_parse_command and fixed_check_item)\")\n    print()\n    # Test:\n    # print(fixed_parse_command(\"  go  north  \"))  # Should return \"north\"\n    # print(fixed_parse_command(\"east\"))  # Should return \"east\"\n\n    print()\n    print(\">>> PART 3: Add error handling...\")\n    print(\"(Implement safe functions and robust_adventure_loop)\")\n    print()\n    # robust_adventure_loop(0)\n\n    print()\n    print(\">>> PART 4: Build the enhanced adventure...\")\n    print(\"(Implement all enhancements)\")\n    print()\n    # enhanced_adventure()\n\n    print()\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_TRIUMPH_COMPLETE}}\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "hybrid"
      ],
      "source_file": "module_5_games/hybrid/exercise_5_rescue_adventure.py"
    },
    {
      "id": "module_5_games.hybrid.exercise_6_project_your_game",
      "topic_id": "loops.while",
      "exercise_type": "hybrid",
      "category": "hybrid",
      "title": "Project Your Game",
      "title_en": "Project Your Game",
      "title_he": "Project Your Game",
      "description_en": "Games: Project Your Game\n\n{{CONTEXT_OWNERSHIP_INTRO}}\n\nThis is your capstone project: Build Your Own Game!\nFollow the guided steps to create a complete, polished game.\n\nProgramming concepts: Everything from Module 5!",
      "description_he": "משחקים: Project Your Game\n\n{{CONTEXT_OWNERSHIP_INTRO}}\n\nThis is your capstone project: Build Your Own Game!\nFollow the guided steps to create a complete, polished game.\n\nProgramming concepts: Everything from Module 5!",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 15,
      "skills": [
        "mental_execution",
        "syntax_recall",
        "implementation",
        "pattern_recognition",
        "independence"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_OWNERSHIP_INTRO}}\n\nThis is your capstone project: Build Your Own Game!\nFollow the guided steps to create a complete, polished game.\n\nProgramming concepts: Everything from Module 5!\n\"\"\"\n\nimport random\n\n\n# ============================================================\n# PART 1: Design Your Game\n# ============================================================\n# {{CONTEXT_OWNERSHIP_NARRATIVE}}\n#\n# Before coding, design your game!\n#\n# Answer these questions (in comments or on paper):\n# 1. What is your game about? (theme, story)\n# 2. What does the player do? (actions, goals)\n# 3. How does the player win? (win condition)\n# 4. How does the player lose? (lose condition, or none?)\n# 5. What makes it fun? (randomness, choices, challenge)\n\n\n\"\"\"\nMY GAME DESIGN\n--------------\nTheme: ________________________________\nGoal: ________________________________\nWin condition: ________________________________\nLose condition: ________________________________\nCore mechanic: ________________________________\n\nPlayer actions:\n1. ________________________________\n2. ________________________________\n3. ________________________________\n\nGame state to track:\n- ________________________________\n- ________________________________\n- ________________________________\n\"\"\"\n\n\n# ============================================================\n# PART 2: Build the Core\n# ============================================================\n# {{CONTEXT_GROWTH_INTRO}}\n# {{CONTEXT_GROWTH_NARRATIVE}}\n#\n# Implement the basic game mechanics.\n\n\ndef initialize_game():\n    \"\"\"\n    Set up the initial game state.\n\n    Returns:\n        dict: Initial game state\n\n    Include whatever your game needs:\n    - Player stats (hp, score, level, etc.)\n    - Game progress (round, turn, etc.)\n    - Any other state variables\n\n    Example structure:\n        {\n            \"player_hp\": 100,\n            \"score\": 0,\n            \"round\": 1,\n            \"playing\": True\n        }\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create and return your initial game state\n    pass\n\n\ndef display_status(game_state):\n    \"\"\"\n    Show the current game status to the player.\n\n    Args:\n        game_state: Your game state dictionary\n\n    Display whatever is relevant:\n    - Health/lives\n    - Score/progress\n    - Current situation\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef get_player_input(game_state):\n    \"\"\"\n    Get the player's next action.\n\n    Args:\n        game_state: Current game state (might affect available actions)\n\n    Returns:\n        str: The valid action chosen\n\n    Requirements:\n    - Show available actions\n    - Validate input\n    - Return a valid action string\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Define your valid actions\n    # Show menu\n    # Get and validate input\n    # Return the action\n    pass\n\n\ndef process_action(game_state, action):\n    \"\"\"\n    Process the player's chosen action.\n\n    Args:\n        game_state: Current game state (will be modified)\n        action: The action string\n\n    Returns:\n        str: Message describing what happened\n\n    This is where your game logic lives!\n    Update game_state based on the action.\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Handle each possible action\n    # Update game_state appropriately\n    # Return a description of what happened\n    pass\n\n\n# ============================================================\n# PART 3: Add Win/Lose Conditions\n# ============================================================\n# {{CONTEXT_IMPROVEMENT_INTRO}}\n# {{CONTEXT_IMPROVEMENT_NARRATIVE}}\n#\n# Define when the game ends.\n\n\ndef check_win(game_state):\n    \"\"\"\n    Check if the player has won.\n\n    Args:\n        game_state: Current game state\n\n    Returns:\n        bool: True if player has won\n\n    What triggers a win in your game?\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef check_lose(game_state):\n    \"\"\"\n    Check if the player has lost.\n\n    Args:\n        game_state: Current game state\n\n    Returns:\n        bool: True if player has lost\n\n    What triggers a loss in your game?\n    (Return False if your game has no lose condition)\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef display_end_message(game_state, won):\n    \"\"\"\n    Show the appropriate end-game message.\n\n    Args:\n        game_state: Final game state\n        won: True if player won, False if lost\n\n    Include:\n    - Win/lose message\n    - Final stats (score, etc.)\n    - Any achievements\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\n# ============================================================\n# PART 4: Make It Crash-Proof\n# ============================================================\n# {{CONTEXT_IMPROVEMENT_NARRATIVE}}\n#\n# Add validation and error handling throughout.\n\n\ndef validate_game_state(game_state):\n    \"\"\"\n    Ensure game state is valid.\n\n    Args:\n        game_state: The state to validate\n\n    Returns:\n        bool: True if valid\n\n    Check for:\n    - Required keys exist\n    - Values are in valid ranges\n    - No corruption\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef safe_update_stat(game_state, stat_name, change, min_val=0, max_val=None):\n    \"\"\"\n    Safely update a game stat with bounds checking.\n\n    Args:\n        game_state: Game state dict\n        stat_name: Key to update\n        change: Amount to add (can be negative)\n        min_val: Minimum allowed value\n        max_val: Maximum allowed value (None = no max)\n\n    Ensures stat stays within bounds.\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\n# ============================================================\n# PART 5: Add Polish\n# ============================================================\n# {{CONTEXT_GROWTH_NARRATIVE}}\n#\n# Make your game feel complete!\n\n\ndef display_intro():\n    \"\"\"\n    Show the game introduction.\n\n    Include:\n    - Game title\n    - Brief story/context\n    - How to play\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Create an engaging introduction for your game\n    # Use {{placeholders}} for theme-agnostic content!\n    pass\n\n\ndef display_help():\n    \"\"\"\n    Show help/instructions.\n\n    List:\n    - All commands\n    - Game rules\n    - Tips\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef ask_play_again():\n    \"\"\"\n    Ask if the player wants to play again.\n\n    Returns:\n        bool: True if yes\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\n# ============================================================\n# PART 6: The Complete Game\n# ============================================================\n# {{CONTEXT_TRIUMPH_COMPLETE}}\n#\n# Put it all together!\n\n\ndef game_loop(game_state):\n    \"\"\"\n    The main game loop.\n\n    Args:\n        game_state: Initial game state\n\n    Loop structure:\n    1. Display status\n    2. Check win/lose conditions\n    3. Get player input\n    4. Process action\n    5. Repeat until game ends\n    \"\"\"\n    while game_state.get(\"playing\", True):\n        # ✏️ YOUR CODE HERE ✏️\n        #\n        # 1. Display current status\n        # 2. Check win condition\n        #    If won: display_end_message, break\n        # 3. Check lose condition\n        #    If lost: display_end_message, break\n        # 4. Get player action\n        # 5. If action is \"quit\", break\n        # 6. Process action\n        # 7. Display result message\n        pass\n\n\ndef play_game():\n    \"\"\"\n    Run the complete game experience.\n\n    Structure:\n    1. Display intro\n    2. Initialize game\n    3. Run game loop\n    4. Ask play again\n    5. Repeat or exit\n    \"\"\"\n    display_intro()\n\n    playing = True\n    while playing:\n        game_state = initialize_game()\n\n        if game_state is None:\n            print(\"Failed to initialize game!\")\n            break\n\n        game_loop(game_state)\n\n        playing = ask_play_again()\n\n    print(\"\\nThanks for playing!\")\n    print(f\"{{{{exclamation}}}} Until next time!\")\n\n\n# ============================================================\n# MAIN\n# ============================================================\n\ndef main():\n    print(\"=\" * 60)\n    print(\"   BUILD YOUR OWN GAME\")\n    print(\"   Module 5 Capstone Project\")\n    print(\"=\" * 60)\n    print()\n\n    print(\">>> PART 1: Design your game (see comments above)\")\n    print()\n\n    print(\">>> PART 2: Build the core\")\n    print(\"(Implement initialize_game, display_status, get_player_input, process_action)\")\n    print()\n    # Test core:\n    # state = initialize_game()\n    # display_status(state)\n    # action = get_player_input(state)\n    # result = process_action(state, action)\n    # print(result)\n\n    print(\">>> PART 3: Add win/lose conditions\")\n    print(\"(Implement check_win, check_lose, display_end_message)\")\n    print()\n\n    print(\">>> PART 4: Make it crash-proof\")\n    print(\"(Implement validate_game_state, safe_update_stat)\")\n    print()\n\n    print(\">>> PART 5: Add polish\")\n    print(\"(Implement display_intro, display_help, ask_play_again)\")\n    print()\n\n    print(\">>> PART 6: Launch your game!\")\n    print()\n    # play_game()\n\n    print(\"=\" * 60)\n    print(\"{{CONTEXT_TRIUMPH_COMPLETE}}\")\n    print(\"=\" * 60)\n\n\nif __name__ == \"__main__\":\n    main()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "hybrid"
      ],
      "source_file": "module_5_games/hybrid/exercise_6_project_your_game.py"
    },
    {
      "id": "module_5_games.write_code.exercise_1_basic_while",
      "topic_id": "loops.while",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Basic While",
      "title_en": "Basic While",
      "title_he": "Basic While",
      "description_en": "Games: Basic While\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Basic while loops with counter variables\nDifficulty: 1-2\n\nIn this exercise, you'll learn the fundamental pattern of while loops:\nsetting up a counter, checking a condition, and updating the counter.",
      "description_he": "משחקים: Basic While\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Basic while loops with counter variables\nDifficulty: 1-2\n\nIn this exercise, you'll learn the fundamental pattern of while loops:\nsetting up a counter, checking a condition, and updating the counter.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Basic while loops with counter variables\nDifficulty: 1-2\n\nIn this exercise, you'll learn the fundamental pattern of while loops:\nsetting up a counter, checking a condition, and updating the counter.\n\"\"\"\n\n\n# ============================================================\n# {{PHASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n#\n# A while loop repeats as long as its condition is True.\n# The pattern: initialize -> check condition -> do work -> update\n\n\ndef countdown_from_five():\n    \"\"\"\n    Print a countdown from 5 to 1, then print a final message.\n\n    Expected output:\n        5\n        4\n        3\n        2\n        1\n        {{exclamation}}\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create a variable called 'count' starting at 5\n    # Step 2: While count is greater than 0:\n    #         - Print the current count\n    #         - Decrease count by 1\n    # Step 3: After the loop, print \"{{exclamation}}\"\n    #\n    # Hint: Don't forget to decrease count, or the loop never ends!\n    pass\n\n\n# ============================================================\n# {{PHASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n#\n# While loops are perfect for counting up to a target.\n\n\ndef count_up_to(target):\n    \"\"\"\n    Print numbers from 1 up to and including target.\n\n    Args:\n        target: The number to count up to\n\n    Example:\n        count_up_to(4) prints:\n        1\n        2\n        3\n        4\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create a variable called 'current' starting at 1\n    # Step 2: While current is less than or equal to target:\n    #         - Print current\n    #         - Increase current by 1\n    pass\n\n\n# ============================================================\n# {{PHASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n#\n# While loops can track totals as they iterate.\n\n\ndef sum_until_limit(limit):\n    \"\"\"\n    Add numbers 1, 2, 3, ... until the sum would exceed the limit.\n    Return the sum and how many numbers were added.\n\n    Args:\n        limit: Stop before the sum exceeds this value\n\n    Returns:\n        tuple: (final_sum, count_of_numbers)\n\n    Example:\n        sum_until_limit(10) returns (10, 4)\n        Because: 1+2+3+4=10, and 1+2+3+4+5=15 would exceed 10\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Initialize total = 0, next_number = 1, count = 0\n    # Step 2: While total + next_number <= limit:\n    #         - Add next_number to total\n    #         - Increase count by 1\n    #         - Increase next_number by 1\n    # Step 3: Return (total, count)\n    pass\n\n\n# ============================================================\n# {{PHASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n#\n# While loops with multiple conditions using 'and' or 'or'.\n\n\ndef process_batch(items_to_process, max_iterations):\n    \"\"\"\n    Process items one at a time, but stop early if you run out of items\n    OR if you reach max_iterations.\n\n    Args:\n        items_to_process: Starting number of items\n        max_iterations: Maximum number of processing rounds\n\n    Returns:\n        tuple: (items_processed, iterations_used)\n\n    Example:\n        process_batch(3, 10) returns (3, 3)  # Ran out of items\n        process_batch(100, 5) returns (5, 5)  # Hit iteration limit\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Initialize items_left = items_to_process, iterations = 0\n    # Step 2: While items_left > 0 AND iterations < max_iterations:\n    #         - Decrease items_left by 1\n    #         - Increase iterations by 1\n    #         - Print f\"Processed item. {items_left} remaining.\"\n    # Step 3: Return (iterations, iterations)  # items processed = iterations\n    pass\n\n\n# ============================================================\n# {{PHASE_5_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_5}}\n#\n# Accumulating results in a list while looping.\n\n\ndef generate_sequence(start, multiplier, length):\n    \"\"\"\n    Generate a sequence where each number is the previous times multiplier.\n\n    Args:\n        start: First number in sequence\n        multiplier: What to multiply by each time\n        length: How many numbers to generate\n\n    Returns:\n        list: The generated sequence\n\n    Example:\n        generate_sequence(2, 3, 4) returns [2, 6, 18, 54]\n        Because: 2, 2*3=6, 6*3=18, 18*3=54\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create an empty list called 'sequence'\n    # Step 2: Set current = start\n    # Step 3: While len(sequence) < length:\n    #         - Append current to sequence\n    #         - Multiply current by multiplier\n    # Step 4: Return sequence\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{PHASE_1_TITLE}} ===\")\n    print(\"Countdown:\")\n    countdown_from_five()\n\n    print(\"\\n=== {{PHASE_2_TITLE}} ===\")\n    print(\"Counting to 5:\")\n    count_up_to(5)\n\n    print(\"\\n=== {{PHASE_3_TITLE}} ===\")\n    result = sum_until_limit(10)\n    print(f\"Sum until 10: {result}\")\n\n    print(\"\\n=== {{PHASE_4_TITLE}} ===\")\n    print(\"Processing batch of 7 items with max 5 iterations:\")\n    result = process_batch(7, 5)\n    print(f\"Result: {result}\")\n\n    print(\"\\n=== {{PHASE_5_TITLE}} ===\")\n    seq = generate_sequence(2, 3, 5)\n    print(f\"Sequence: {seq}\")\n\n    print(\"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "write_code"
      ],
      "source_file": "module_5_games/write_code/exercise_1_basic_while.py"
    },
    {
      "id": "module_5_games.write_code.exercise_2_break_loops",
      "topic_id": "loops.while",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Break Loops",
      "title_en": "Break Loops",
      "title_he": "Break Loops",
      "description_en": "Games: Break Loops\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using break to exit loops early\nDifficulty: 2-3\n\nThe 'break' statement immediately exits the current loop.\nUse it when you've found what you're looking for or need to stop early.",
      "description_he": "משחקים: Break Loops\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using break to exit loops early\nDifficulty: 2-3\n\nThe 'break' statement immediately exits the current loop.\nUse it when you've found what you're looking for or need to stop early.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using break to exit loops early\nDifficulty: 2-3\n\nThe 'break' statement immediately exits the current loop.\nUse it when you've found what you're looking for or need to stop early.\n\"\"\"\n\n\n# ============================================================\n# {{PHASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n#\n# Use break to exit a loop when a condition is met.\n\n\ndef find_first_negative(numbers):\n    \"\"\"\n    Find the first negative number in a list.\n\n    Args:\n        numbers: A list of integers\n\n    Returns:\n        The first negative number, or None if all are non-negative\n\n    Example:\n        find_first_negative([3, 7, -2, 5, -8]) returns -2\n        find_first_negative([1, 2, 3]) returns None\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Set result = None\n    # Step 2: Loop through each number in numbers\n    # Step 3: If the number is negative:\n    #         - Set result to that number\n    #         - Break out of the loop\n    # Step 4: Return result\n    pass\n\n\n# ============================================================\n# {{PHASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n#\n# Use break with user input to create exit conditions.\n\n\ndef collect_names_until_done():\n    \"\"\"\n    Collect names from the user until they type 'done'.\n\n    Returns:\n        list: All the names collected (not including 'done')\n\n    The function should:\n    - Ask \"Enter a name (or 'done' to finish): \"\n    - Keep asking until user types 'done'\n    - Return the list of names collected\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create an empty list for names\n    # Step 2: Start an infinite loop (while True)\n    # Step 3: Ask for input\n    # Step 4: If input is 'done', break\n    # Step 5: Otherwise, add the name to the list\n    # Step 6: After the loop, return the list\n    pass\n\n\n# ============================================================\n# {{PHASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n#\n# Use break in a search to stop once you find the target.\n\n\ndef search_inventory(inventory, target):\n    \"\"\"\n    Search for a target item in an inventory.\n    Print each item checked, and stop when found.\n\n    Args:\n        inventory: List of items\n        target: Item to find\n\n    Returns:\n        int: Index where found, or -1 if not found\n\n    Example:\n        search_inventory([\"{{item}}\", \"{{pet}}\", \"{{creature}}\"], \"{{pet}}\")\n        Prints:\n            Checking: {{item}}\n            Checking: {{pet}}\n            Found {{pet}}!\n        Returns: 1\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Loop through inventory with index (use range(len(...)))\n    # Step 2: Print f\"Checking: {item}\"\n    # Step 3: If item equals target:\n    #         - Print f\"Found {target}!\"\n    #         - Return the index (using break or direct return)\n    # Step 4: After the loop, print f\"{target} not found.\"\n    # Step 5: Return -1\n    pass\n\n\n# ============================================================\n# {{PHASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n#\n# Use break with a counter limit to prevent infinite loops.\n\n\ndef safe_guess_loop():\n    \"\"\"\n    Let the user guess a secret word with a maximum of 5 attempts.\n\n    The secret word is \"{{password}}\".\n\n    Returns:\n        bool: True if guessed correctly, False if ran out of attempts\n\n    The function should:\n    - Give the user up to 5 attempts\n    - If they guess correctly, print a success message and return True\n    - If they run out of attempts, print failure message and return False\n    \"\"\"\n    secret = \"{{password}}\"\n    max_attempts = 5\n\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Set attempts = 0\n    # Step 2: While attempts < max_attempts:\n    #         - Increase attempts\n    #         - Ask for a guess\n    #         - If guess equals secret, print success and return True\n    # Step 3: After the loop, print failure message\n    # Step 4: Return False\n    pass\n\n\n# ============================================================\n# {{PHASE_5_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_5}}\n#\n# Combine break with complex conditions.\n\n\ndef process_until_error(data):\n    \"\"\"\n    Process data items until you encounter an error value.\n    Error values are: \"ERROR\", \"\", or None.\n\n    Args:\n        data: List of values to process\n\n    Returns:\n        list: Successfully processed values (before the error)\n\n    Example:\n        process_until_error([\"a\", \"b\", \"ERROR\", \"c\"]) returns [\"A\", \"B\"]\n        (Values are uppercased during processing, stops at ERROR)\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create an empty list for results\n    # Step 2: Loop through each item in data\n    # Step 3: If item is \"ERROR\", \"\", or None:\n    #         - Print f\"Error encountered! Stopping.\"\n    #         - Break\n    # Step 4: Process the item (convert to uppercase) and add to results\n    #         - Print f\"Processed: {processed_item}\"\n    # Step 5: Return results\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{PHASE_1_TITLE}} ===\")\n    numbers = [5, 12, 8, -3, 7, -1]\n    result = find_first_negative(numbers)\n    print(f\"First negative in {numbers}: {result}\")\n\n    print(\"\\n=== {{PHASE_2_TITLE}} ===\")\n    print(\"Collecting names (type 'done' to finish):\")\n    # Uncomment to test:\n    # names = collect_names_until_done()\n    # print(f\"Collected: {names}\")\n\n    print(\"\\n=== {{PHASE_3_TITLE}} ===\")\n    inventory = [\"{{item}}\", \"{{pet}}\", \"{{creature}}\", \"{{transport}}\"]\n    index = search_inventory(inventory, \"{{creature}}\")\n    print(f\"Found at index: {index}\")\n\n    print(\"\\n=== {{PHASE_4_TITLE}} ===\")\n    print(\"Guess the secret word:\")\n    # Uncomment to test:\n    # success = safe_guess_loop()\n    # print(f\"Result: {'Success!' if success else 'Failed'}\")\n\n    print(\"\\n=== {{PHASE_5_TITLE}} ===\")\n    test_data = [\"{{hero}}\", \"{{heroine}}\", \"ERROR\", \"{{friend}}\"]\n    processed = process_until_error(test_data)\n    print(f\"Processed items: {processed}\")\n\n    print(\"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "write_code"
      ],
      "source_file": "module_5_games/write_code/exercise_2_break_loops.py"
    },
    {
      "id": "module_5_games.write_code.exercise_3_continue_loops",
      "topic_id": "loops.while",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Continue Loops",
      "title_en": "Continue Loops",
      "title_he": "Continue Loops",
      "description_en": "Games: Continue Loops\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using continue to skip iterations\nDifficulty: 2-3\n\nThe 'continue' statement skips the rest of the current iteration\nand moves to the next one. Use it to skip unwanted items.",
      "description_he": "משחקים: Continue Loops\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using continue to skip iterations\nDifficulty: 2-3\n\nThe 'continue' statement skips the rest of the current iteration\nand moves to the next one. Use it to skip unwanted items.",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using continue to skip iterations\nDifficulty: 2-3\n\nThe 'continue' statement skips the rest of the current iteration\nand moves to the next one. Use it to skip unwanted items.\n\"\"\"\n\n\n# ============================================================\n# {{PHASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n#\n# Use continue to skip items that don't match criteria.\n\n\ndef print_positive_only(numbers):\n    \"\"\"\n    Print only the positive numbers from a list.\n    Skip zeros and negative numbers using continue.\n\n    Args:\n        numbers: A list of integers\n\n    Example:\n        print_positive_only([3, -1, 0, 5, -2, 8])\n        Prints:\n            3\n            5\n            8\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Loop through each number in numbers\n    # Step 2: If number is less than or equal to 0, continue\n    # Step 3: Print the number\n    pass\n\n\n# ============================================================\n# {{PHASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n#\n# Use continue to filter during processing.\n\n\ndef filter_and_transform(items):\n    \"\"\"\n    Process items but skip any that are empty strings.\n    Transform valid items to uppercase.\n\n    Args:\n        items: A list of strings\n\n    Returns:\n        list: Uppercase versions of non-empty strings\n\n    Example:\n        filter_and_transform([\"{{hero}}\", \"\", \"{{villain}}\", \"\"])\n        Returns: [\"{{HERO}}\", \"{{VILLAIN}}\"]  # (uppercase versions)\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create an empty result list\n    # Step 2: Loop through each item\n    # Step 3: If item is an empty string \"\", continue\n    # Step 4: Convert to uppercase and add to result\n    # Step 5: Return result\n    pass\n\n\n# ============================================================\n# {{PHASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n#\n# Use continue with index-based loops.\n\n\ndef process_every_other(values):\n    \"\"\"\n    Process only items at even indices (0, 2, 4, ...).\n    Skip items at odd indices using continue.\n\n    Args:\n        values: A list of values\n\n    Returns:\n        list: Items from even indices only\n\n    Example:\n        process_every_other([\"A\", \"B\", \"C\", \"D\", \"E\"])\n        Returns: [\"A\", \"C\", \"E\"]  # indices 0, 2, 4\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create an empty result list\n    # Step 2: Loop with index: for i in range(len(values))\n    # Step 3: If i is odd (i % 2 != 0), continue\n    # Step 4: Add values[i] to result\n    # Step 5: Return result\n    pass\n\n\n# ============================================================\n# {{PHASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n#\n# Combine continue with while loops.\n\n\ndef sum_valid_inputs():\n    \"\"\"\n    Collect numbers from user and sum them.\n    Skip invalid inputs (non-numeric) using continue.\n    Stop when user enters 'done'.\n\n    Returns:\n        int: Sum of all valid numbers entered\n\n    The function should:\n    - Ask for input repeatedly\n    - If input is 'done', stop and return the sum\n    - If input is not a valid integer, print error and continue\n    - If input is valid, add to sum\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Set total = 0\n    # Step 2: While True:\n    #         - Get input\n    #         - If input is 'done', break\n    #         - If input.isdigit() or (input.startswith('-') and input[1:].isdigit()):\n    #           Add int(input) to total\n    #         - Else: print \"Invalid number, skipping.\" and continue\n    # Step 3: Return total\n    #\n    # Note: Use .lstrip('-').isdigit() to check for negative numbers\n    pass\n\n\n# ============================================================\n# {{PHASE_5_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_5}}\n#\n# Use continue with complex skip conditions.\n\n\ndef process_approved_items(items, blocked_list):\n    \"\"\"\n    Process items unless they are in the blocked list.\n    Skip blocked items using continue.\n\n    Args:\n        items: List of items to process\n        blocked_list: List of items to skip\n\n    Returns:\n        list: Processed (lowercase) items that weren't blocked\n\n    Example:\n        process_approved_items(\n            [\"{{hero}}\", \"{{villain}}\", \"{{friend}}\"],\n            [\"{{villain}}\"]\n        )\n        Returns: [\"{{hero}}\", \"{{friend}}\"]  # lowercase versions\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create an empty result list\n    # Step 2: Loop through each item\n    # Step 3: If item is in blocked_list:\n    #         - Print f\"Blocked: {item}\"\n    #         - Continue\n    # Step 4: Process item (convert to lowercase) and add to result\n    #         - Print f\"Approved: {item}\"\n    # Step 5: Return result\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{PHASE_1_TITLE}} ===\")\n    numbers = [5, -3, 0, 8, -1, 12, 0, -7]\n    print(f\"Numbers: {numbers}\")\n    print(\"Positive only:\")\n    print_positive_only(numbers)\n\n    print(\"\\n=== {{PHASE_2_TITLE}} ===\")\n    items = [\"{{hero}}\", \"\", \"{{villain}}\", \"\", \"{{friend}}\"]\n    result = filter_and_transform(items)\n    print(f\"Filtered and transformed: {result}\")\n\n    print(\"\\n=== {{PHASE_3_TITLE}} ===\")\n    values = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]\n    result = process_every_other(values)\n    print(f\"Every other item: {result}\")\n\n    print(\"\\n=== {{PHASE_4_TITLE}} ===\")\n    print(\"Sum numbers (type 'done' to finish):\")\n    # Uncomment to test:\n    # total = sum_valid_inputs()\n    # print(f\"Sum: {total}\")\n\n    print(\"\\n=== {{PHASE_5_TITLE}} ===\")\n    all_items = [\"{{hero}}\", \"{{villain}}\", \"{{friend}}\", \"{{mentor}}\"]\n    blocked = [\"{{villain}}\"]\n    result = process_approved_items(all_items, blocked)\n    print(f\"Approved items: {result}\")\n\n    print(\"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "write_code"
      ],
      "source_file": "module_5_games/write_code/exercise_3_continue_loops.py"
    },
    {
      "id": "module_5_games.write_code.exercise_4_random_basics",
      "topic_id": "loops.while",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Random Basics",
      "title_en": "Random Basics",
      "title_he": "Random Basics",
      "description_en": "Games: Random Basics\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using the random module\nDifficulty: 2-3\n\nThe random module lets you generate random numbers and make random choices.\nEssential for games with unpredictable elements!",
      "description_he": "משחקים: Random Basics\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using the random module\nDifficulty: 2-3\n\nThe random module lets you generate random numbers and make random choices.\nEssential for games with unpredictable elements!",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Using the random module\nDifficulty: 2-3\n\nThe random module lets you generate random numbers and make random choices.\nEssential for games with unpredictable elements!\n\"\"\"\n\nimport random\n\n\n# ============================================================\n# {{PHASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n#\n# random.randint(a, b) returns a random integer from a to b INCLUSIVE.\n# Unlike range(), both endpoints are included!\n\n\ndef roll_dice(num_sides):\n    \"\"\"\n    Roll a single die with the given number of sides.\n\n    Args:\n        num_sides: Number of sides on the die (e.g., 6 for standard die)\n\n    Returns:\n        int: A random number from 1 to num_sides\n\n    Example:\n        roll_dice(6) might return 1, 2, 3, 4, 5, or 6\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Use random.randint(1, num_sides) to get a number from 1 to num_sides\n    pass\n\n\ndef roll_multiple_dice(num_dice, num_sides):\n    \"\"\"\n    Roll multiple dice and return the total.\n\n    Args:\n        num_dice: How many dice to roll\n        num_sides: Number of sides per die\n\n    Returns:\n        int: Sum of all dice rolls\n\n    Example:\n        roll_multiple_dice(2, 6) might return any value from 2 to 12\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Initialize total = 0\n    # Step 2: Loop num_dice times\n    # Step 3: Add a random roll to total\n    # Step 4: Return total\n    pass\n\n\n# ============================================================\n# {{PHASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n#\n# random.choice(sequence) picks a random item from a list or string.\n\n\ndef pick_random_item(items):\n    \"\"\"\n    Pick a random item from a list.\n\n    Args:\n        items: A non-empty list\n\n    Returns:\n        A randomly selected item from the list\n\n    Example:\n        pick_random_item([\"{{hero}}\", \"{{villain}}\", \"{{friend}}\"])\n        might return any of those three names\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Use random.choice(items)\n    pass\n\n\ndef generate_random_name():\n    \"\"\"\n    Generate a random name by combining a random adjective and noun.\n\n    Returns:\n        str: A randomly generated name like \"Swift {{creature}}\"\n\n    Use these lists:\n        adjectives = [\"Swift\", \"Brave\", \"Clever\", \"Mighty\", \"Silent\"]\n        nouns = [\"{{creature}}\", \"{{hero}}\", \"{{villain}}\"]\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Create the adjectives list\n    # Step 2: Create the nouns list\n    # Step 3: Pick random adjective with random.choice()\n    # Step 4: Pick random noun with random.choice()\n    # Step 5: Return f\"{adjective} {noun}\"\n    pass\n\n\n# ============================================================\n# {{PHASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n#\n# random.random() returns a float from 0.0 to 1.0 (exclusive).\n# Useful for percentage-based chances.\n\n\ndef chance_event(probability):\n    \"\"\"\n    Return True with the given probability, False otherwise.\n\n    Args:\n        probability: Float from 0.0 to 1.0 (e.g., 0.7 for 70% chance)\n\n    Returns:\n        bool: True if the event happens, False otherwise\n\n    Example:\n        chance_event(0.5) returns True about 50% of the time\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # If random.random() < probability, return True\n    # Otherwise return False\n    pass\n\n\ndef attempt_action(success_rate):\n    \"\"\"\n    Attempt an action that might succeed or fail.\n\n    Args:\n        success_rate: Float from 0.0 to 1.0 (chance of success)\n\n    Returns:\n        str: \"success\" or \"failure\"\n\n    Also prints the result:\n        \"{{exclamation}} Success!\" or \"Failed...\"\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Use chance_event() to determine if successful\n    # Print the appropriate message\n    # Return \"success\" or \"failure\"\n    pass\n\n\n# ============================================================\n# {{PHASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n#\n# Combine random functions to create game mechanics.\n\n\ndef weighted_random_choice(options, weights):\n    \"\"\"\n    Choose from options with weighted probabilities.\n\n    Args:\n        options: List of choices\n        weights: List of weights (must sum to 1.0)\n\n    Returns:\n        A randomly chosen option based on weights\n\n    Example:\n        weighted_random_choice([\"common\", \"rare\", \"legendary\"], [0.7, 0.25, 0.05])\n        Returns \"common\" 70%, \"rare\" 25%, \"legendary\" 5%\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Get a random float with random.random()\n    # Step 2: Track cumulative probability\n    # Step 3: Loop through options and weights together\n    #         - Add weight to cumulative\n    #         - If random value < cumulative, return that option\n    # Step 4: Return last option (safety fallback)\n    #\n    # Hint: Use zip(options, weights) to loop through both\n    pass\n\n\ndef generate_loot():\n    \"\"\"\n    Generate random loot with rarities.\n\n    Returns:\n        tuple: (item_name, rarity)\n\n    Rarities:\n        - \"common\" (60% chance)\n        - \"uncommon\" (25% chance)\n        - \"rare\" (12% chance)\n        - \"legendary\" (3% chance)\n\n    Use placeholder items based on rarity:\n        - common: \"{{item}}\"\n        - uncommon: \"Enhanced {{item}}\"\n        - rare: \"{{creature}}'s {{item}}\"\n        - legendary: \"{{hero}}'s Legendary {{item}}\"\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Define rarities and weights\n    # Step 2: Use weighted_random_choice to pick rarity\n    # Step 3: Create item name based on rarity\n    # Step 4: Return (item_name, rarity)\n    pass\n\n\n# ============================================================\n# {{PHASE_5_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_5}}\n#\n# Generate random numbers within ranges for game scenarios.\n\n\ndef generate_stats():\n    \"\"\"\n    Generate random stats for a character.\n\n    Returns:\n        dict: Character stats\n\n    Stats to generate:\n        - \"strength\": random 5-15\n        - \"agility\": random 5-15\n        - \"wisdom\": random 5-15\n        - \"luck\": random 1-10\n\n    Also calculate:\n        - \"power\": strength + agility\n        - \"total\": sum of all four base stats\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Generate each base stat with random.randint()\n    # Step 2: Calculate derived stats\n    # Step 3: Return dictionary with all stats\n    pass\n\n\ndef simulate_battle_round(attacker_power, defender_power):\n    \"\"\"\n    Simulate one round of battle between attacker and defender.\n\n    Args:\n        attacker_power: Attacker's power stat\n        defender_power: Defender's power stat\n\n    Returns:\n        tuple: (attacker_damage_dealt, defender_damage_dealt)\n\n    Damage formula:\n        base_damage = power // 3\n        actual_damage = base_damage + random.randint(0, 5)\n\n    Example:\n        simulate_battle_round(15, 12) might return (7, 6)\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Calculate attacker's damage\n    # Calculate defender's damage\n    # Return both as a tuple\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{PHASE_1_TITLE}} ===\")\n    print(f\"Rolling a 6-sided die: {roll_dice(6)}\")\n    print(f\"Rolling a 20-sided die: {roll_dice(20)}\")\n    print(f\"Rolling 3d6: {roll_multiple_dice(3, 6)}\")\n\n    print(\"\\n=== {{PHASE_2_TITLE}} ===\")\n    characters = [\"{{hero}}\", \"{{villain}}\", \"{{friend}}\", \"{{mentor}}\"]\n    print(f\"Random character: {pick_random_item(characters)}\")\n    print(f\"Random name: {generate_random_name()}\")\n\n    print(\"\\n=== {{PHASE_3_TITLE}} ===\")\n    print(\"Attempting action with 75% success rate:\")\n    attempt_action(0.75)\n\n    print(\"\\n=== {{PHASE_4_TITLE}} ===\")\n    print(\"Generating loot:\")\n    item, rarity = generate_loot()\n    print(f\"Found: {item} ({rarity})\")\n\n    print(\"\\n=== {{PHASE_5_TITLE}} ===\")\n    print(\"Generating character stats:\")\n    stats = generate_stats()\n    print(f\"Stats: {stats}\")\n    print(\"\\nSimulating battle round (power 15 vs 12):\")\n    atk_dmg, def_dmg = simulate_battle_round(15, 12)\n    print(f\"Attacker dealt {atk_dmg}, Defender dealt {def_dmg}\")\n\n    print(\"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "write_code"
      ],
      "source_file": "module_5_games/write_code/exercise_4_random_basics.py"
    },
    {
      "id": "module_5_games.write_code.exercise_5_input_functions",
      "topic_id": "loops.while",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Input Functions",
      "title_en": "Input Functions",
      "title_he": "Input Functions",
      "description_en": "Games: Input Functions\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Building robust input functions\nDifficulty: 3\n\nCreate reusable input functions that validate user input.\nThese can be used in any game or interactive program!",
      "description_he": "משחקים: Input Functions\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Building robust input functions\nDifficulty: 3\n\nCreate reusable input functions that validate user input.\nThese can be used in any game or interactive program!",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Building robust input functions\nDifficulty: 3\n\nCreate reusable input functions that validate user input.\nThese can be used in any game or interactive program!\n\"\"\"\n\n\n# ============================================================\n# {{PHASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n#\n# Build a function that gets an integer within a specified range.\n\n\ndef get_integer_in_range(prompt, min_val, max_val):\n    \"\"\"\n    Get an integer from the user within a specified range.\n\n    Args:\n        prompt: Message to display when asking for input\n        min_val: Minimum acceptable value (inclusive)\n        max_val: Maximum acceptable value (inclusive)\n\n    Returns:\n        int: A valid integer within the range\n\n    The function should:\n    - Display the prompt\n    - Validate input is numeric\n    - Validate input is within range\n    - Show helpful error messages\n    - Keep asking until valid input received\n\n    Example:\n        get_integer_in_range(\"Pick 1-10: \", 1, 10)\n        User enters \"abc\" -> \"Please enter a number.\"\n        User enters \"15\" -> \"Must be between 1 and 10.\"\n        User enters \"5\" -> returns 5\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Start while True loop\n    # Step 2: Print prompt and get input\n    # Step 3: Check if numeric using .lstrip('-').isdigit()\n    #         If not, print \"Please enter a number.\" and continue\n    # Step 4: Convert to int\n    # Step 5: Check if in range\n    #         If not, print f\"Must be between {min_val} and {max_val}.\" and continue\n    # Step 6: Return valid integer\n    pass\n\n\n# ============================================================\n# {{PHASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n#\n# Build a function that gets a choice from a list of options.\n\n\ndef get_choice_from_list(prompt, options):\n    \"\"\"\n    Get user to choose from a list of options.\n\n    Args:\n        prompt: Message to display\n        options: List of valid choices (strings)\n\n    Returns:\n        str: The chosen option (matching case of original)\n\n    The function should:\n    - Display numbered options\n    - Accept either the number or the text\n    - Case-insensitive text matching\n    - Keep asking until valid\n\n    Example:\n        get_choice_from_list(\"Choose:\", [\"{{spell1}}\", \"{{spell2}}\", \"{{spell3}}\"])\n        Displays:\n            Choose:\n            1. {{spell1}}\n            2. {{spell2}}\n            3. {{spell3}}\n        User can enter \"1\" or \"{{spell1}}\" to select first option\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Print prompt\n    # Step 2: Print numbered list of options\n    # Step 3: Start while True loop\n    # Step 4: Get input (lowercase for comparison)\n    # Step 5: Check if input is a valid number (1 to len(options))\n    #         If so, return options[int(input) - 1]\n    # Step 6: Check if input matches any option (case insensitive)\n    #         If so, return the original option\n    # Step 7: Print \"Invalid choice. Try again.\"\n    pass\n\n\n# ============================================================\n# {{PHASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n#\n# Build a function that gets a yes/no answer with custom prompts.\n\n\ndef get_yes_no(question, yes_text=\"yes\", no_text=\"no\"):\n    \"\"\"\n    Get a yes/no answer from the user.\n\n    Args:\n        question: The question to ask\n        yes_text: Text to display for yes option (default \"yes\")\n        no_text: Text to display for no option (default \"no\")\n\n    Returns:\n        bool: True for yes, False for no\n\n    The function should:\n    - Display question with options\n    - Accept first letter or full word\n    - Case insensitive\n    - Keep asking until valid\n\n    Example:\n        get_yes_no(\"Continue?\")\n        Displays: \"Continue? (yes/no): \"\n        Accepts: y, yes, Y, YES, n, no, N, NO\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Start while True loop\n    # Step 2: Print f\"{question} ({yes_text}/{no_text}): \" and get input\n    # Step 3: Convert to lowercase and strip\n    # Step 4: If matches yes_text or its first letter, return True\n    # Step 5: If matches no_text or its first letter, return False\n    # Step 6: Print f\"Please enter {yes_text} or {no_text}.\"\n    pass\n\n\n# ============================================================\n# {{PHASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n#\n# Build a function that gets a non-empty string with validation.\n\n\ndef get_validated_string(prompt, validator_func, error_message):\n    \"\"\"\n    Get a string that passes a custom validation function.\n\n    Args:\n        prompt: Message to display\n        validator_func: Function that takes string, returns True if valid\n        error_message: Message to show if validation fails\n\n    Returns:\n        str: A string that passed validation\n\n    Example:\n        # Get a name that's at least 2 characters\n        def at_least_two(s):\n            return len(s) >= 2\n\n        get_validated_string(\"Name: \", at_least_two, \"Name must be at least 2 chars\")\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Start while True loop\n    # Step 2: Print prompt and get input\n    # Step 3: If validator_func(input) returns True, return input\n    # Step 4: Otherwise print error_message\n    pass\n\n\n# ============================================================\n# {{PHASE_5_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_5}}\n#\n# Use your input functions to build a character creator.\n\n\ndef create_character():\n    \"\"\"\n    Create a character using robust input functions.\n\n    Collect:\n    - Name: Non-empty string, at least 2 characters\n    - Class: Choice from [\"{{spell1}}\", \"{{spell2}}\", \"{{spell3}}\"]\n    - Level: Integer from 1 to 20\n    - Confirm: Yes/no to create\n\n    Returns:\n        dict: Character data, or None if cancelled\n\n    Example output:\n        Character Creator\n        -----------------\n        Name: (gets validated name)\n        Class: (shows choices, gets selection)\n        Level (1-20): (gets valid level)\n        Create this character? (yes/no):\n        (If yes, returns character dict)\n    \"\"\"\n    print(\"=\" * 40)\n    print(\"   CHARACTER CREATOR\")\n    print(\"=\" * 40)\n    print()\n\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Step 1: Get name using get_validated_string\n    #         (validator: len >= 2, error: \"Name must be at least 2 characters\")\n    # Step 2: Get character class using get_choice_from_list\n    # Step 3: Get level using get_integer_in_range\n    # Step 4: Display summary\n    # Step 5: Confirm with get_yes_no\n    # Step 6: If confirmed, return dict with name, class, level\n    # Step 7: If not confirmed, return None\n    pass\n\n\ndef main():\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{PHASE_1_TITLE}} ===\")\n    print(\"Testing integer range input:\")\n    # level = get_integer_in_range(\"Enter level (1-10): \", 1, 10)\n    # print(f\"Level selected: {level}\")\n\n    print(\"\\n=== {{PHASE_2_TITLE}} ===\")\n    print(\"Testing choice from list:\")\n    # abilities = [\"{{spell1}}\", \"{{spell2}}\", \"{{spell3}}\"]\n    # choice = get_choice_from_list(\"Select ability:\", abilities)\n    # print(f\"Selected: {choice}\")\n\n    print(\"\\n=== {{PHASE_3_TITLE}} ===\")\n    print(\"Testing yes/no:\")\n    # answer = get_yes_no(\"Do you want to continue?\")\n    # print(f\"Answer: {answer}\")\n\n    print(\"\\n=== {{PHASE_4_TITLE}} ===\")\n    print(\"Testing validated string:\")\n    # def is_long_enough(s):\n    #     return len(s) >= 3\n    # name = get_validated_string(\"Enter name (3+ chars): \", is_long_enough, \"Too short!\")\n    # print(f\"Name: {name}\")\n\n    print(\"\\n=== {{PHASE_5_TITLE}} ===\")\n    print(\"Testing character creator:\")\n    # character = create_character()\n    # if character:\n    #     print(f\"\\nCreated: {character}\")\n    # else:\n    #     print(\"\\nCancelled.\")\n\n    print(\"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "write_code"
      ],
      "source_file": "module_5_games/write_code/exercise_5_input_functions.py"
    },
    {
      "id": "module_5_games.write_code.exercise_6_simple_game",
      "topic_id": "loops.while",
      "exercise_type": "write_code",
      "category": "free_writing",
      "title": "Simple Game",
      "title_en": "Simple Game",
      "title_he": "Simple Game",
      "description_en": "Games: Simple Game\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Building a complete simple game\nDifficulty: 4-5\n\nCombine everything you've learned to build a complete,\nplayable game with loops, random, input validation, and state!",
      "description_he": "משחקים: Simple Game\n\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Building a complete simple game\nDifficulty: 4-5\n\nCombine everything you've learned to build a complete,\nplayable game with loops, random, input validation, and state!",
      "difficulty": 3,
      "requires_running": true,
      "estimated_time_minutes": 10,
      "skills": [
        "implementation",
        "problem_solving",
        "syntax"
      ],
      "starter_code": "\"\"\"\n{{CONTEXT_PROJECT_INTRO}}\n{{CONTEXT_LEARNING_OBJECTIVE}}\n\nTopic: Building a complete simple game\nDifficulty: 4-5\n\nCombine everything you've learned to build a complete,\nplayable game with loops, random, input validation, and state!\n\"\"\"\n\nimport random\n\n\n# ============================================================\n# {{PHASE_1_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_1}}\n#\n# Build the core game mechanics.\n\n\ndef roll_stat():\n    \"\"\"\n    Roll a random stat value.\n\n    Returns:\n        int: Random value from 3 to 18 (like 3d6)\n\n    Roll three 6-sided dice and sum them.\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef create_character(name):\n    \"\"\"\n    Create a new character with random stats.\n\n    Args:\n        name: The character's name\n\n    Returns:\n        dict: Character with name, hp, max_hp, attack, defense\n\n    Stats:\n    - max_hp: roll_stat() + 10\n    - hp: starts equal to max_hp\n    - attack: roll_stat()\n    - defense: roll_stat() // 2\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef create_enemy(name, difficulty):\n    \"\"\"\n    Create an enemy scaled to difficulty.\n\n    Args:\n        name: Enemy name\n        difficulty: 1-3 (easy, medium, hard)\n\n    Returns:\n        dict: Enemy with name, hp, max_hp, attack, defense\n\n    Scale:\n    - hp: 10 + (difficulty * 5) + random 1-5\n    - attack: 5 + (difficulty * 2) + random 1-3\n    - defense: 2 + difficulty\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\n# ============================================================\n# {{PHASE_2_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_2}}\n#\n# Build the combat system.\n\n\ndef calculate_damage(attacker, defender):\n    \"\"\"\n    Calculate damage from attacker to defender.\n\n    Args:\n        attacker: Dict with 'attack' stat\n        defender: Dict with 'defense' stat\n\n    Returns:\n        int: Damage dealt (minimum 1)\n\n    Formula: attacker['attack'] - defender['defense'] + random(-2, 2)\n    Always deal at least 1 damage.\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef attack(attacker, defender):\n    \"\"\"\n    Perform an attack.\n\n    Args:\n        attacker: The attacking character dict\n        defender: The defending character dict\n\n    Returns:\n        int: Damage dealt\n\n    Process:\n    1. Calculate damage\n    2. Subtract from defender's hp\n    3. Print attack message with damage\n    4. Return damage dealt\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef is_alive(character):\n    \"\"\"\n    Check if a character is still alive.\n\n    Args:\n        character: Character dict with 'hp'\n\n    Returns:\n        bool: True if hp > 0\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\n# ============================================================\n# {{PHASE_3_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_3}}\n#\n# Build player actions.\n\n\ndef player_attack(player, enemy):\n    \"\"\"\n    Player performs a basic attack.\n\n    Args:\n        player: Player character dict\n        enemy: Enemy character dict\n\n    Returns:\n        int: Damage dealt\n    \"\"\"\n    print(f\"\\n{{{{hero}}}} attacks {{{{villain}}}}!\")\n    return attack(player, enemy)\n\n\ndef player_defend(player):\n    \"\"\"\n    Player takes defensive stance.\n\n    Args:\n        player: Player character dict\n\n    Returns:\n        int: Temporary defense bonus (3)\n\n    Also prints a message about defending.\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # Print defending message\n    # Return 3 (temporary defense bonus)\n    pass\n\n\ndef player_heal(player):\n    \"\"\"\n    Player attempts to heal.\n\n    Args:\n        player: Player character dict\n\n    Returns:\n        int: Amount healed\n\n    Healing:\n    - Heal 5 + random(1, 5) hp\n    - Cannot exceed max_hp\n    - Print message with amount healed\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef get_player_action():\n    \"\"\"\n    Get the player's action choice.\n\n    Returns:\n        str: 'attack', 'defend', or 'heal'\n\n    Display menu:\n    1. Attack\n    2. Defend\n    3. Heal\n\n    Accept number (1-3) or word.\n    Keep asking until valid.\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\n# ============================================================\n# {{PHASE_4_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_4}}\n#\n# Build the combat loop.\n\n\ndef display_status(player, enemy):\n    \"\"\"\n    Display current combat status.\n\n    Format:\n        ========================================\n        {{hero}}: 25/30 HP    {{villain}}: 15/20 HP\n        ========================================\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef combat_round(player, enemy, defending):\n    \"\"\"\n    Execute one round of combat.\n\n    Args:\n        player: Player character dict\n        enemy: Enemy character dict\n        defending: Bool, True if player defended last turn\n\n    Returns:\n        tuple: (player_alive, enemy_alive, now_defending)\n\n    Round structure:\n    1. Get player action\n    2. Execute player action\n    3. If enemy still alive, enemy attacks\n       - If player was defending, reduce damage\n    4. Return status\n    \"\"\"\n    # ✏️ YOUR CODE HERE ✏️\n    pass\n\n\ndef battle(player, enemy):\n    \"\"\"\n    Run a complete battle.\n\n    Args:\n        player: Player character dict\n        enemy: Enemy character dict\n\n    Returns:\n        bool: True if player won\n\n    Battle loop:\n    1. Display status\n    2. Run combat round\n    3. Check for battle end\n    4. Repeat until someone loses\n    5. Announce winner\n    \"\"\"\n    print(\"\\n\" + \"=\" * 50)\n    print(f\"   BATTLE: {{{{hero}}}} vs {enemy['name']}\")\n    print(\"=\" * 50)\n\n    defending = False\n\n    # ✏️ YOUR CODE HERE ✏️\n    #\n    # While both alive:\n    #   1. Display status\n    #   2. Run combat round, get new defending state\n    #   3. Check if battle over\n    #\n    # After loop: Announce winner, return result\n    pass\n\n\n# ============================================================\n# {{PHASE_5_TITLE}}\n# ============================================================\n# {{CONTEXT_PHASE_5}}\n#\n# Build the complete game.\n\n\ndef introduction():\n    \"\"\"\n    Display game introduction.\n    \"\"\"\n    print(\"=\" * 50)\n    print(\"   ARENA CHAMPION\")\n    print(f\"   A {{{{school}}}} Adventure\")\n    print(\"=\" * 50)\n    print()\n    print(f\"{{{{hero}}}} enters {{{{location}}}} to face {{{{villain}}}}!\")\n    print(\"Victory means glory. Defeat means... starting over.\")\n    print()\n\n\ndef play_game():\n    \"\"\"\n    Run the complete game.\n\n    Structure:\n    1. Introduction\n    2. Create player character\n    3. Fight through 3 enemies of increasing difficulty\n    4. Track wins/losses\n    5. Offer play again\n\n    Game flow:\n    - Player starts fresh each game\n    - Fight enemy 1 (easy), enemy 2 (medium), enemy 3 (hard)\n    - After each battle, restore some HP if won\n    - If player loses, game over\n    - If player wins all 3, victory!\n    \"\"\"\n    introduction()\n\n    playing = True\n    while playing:\n        print(\"\\n--- Creating your champion ---\")\n        name = input(\"Enter your champion's name: \").strip()\n        if not name:\n            name = \"{{hero}}\"\n\n        player = create_character(name)\n        print(f\"\\n{name} enters the arena!\")\n        print(f\"HP: {player['hp']} | Attack: {player['attack']} | Defense: {player['defense']}\")\n\n        # ✏️ YOUR CODE HERE ✏️\n        #\n        # Create three enemies with increasing difficulty:\n        # enemies = [\n        #     create_enemy(\"{{creature}}\", 1),\n        #     create_enemy(\"{{villain}}'s Minion\", 2),\n        #     create_enemy(\"{{villain}}\", 3)\n        # ]\n        #\n        # Battle loop:\n        # For each enemy:\n        #   1. Print \"Battle X of 3\"\n        #   2. Run battle\n        #   3. If lost, print game over, break\n        #   4. If won and not last battle, restore 10 HP\n        #\n        # If completed all battles: Victory message!\n        #\n        # Ask to play again\n        pass\n\n\ndef main():\n    print(\"{{CONTEXT_PROJECT_INTRO}}\")\n    print(\"=\" * 50)\n\n    print(\"\\n=== {{PHASE_1_TITLE}} ===\")\n    print(\"Testing character creation:\")\n    # player = create_character(\"Test\")\n    # print(f\"Player: {player}\")\n    # enemy = create_enemy(\"Goblin\", 2)\n    # print(f\"Enemy: {enemy}\")\n\n    print(\"\\n=== {{PHASE_2_TITLE}} ===\")\n    print(\"Testing combat:\")\n    # player = create_character(\"Test\")\n    # enemy = create_enemy(\"Target\", 1)\n    # damage = attack(player, enemy)\n    # print(f\"Enemy HP: {enemy['hp']}\")\n\n    print(\"\\n=== {{PHASE_3_TITLE}} ===\")\n    print(\"Testing player actions:\")\n    # (test individual actions)\n\n    print(\"\\n=== {{PHASE_4_TITLE}} ===\")\n    print(\"Testing battle:\")\n    # player = create_character(\"Champion\")\n    # enemy = create_enemy(\"Challenger\", 1)\n    # result = battle(player, enemy)\n    # print(f\"Player won: {result}\")\n\n    print(\"\\n=== {{PHASE_5_TITLE}} ===\")\n    print(\"Launch full game:\")\n    # play_game()\n\n    print(\"=\" * 50)\n    print(\"{{CONTEXT_FINAL_ASSEMBLY}}\")\n\n\nmain()\n",
      "solution_code": null,
      "hints": [],
      "tags": [
        "module_5_games",
        "write_code"
      ],
      "source_file": "module_5_games/write_code/exercise_6_simple_game.py"
    }
  ]
}